---
alwaysApply: true
---
# 🛡️ SmartAbp代码质量强制执行规则

## ⚡ 质量铁律（零容错）

### 0. BUG修复铁律（最高优先级）
**🚨 修复错误时绝对禁止的行为：**

```typescript
// ❌ 绝对禁止：删除报错代码来"修复"错误
// function problematicFunction(param: string) {
//   return param.toUpperCase(); // 被删除
// }

// ❌ 绝对禁止：使用as any绕过类型检查
const result = unknownValue as any; // 严禁

// ❌ 绝对禁止：使用_前缀规避"未使用"警告  
function process(_unusedParam: string, data: Data) {} // 严禁

// ❌ 绝对禁止：注释掉报错代码
// const problematicCode = getValue(); // 严禁

// ✅ 正确做法：深入理解错误，实现功能性修复
interface ProcessedData {
  value: string;
  processed: boolean;
}

function processData(inputParam: string): ProcessedData {
  // 理解inputParam的作用，正确使用
  return {
    value: inputParam.toUpperCase(),
    processed: true
  };
}
```

**🔴 BUG修复黄金准则：**
1. **深入理解错误根源** - 不是症状，是根本原因
2. **查阅相关文档和API** - 使用正确的接口和参数
3. **增强功能而非删减** - 修复的同时提升代码质量
4. **保持类型安全** - 绝不使用any或强制类型转换逃避
5. **测试修复效果** - 确保修复没有引入新问题

### 1. 构建质量检查
**🔴 每次代码修改后强制执行：**

```bash
# 必须按顺序执行，全部通过才能继续
npm run build        # ❌ 任何构建错误 = 立即停止
npm run type-check   # ❌ 任何类型错误 = 立即停止  
npm run lint --fix   # ❌ 任何lint错误 = 立即停止
npm run dev          # ❌ 运行时错误 = 立即停止
```

### 2. 代码重复检测
**🔴 严禁任何形式的代码重复：**

```typescript
// ❌ 严禁：重复的函数实现
// 文件A
function formatDate(date: Date): string {
  return date.toLocaleDateString()
}

// 文件B  
function formatDate(date: Date): string {  // ❌ 重复实现
  return date.toLocaleDateString()
}

// ✅ 正确：共享工具函数
// utils/dateUtils.ts
export function formatDate(date: Date): string {
  return date.toLocaleDateString()
}
```

### 3. TypeScript严格模式
**🔴 强制启用所有严格检查：**

```json
// tsconfig.json - 强制配置
{
  "compilerOptions": {
    "strict": true,                    // ✅ 必须启用
    "noImplicitAny": true,            // ✅ 禁止隐式any
    "strictNullChecks": true,         // ✅ 严格空值检查
    "strictFunctionTypes": true,      // ✅ 严格函数类型
    "noImplicitReturns": true,        // ✅ 必须显式返回
    "noUnusedLocals": true,           // ✅ 禁止未使用变量
    "noUnusedParameters": true        // ✅ 禁止未使用参数
  }
}
```

### 4. ESLint强制规则
**🔴 强制执行的代码规范：**

```typescript
// ✅ 强制使用：明确的类型定义
interface UserInfo {
  id: string
  name: string
  email: string
  createdAt: Date
}

const user: UserInfo = {
  id: '123',
  name: 'John',
  email: 'john@example.com',
  createdAt: new Date()
}

// ❌ 严禁：类型推断的危险用法
const user = {  // ❌ 没有明确类型
  id: '123',
  name: 'John'
}
```

## 🧹 代码清洁度强制要求

### 函数复杂度限制
```typescript
// ✅ 正确：简单明确的函数
function validateEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}

// ❌ 严禁：复杂的巨型函数（圈复杂度 > 10）
function complexValidation(data: any): any {  // ❌ 禁止
  if (data.type === 'user') {
    if (data.email) {
      if (data.email.includes('@')) {
        if (data.name) {
          if (data.name.length > 2) {
            // ... 超过10层嵌套 = 禁止
          }
        }
      }
    }
  }
}
```

### 命名清晰度要求
```typescript
// ✅ 强制使用：语义明确的命名
const getUserById = async (userId: string): Promise<UserInfo> => {
  const user = await userRepository.findById(userId)
  if (!user) {
    throw new Error(`User with id ${userId} not found`)
  }
  return user
}

// ❌ 严禁：模糊的命名
const getData = async (id: any): Promise<any> => {  // ❌ 禁止
  const result = await repo.find(id)  // ❌ 禁止
  return result
}
```

## 📏 文件大小限制

### 强制文件大小限制
```typescript
// ✅ 允许的文件大小
// Vue组件: < 300行
// TypeScript文件: < 500行
// 工具函数文件: < 200行

// ❌ 超过限制必须拆分
// 单个Vue组件 > 300行 = 强制拆分为多个组件
// 单个TS文件 > 500行 = 强制拆分为多个模块
```

### 组件复杂度控制
```vue
<!-- ✅ 正确：简单专注的组件 -->
<template>
  <div class="user-card">
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
  </div>
</template>

<script setup lang="ts">
interface Props {
  user: UserInfo
}

defineProps<Props>()
</script>

<!-- ❌ 严禁：巨型组件（>300行） -->
<!-- 包含多个业务逻辑的复杂组件 = 必须拆分 -->
```

## 🔒 安全性强制要求

### 输入验证
```typescript
// ✅ 强制使用：严格的输入验证
function createUser(input: CreateUserRequest): Promise<UserInfo> {
  // 验证必填字段
  if (!input.name?.trim()) {
    throw new ValidationError('Name is required')
  }
  
  if (!input.email?.trim()) {
    throw new ValidationError('Email is required')
  }
  
  // 验证格式
  if (!isValidEmail(input.email)) {
    throw new ValidationError('Invalid email format')
  }
  
  return userService.create(input)
}

// ❌ 严禁：直接使用未验证的输入
function createUser(input: any): Promise<any> {  // ❌ 禁止
  return userService.create(input)  // ❌ 未验证的输入
}
```

### 错误处理
```typescript
// ✅ 强制使用：完整的错误处理
async function fetchUserData(userId: string): Promise<UserInfo> {
  try {
    const response = await userApi.getUser(userId)
    
    if (!response.success) {
      throw new ApiError(`Failed to fetch user: ${response.message}`)
    }
    
    if (!isValidUser(response.data)) {
      throw new ValidationError('Invalid user data received')
    }
    
    return response.data
  } catch (error) {
    logger.error('Error fetching user data', { userId, error })
    throw error
  }
}

// ❌ 严禁：忽略错误处理
async function fetchUserData(userId: string): Promise<any> {
  const response = await userApi.getUser(userId)  // ❌ 无错误处理
  return response.data  // ❌ 不检查响应状态
}
```

## 🧪 测试覆盖率要求

### 强制测试覆盖率
```typescript
// ✅ 必须达到的覆盖率指标
// 函数覆盖率: >90%
// 行覆盖率: >85%
// 分支覆盖率: >80%

// ✅ 必须测试的函数类型
// 1. 所有public方法
// 2. 所有业务逻辑函数
// 3. 所有API调用函数
// 4. 所有数据转换函数

describe('UserService', () => {
  it('should create user with valid data', async () => {
    const userData = { name: 'John', email: 'john@test.com' }
    const result = await userService.create(userData)
    expect(result).toBeDefined()
    expect(result.id).toBeTruthy()
  })
  
  it('should throw error for invalid email', async () => {
    const userData = { name: 'John', email: 'invalid-email' }
    await expect(userService.create(userData))
      .rejects.toThrow('Invalid email format')
  })
})
```

## 📊 性能要求

### 强制性能标准
```typescript
// ✅ 必须满足的性能指标
// Vue组件渲染时间: <16ms (60fps)
// API响应时间: <200ms
// 页面加载时间: <2s
// 包大小: <5MB

// ✅ 强制使用：性能优化技术
// 1. Vue组件懒加载
const UserManagement = defineAsyncComponent(
  () => import('@/views/user/UserManagement.vue')
)

// 2. API请求去重
const userCache = new Map<string, Promise<UserInfo>>()
const getUserById = (id: string): Promise<UserInfo> => {
  if (!userCache.has(id)) {
    userCache.set(id, userApi.getUser(id))
  }
  return userCache.get(id)!
}

// 3. 计算属性缓存
const expensiveComputation = computed(() => {
  return heavyCalculation(props.data)  // 自动缓存
})
```

## 🚨 自动质量检查

### 代码提交前强制检查
```bash
# Git pre-commit钩子自动执行
1. TypeScript类型检查 (tsc --noEmit)
2. ESLint规范检查 (eslint --fix)
3. 单元测试执行 (npm test)
4. 构建验证 (npm run build)
5. 性能测试 (npm run perf)
```

### 质量门禁
```typescript
// 质量门禁标准 - 未达标禁止合并
interface QualityGates {
  buildSuccess: true,           // ✅ 构建必须成功
  typeCheckPass: true,          // ✅ 类型检查必须通过
  lintErrors: 0,                // ✅ Lint错误必须为0
  testCoverage: '>85%',         // ✅ 测试覆盖率>85%
  duplicatedCode: '<5%',        // ✅ 重复代码<5%
  complexityScore: '<10',       // ✅ 圈复杂度<10
  performanceScore: '>90'       // ✅ 性能分数>90
}
```

## ⚠️ 质量违规处理

### 自动处理机制
1. **构建失败** → 自动回滚到上一次成功状态
2. **类型错误** → 阻止代码执行，强制修复
3. **Lint错误** → 自动修复，无法修复则阻止提交
4. **测试失败** → 阻止部署，必须修复测试
5. **性能下降** → 发出警报，要求性能优化

---

**🔒 代码质量是项目生命线，质量标准不可妥协！**