# P1 短期改进架构设计（1-2个月）

## 🎯 P1 改进目标
- ✅ 策略模式解耦，插件化架构
- ✅ 实时内存监控和智能管理  
- ✅ 企业级错误处理和审计日志

---

## Step 3: 插件化策略架构重构

### 3.1 代码生成策略接口

```typescript
// tools/generator/strategies/generation-strategy.ts
export interface IGenerationStrategy {
  name: string
  version: string
  supportedFrameworks: string[]
  
  generateRoutes(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]>
  generateStores(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]>
  generateLifecycles(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]>
  generatePolicies(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]>
  
  validate(manifests: EnterpriseManifest[]): Promise<ValidationResult>
  cleanup(): Promise<void>
}

export interface GenerationContext {
  rootDir: string
  outputDir: string
  framework: string
  buildTarget: 'spa' | 'ssr' | 'ssg' | 'micro-frontend'
  environment: 'development' | 'production' | 'test'
  options: Record<string, any>
}

export interface GeneratedFile {
  path: string
  content: string
  checksum: string
  dependencies: string[]
  metadata: Record<string, any>
}

export interface ValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
  suggestions: string[]
}
```

### 3.2 Vue.js 策略实现

```typescript
// tools/generator/strategies/vue-strategy.ts
import { IGenerationStrategy, GenerationContext, GeneratedFile, ValidationResult } from './generation-strategy'
import { EnterpriseManifest } from '../enhanced-schema'
import { createLogger } from '../enterprise-logger'

const logger = createLogger('VueStrategy')

export class VueGenerationStrategy implements IGenerationStrategy {
  name = 'vue'
  version = '3.4.0'
  supportedFrameworks = ['vue']

  async generateRoutes(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('生成 Vue 路由配置')
    
    const imports: string[] = [
      "import type { RouteRecordRaw } from 'vue-router'",
      "import { defineAsyncComponent } from 'vue'"
    ]
    
    const routes: string[] = []
    const routeModuleMap: Record<string, string[]> = {}

    for (const manifest of manifests) {
      routeModuleMap[manifest.name] = []
      
      for (const route of manifest.routes) {
        if (route.framework !== 'vue') continue
        
        routeModuleMap[manifest.name].push(route.name)
        
        const componentImport = route.meta?.lazyLoad 
          ? `defineAsyncComponent(() => import('${route.component}'))`
          : `() => import('${route.component}')`

        routes.push(`  {
    name: '${route.name}',
    path: '${route.path}',
    component: ${componentImport},
    meta: ${JSON.stringify({
      ...route.meta,
      module: manifest.name,
      framework: 'vue'
    }, null, 6).replace(/\n/g, '\n    ')},
    props: true,
    beforeEnter: [
      ${route.meta?.policy ? `checkPolicy('${route.meta.policy}')` : ''},
      ${route.meta?.preload ? 'preloadDependencies' : ''}
    ].filter(Boolean)
  }`)
      }
    }

    const content = `${this.generateFileHeader()}

${imports.join('\n')}

// 权限检查守卫
function checkPolicy(policy: string) {
  return (to: any, from: any, next: any) => {
    // 实现权限检查逻辑
    next()
  }
}

// 依赖预加载
function preloadDependencies(to: any, from: any, next: any) {
  // 实现依赖预加载逻辑
  next()
}

export const vueRoutes: RouteRecordRaw[] = [
${routes.join(',\n')}
]

export const vueRouteModuleMap = ${JSON.stringify(routeModuleMap, null, 2)}

// 路由懒加载优化
export const routeChunks = {
${manifests.map(m => 
  `  '${m.name}': () => import(/* webpackChunkName: "${m.name.toLowerCase()}" */ '@/modules/${m.name}')`
).join(',\n')}
}
`

    return [{
      path: 'src/appshell/router/vue-routes.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        routeCount: routes.length,
        moduleCount: manifests.length
      }
    }]
  }

  async generateStores(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('生成 Vue Store 配置')
    
    const imports: string[] = []
    const storeExports: string[] = []
    const storeModuleMap: Record<string, string[]> = {}

    for (const manifest of manifests) {
      storeModuleMap[manifest.name] = []
      
      for (const store of manifest.stores) {
        if (store.framework !== 'vue') continue
        
        imports.push(`import { ${store.symbol} } from '${store.modulePath}'`)
        storeExports.push(`  ${store.symbol}, // from ${manifest.name}`)
        storeModuleMap[manifest.name].push(store.id)
      }
    }

    const content = `${this.generateFileHeader()}

import { createPinia, type PiniaPluginContext } from 'pinia'

${imports.join('\n')}

// 创建 Pinia 实例
export const pinia = createPinia()

// 添加开发工具支持
if (import.meta.env.DEV) {
  pinia.use(({ store }: PiniaPluginContext) => {
    // 添加调试信息
    store.$subscribe((mutation, state) => {
      console.log(\`[Store] \${mutation.storeId}: \${mutation.type}\`, mutation)
    })
  })
}

// 导出所有 Store
export const vueStores = {
${storeExports.join(',\n')}
}

export const vueStoreModuleMap = ${JSON.stringify(storeModuleMap, null, 2)}

// Store 懒加载
export const storeRegistry = new Map<string, () => Promise<any>>([
${manifests.flatMap(m => 
  m.stores.filter(s => s.framework === 'vue').map(s => 
    `  ['${s.id}', () => import('${s.modulePath}')]`
  )
).join(',\n')}
])

// 动态加载 Store
export async function loadStore(storeId: string) {
  const loader = storeRegistry.get(storeId)
  if (!loader) {
    throw new Error(\`Store '\${storeId}' not found\`)
  }
  
  const storeModule = await loader()
  return storeModule
}
`

    return [{
      path: 'src/appshell/stores/vue-stores.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        storeCount: storeExports.length,
        moduleCount: manifests.length
      }
    }]
  }

  async generateLifecycles(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('生成 Vue 生命周期管理')
    
    const hooks = ['preInit', 'init', 'postInit', 'beforeMount', 'mounted', 'beforeUnmount', 'unmounted']
    const sections: string[] = []

    for (const hook of hooks) {
      const hookImports: string[] = []
      const hookCalls: string[] = []

      manifests.forEach(manifest => {
        const hookPath = manifest.lifecycle[hook as keyof typeof manifest.lifecycle]
        if (hookPath) {
          const importName = `${manifest.name}_${hook}`
          hookImports.push(`import ${importName} from '${hookPath}'`)
          hookCalls.push(`    await executeHookSafely('${manifest.name}', '${hook}', ${importName}, ctx)`)
        }
      })

      if (hookImports.length > 0) {
        sections.push(`// ${hook} hooks
${hookImports.join('\n')}

export async function run${hook.charAt(0).toUpperCase() + hook.slice(1)}(ctx: VueLifecycleContext) {
  const startTime = performance.now()
  logger.info('执行 ${hook} 生命周期钩子')
  
  try {
${hookCalls.join('\n')}
    
    const duration = performance.now() - startTime
    logger.info(\`${hook} 生命周期完成，耗时: \${duration.toFixed(2)}ms\`)
  } catch (error) {
    logger.error('${hook} 生命周期执行失败:', error)
    throw new LifecycleError('${hook}', error)
  }
}`)
      } else {
        sections.push(`export async function run${hook.charAt(0).toUpperCase() + hook.slice(1)}(ctx: VueLifecycleContext) {
  logger.debug('跳过 ${hook} - 未注册钩子')
}`)
      }
    }

    const content = `${this.generateFileHeader()}

import type { App } from 'vue'
import type { Router } from 'vue-router'
import type { Pinia } from 'pinia'
import { createLogger } from '../enterprise-logger'

const logger = createLogger('VueLifecycle')

export interface VueLifecycleContext {
  app: App
  router: Router
  pinia: Pinia
  config: Record<string, any>
}

export class LifecycleError extends Error {
  constructor(public hook: string, public originalError: any) {
    super(\`Lifecycle hook '\${hook}' failed: \${originalError.message}\`)
    this.name = 'LifecycleError'
  }
}

async function executeHookSafely(
  moduleName: string, 
  hookName: string, 
  hookFn: (ctx: VueLifecycleContext) => Promise<void> | void,
  ctx: VueLifecycleContext
) {
  try {
    await hookFn(ctx)
    logger.debug(\`模块 \${moduleName} 的 \${hookName} 钩子执行成功\`)
  } catch (error) {
    logger.error(\`模块 \${moduleName} 的 \${hookName} 钩子执行失败:\`, error)
    throw error
  }
}

${sections.join('\n\n')}

export const vueLifecycleModuleMap = {
${manifests.map(m => {
  const hooks = Object.entries(m.lifecycle)
    .filter(([_, v]) => v)
    .map(([k]) => `'${k}'`)
  return `  '${m.name}': [${hooks.join(', ')}]`
}).join(',\n')}
}

// 生命周期管理器
export class VueLifecycleManager {
  private executed = new Set<string>()
  
  async executeAll(ctx: VueLifecycleContext) {
    const hooks = ['preInit', 'init', 'postInit', 'beforeMount', 'mounted']
    
    for (const hook of hooks) {
      if (!this.executed.has(hook)) {
        await this[\`run\${hook.charAt(0).toUpperCase() + hook.slice(1)}\`](ctx)
        this.executed.add(hook)
      }
    }
  }
  
  async cleanup(ctx: VueLifecycleContext) {
    await this.runBeforeUnmount(ctx)
    await this.runUnmounted(ctx)
  }
}
`

    return [{
      path: 'src/appshell/lifecycle/vue-lifecycle.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        hookCount: sections.length,
        moduleCount: manifests.length
      }
    }]
  }

  async generatePolicies(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('生成 Vue 权限策略')
    
    const allPolicies: Record<string, string> = {}
    const policyModuleMap: Record<string, string[]> = {}
    
    manifests.forEach(manifest => {
      policyModuleMap[manifest.name] = manifest.policies
      manifest.policies.forEach(policy => {
        allPolicies[policy] = manifest.name
      })
    })

    const content = `${this.generateFileHeader()}

import { inject, type InjectionKey } from 'vue'

export interface PolicyService {
  hasPolicy(policy: string): boolean
  hasAnyPolicy(policies: string[]): boolean
  hasAllPolicies(policies: string[]): boolean
  getUserPolicies(): string[]
}

export const POLICY_SERVICE_KEY: InjectionKey<PolicyService> = Symbol('PolicyService')

// 生成的权限策略映射
export const vuePolicies = ${JSON.stringify(allPolicies, null, 2)}

export const vuePolicyModuleMap = ${JSON.stringify(policyModuleMap, null, 2)}

// Vue 权限检查组合函数
export function usePermissions() {
  const policyService = inject(POLICY_SERVICE_KEY)
  
  if (!policyService) {
    throw new Error('PolicyService not provided')
  }
  
  return {
    hasPolicy: (policy: string) => policyService.hasPolicy(policy),
    hasAnyPolicy: (policies: string[]) => policyService.hasAnyPolicy(policies),
    hasAllPolicies: (policies: string[]) => policyService.hasAllPolicies(policies),
    canAccess: (policy?: string) => policy ? policyService.hasPolicy(policy) : true
  }
}

// Vue 权限指令
export const vPermission = {
  mounted(el: HTMLElement, binding: { value: string | string[] }) {
    const policyService = inject(POLICY_SERVICE_KEY)
    if (!policyService) return
    
    const policies = Array.isArray(binding.value) ? binding.value : [binding.value]
    const hasPermission = policyService.hasAnyPolicy(policies)
    
    if (!hasPermission) {
      el.style.display = 'none'
    }
  }
}

// 策略权重计算
export const policyWeights = {
${Object.keys(allPolicies).map(policy => {
  const parts = policy.split('.')
  const weight = parts.length * 10 + (parts[parts.length - 1] === 'Admin' ? 100 : 0)
  return `  '${policy}': ${weight}`
}).join(',\n')}
}
`

    return [{
      path: 'src/appshell/security/vue-policies.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        policyCount: Object.keys(allPolicies).length,
        moduleCount: manifests.length
      }
    }]
  }

  async validate(manifests: EnterpriseManifest[]): Promise<ValidationResult> {
    const errors: string[] = []
    const warnings: string[] = []
    const suggestions: string[] = []

    // 验证 Vue 特定的约束
    for (const manifest of manifests) {
      // 检查组件路径
      for (const route of manifest.routes) {
        if (route.framework === 'vue' && !route.component.endsWith('.vue')) {
          warnings.push(`路由 ${route.name} 的组件路径 ${route.component} 不是 .vue 文件`)
        }
      }

      // 检查 Store 命名约定
      for (const store of manifest.stores) {
        if (store.framework === 'vue') {
          if (!store.symbol.startsWith('use') || !store.symbol.endsWith('Store')) {
            errors.push(`Store ${store.id} 的符号 ${store.symbol} 不符合 Vue Composition API 命名约定`)
          }
        }
      }
    }

    // 性能建议
    const routeCount = manifests.reduce((sum, m) => sum + m.routes.filter(r => r.framework === 'vue').length, 0)
    if (routeCount > 50) {
      suggestions.push('路由数量较多，建议启用路由懒加载和代码分割')
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      suggestions
    }
  }

  async cleanup(): Promise<void> {
    // 清理临时资源
    logger.debug('Vue 策略清理完成')
  }

  private generateFileHeader(): string {
    return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by: ${this.name} strategy v${this.version}
// Generated at: ${new Date().toISOString()}
// Framework: Vue.js ${this.version}`
  }

  private calculateChecksum(content: string): string {
    return require('crypto').createHash('sha256').update(content).digest('hex')
  }
}
```

### 3.3 React 策略实现

```typescript
// tools/generator/strategies/react-strategy.ts
import { IGenerationStrategy, GenerationContext, GeneratedFile, ValidationResult } from './generation-strategy'
import { EnterpriseManifest } from '../enhanced-schema'
import { createLogger } from '../enterprise-logger'

const logger = createLogger('ReactStrategy')

export class ReactGenerationStrategy implements IGenerationStrategy {
  name = 'react'
  version = '18.2.0'
  supportedFrameworks = ['react']

  async generateRoutes(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('生成 React 路由配置')
    
    const imports: string[] = [
      "import React, { lazy, Suspense } from 'react'",
      "import { createBrowserRouter, RouteObject } from 'react-router-dom'"
    ]
    
    const routes: string[] = []
    const routeModuleMap: Record<string, string[]> = {}

    for (const manifest of manifests) {
      routeModuleMap[manifest.name] = []
      
      for (const route of manifest.routes) {
        if (route.framework !== 'react') continue
        
        routeModuleMap[manifest.name].push(route.name)
        
        const componentName = route.name + 'Component'
        const componentImport = route.meta?.lazyLoad 
          ? `const ${componentName} = lazy(() => import('${route.component}'))`
          : `import ${componentName} from '${route.component}'`

        imports.push(componentImport)

        routes.push(`  {
    id: '${route.name}',
    path: '${route.path}',
    element: ${route.meta?.lazyLoad ? 
      `<Suspense fallback={<div>Loading...</div>}><${componentName} /></Suspense>` : 
      `<${componentName} />`
    },
    loader: async ({ params }) => {
      // 权限检查
      ${route.meta?.policy ? `await checkPolicy('${route.meta.policy}')` : ''}
      return { params }
    },
    meta: ${JSON.stringify({
      ...route.meta,
      module: manifest.name,
      framework: 'react'
    }, null, 6).replace(/\n/g, '\n    ')}
  }`)
      }
    }

    const content = `${this.generateFileHeader()}

${imports.join('\n')}

// 权限检查
async function checkPolicy(policy: string) {
  // 实现权限检查逻辑
  return true
}

export const reactRoutes: RouteObject[] = [
${routes.join(',\n')}
]

export const reactRouter = createBrowserRouter(reactRoutes)

export const reactRouteModuleMap = ${JSON.stringify(routeModuleMap, null, 2)}
`

    return [{
      path: 'src/appshell/router/react-routes.generated.tsx',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        routeCount: routes.length,
        moduleCount: manifests.length
      }
    }]
  }

  async generateStores(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('生成 React Store 配置 (Redux Toolkit)')
    
    const imports: string[] = [
      "import { configureStore } from '@reduxjs/toolkit'",
      "import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'"
    ]
    
    const sliceImports: string[] = []
    const reducers: string[] = []
    const storeModuleMap: Record<string, string[]> = {}

    for (const manifest of manifests) {
      storeModuleMap[manifest.name] = []
      
      for (const store of manifest.stores) {
        if (store.framework !== 'react') continue
        
        const sliceName = store.id + 'Slice'
        sliceImports.push(`import { ${sliceName} } from '${store.modulePath}'`)
        reducers.push(`  ${store.id}: ${sliceName}.reducer`)
        storeModuleMap[manifest.name].push(store.id)
      }
    }

    const content = `${this.generateFileHeader()}

${imports.join('\n')}
${sliceImports.join('\n')}

export const reactStore = configureStore({
  reducer: {
${reducers.join(',\n')}
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST']
      }
    }),
  devTools: process.env.NODE_ENV !== 'production'
})

export type RootState = ReturnType<typeof reactStore.getState>
export type AppDispatch = typeof reactStore.dispatch

export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector

export const reactStoreModuleMap = ${JSON.stringify(storeModuleMap, null, 2)}
`

    return [{
      path: 'src/appshell/stores/react-stores.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        storeCount: reducers.length,
        moduleCount: manifests.length
      }
    }]
  }

  // 其他方法实现...
  async generateLifecycles(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    // React 生命周期实现
    return []
  }

  async generatePolicies(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    // React 权限策略实现
    return []
  }

  async validate(manifests: EnterpriseManifest[]): ValidationResult {
    return { isValid: true, errors: [], warnings: [], suggestions: [] }
  }

  async cleanup(): Promise<void> {
    logger.debug('React 策略清理完成')
  }

  private generateFileHeader(): string {
    return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by: ${this.name} strategy v${this.version}
// Generated at: ${new Date().toISOString()}
// Framework: React ${this.version}`
  }

  private calculateChecksum(content: string): string {
    return require('crypto').createHash('sha256').update(content).digest('hex')
  }
}
```

### 3.4 策略管理器

```typescript
// tools/generator/strategy-manager.ts
import { IGenerationStrategy, GenerationContext } from './strategies/generation-strategy'
import { VueGenerationStrategy } from './strategies/vue-strategy'
import { ReactGenerationStrategy } from './strategies/react-strategy'
import { EnterpriseManifest } from './enhanced-schema'
import { createLogger } from './enterprise-logger'

const logger = createLogger('StrategyManager')

export class PluginableStrategyManager {
  private strategies = new Map<string, IGenerationStrategy>()
  private activeStrategies = new Set<string>()

  constructor() {
    // 注册内置策略
    this.registerStrategy(new VueGenerationStrategy())
    this.registerStrategy(new ReactGenerationStrategy())
  }

  registerStrategy(strategy: IGenerationStrategy): void {
    logger.info(`注册策略: ${strategy.name} v${strategy.version}`)
    this.strategies.set(strategy.name, strategy)
  }

  unregisterStrategy(name: string): void {
    const strategy = this.strategies.get(name)
    if (strategy) {
      strategy.cleanup()
      this.strategies.delete(name)
      this.activeStrategies.delete(name)
      logger.info(`注销策略: ${name}`)
    }
  }

  getStrategy(name: string): IGenerationStrategy | undefined {
    return this.strategies.get(name)
  }

  listStrategies(): string[] {
    return Array.from(this.strategies.keys())
  }

  async generateAll(manifests: EnterpriseManifest[], context: GenerationContext): Promise<void> {
    // 确定需要的策略
    const requiredFrameworks = new Set<string>()
    manifests.forEach(manifest => {
      manifest.frameworks.forEach(fw => requiredFrameworks.add(fw))
    })

    logger.info(`需要的框架策略: ${Array.from(requiredFrameworks).join(', ')}`)

    // 并行执行各策略
    const tasks = Array.from(requiredFrameworks).map(async (framework) => {
      const strategy = this.strategies.get(framework)
      if (!strategy) {
        throw new Error(`策略 ${framework} 未注册`)
      }

      const frameworkManifests = manifests.filter(m => 
        m.frameworks.includes(framework as any)
      )

      const frameworkContext = { ...context, framework }

      logger.info(`执行 ${framework} 策略生成`)
      
      // 并行生成各类型文件
      await Promise.all([
        strategy.generateRoutes(frameworkManifests, frameworkContext),
        strategy.generateStores(frameworkManifests, frameworkContext),
        strategy.generateLifecycles(frameworkManifests, frameworkContext),
        strategy.generatePolicies(frameworkManifests, frameworkContext)
      ])

      this.activeStrategies.add(framework)
    })

    await Promise.all(tasks)
    
    logger.info('所有策略生成完成')
  }

  async validateAll(manifests: EnterpriseManifest[]): Promise<boolean> {
    const frameworks = new Set<string>()
    manifests.forEach(m => m.frameworks.forEach(fw => frameworks.add(fw)))

    let allValid = true
    
    for (const framework of frameworks) {
      const strategy = this.strategies.get(framework)
      if (!strategy) {
        logger.error(`策略 ${framework} 未找到`)
        allValid = false
        continue
      }

      const result = await strategy.validate(manifests.filter(m => 
        m.frameworks.includes(framework as any)
      ))

      if (!result.isValid) {
        logger.error(`${framework} 策略验证失败:`, result)
        allValid = false
      }
    }

    return allValid
  }

  async cleanup(): Promise<void> {
    const cleanupTasks = Array.from(this.strategies.values()).map(strategy => 
      strategy.cleanup()
    )
    
    await Promise.all(cleanupTasks)
    this.activeStrategies.clear()
    
    logger.info('策略管理器清理完成')
  }
}
```

---

## Step 4: 企业级内存监控系统

### 4.1 内存监控服务

```typescript
// tools/monitoring/memory-monitor.ts
import { EventEmitter } from 'events'
import { createLogger } from '../generator/enterprise-logger'

const logger = createLogger('MemoryMonitor')

export interface MemoryMetrics {
  heapUsed: number
  heapTotal: number
  external: number
  rss: number
  arrayBuffers: number
  timestamp: Date
  usagePercent: number
}

export interface MemoryAlert {
  level: 'warning' | 'critical' | 'emergency'
  message: string
  metrics: MemoryMetrics
  recommendations: string[]
}

export class EnterpriseMemoryMonitor extends EventEmitter {
  private isMonitoring = false
  private intervalId: NodeJS.Timeout | null = null
  private metricsHistory: MemoryMetrics[] = []
  private maxHistorySize = 1000
  
  // 阈值配置
  private thresholds = {
    warning: 70,    // 70% 内存使用率
    critical: 85,   // 85% 内存使用率
    emergency: 95   // 95% 内存使用率
  }

  private lastAlertLevel: string | null = null
  private alertCooldown = 30000 // 30秒冷却时间
  private lastAlertTime = 0

  constructor(private options: {
    interval?: number
    historySize?: number
    thresholds?: Partial<typeof EnterpriseMemoryMonitor.prototype.thresholds>
  } = {}) {
    super()
    
    if (options.historySize) {
      this.maxHistorySize = options.historySize
    }
    
    if (options.thresholds) {
      this.thresholds = { ...this.thresholds, ...options.thresholds }
    }
  }

  start(): void {
    if (this.isMonitoring) {
      logger.warn('内存监控已在运行')
      return
    }

    logger.info('启动企业级内存监控', {
      interval: this.options.interval || 5000,
      thresholds: this.thresholds
    })

    this.isMonitoring = true
    this.intervalId = setInterval(() => {
      this.collectMetrics()
    }, this.options.interval || 5000)

    // 监听进程退出
    process.on('exit', () => this.stop())
    process.on('SIGINT', () => this.stop())
  }

  stop(): void {
    if (!this.isMonitoring) return

    logger.info('停止内存监控')
    
    this.isMonitoring = false
    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = null
    }
  }

  private collectMetrics(): void {
    const memUsage = process.memoryUsage()
    
    const metrics: MemoryMetrics = {
      heapUsed: memUsage.heapUsed,
      heapTotal: memUsage.heapTotal,
      external: memUsage.external,
      rss: memUsage.rss,
      arrayBuffers: memUsage.arrayBuffers,
      timestamp: new Date(),
      usagePercent: (memUsage.heapUsed / memUsage.heapTotal) * 100
    }

    // 添加到历史记录
    this.metricsHistory.push(metrics)
    if (this.metricsHistory.length > this.maxHistorySize) {
      this.metricsHistory.shift()
    }

    // 检查内存使用率
    this.checkThresholds(metrics)
    
    // 发出指标事件
    this.emit('metrics', metrics)
  }

  private checkThresholds(metrics: MemoryMetrics): void {
    const now = Date.now()
    const { usagePercent } = metrics
    
    // 冷却时间检查
    if (now - this.lastAlertTime < this.alertCooldown) {
      return
    }

    let alertLevel: string | null = null
    let recommendations: string[] = []

    if (usagePercent >= this.thresholds.emergency) {
      alertLevel = 'emergency'
      recommendations = [
        '立即释放不必要的对象引用',
        '强制执行垃圾回收 global.gc()',
        '考虑重启应用程序',
        '检查是否存在内存泄漏'
      ]
    } else if (usagePercent >= this.thresholds.critical) {
      alertLevel = 'critical'
      recommendations = [
        '清理临时缓存',
        '释放大型对象',
        '检查循环引用',
        '考虑增加堆内存限制'
      ]
    } else if (usagePercent >= this.thresholds.warning) {
      alertLevel = 'warning'
      recommendations = [
        '监控内存增长趋势',
        '优化数据结构',
        '检查是否有内存密集操作',
        '考虑实现分页或懒加载'
      ]
    }

    // 只在警告级别升级时发送警报
    if (alertLevel && (
      !this.lastAlertLevel || 
      this.getAlertPriority(alertLevel) > this.getAlertPriority(this.lastAlertLevel)
    )) {
      const alert: MemoryAlert = {
        level: alertLevel as 'warning' | 'critical' | 'emergency',
        message: `内存使用率达到 ${usagePercent.toFixed(2)}%`,
        metrics,
        recommendations
      }

      this.emit('alert', alert)
      logger.warn('内存警报', alert)
      
      this.lastAlertLevel = alertLevel
      this.lastAlertTime = now
    }

    // 重置警报级别（如果使用率下降）
    if (!alertLevel && this.lastAlertLevel) {
      this.lastAlertLevel = null
      logger.info('内存使用率已恢复正常')
    }
  }

  private getAlertPriority(level: string): number {
    switch (level) {
      case 'warning': return 1
      case 'critical': return 2
      case 'emergency': return 3
      default: return 0
    }
  }

  // 获取当前指标
  getCurrentMetrics(): MemoryMetrics | null {
    return this.metricsHistory[this.metricsHistory.length - 1] || null
  }

  // 获取历史指标
  getHistoricalMetrics(minutes: number = 10): MemoryMetrics[] {
    const cutoff = new Date(Date.now() - minutes * 60 * 1000)
    return this.metricsHistory.filter(m => m.timestamp >= cutoff)
  }

  // 获取内存统计
  getMemoryStats() {
    if (this.metricsHistory.length === 0) return null

    const recent = this.getHistoricalMetrics(5) // 最近5分钟
    const usageValues = recent.map(m => m.usagePercent)
    
    return {
      current: this.getCurrentMetrics(),
      avg: usageValues.reduce((a, b) => a + b, 0) / usageValues.length,
      min: Math.min(...usageValues),
      max: Math.max(...usageValues),
      trend: this.calculateTrend(usageValues),
      historySize: this.metricsHistory.length
    }
  }

  private calculateTrend(values: number[]): 'rising' | 'stable' | 'falling' {
    if (values.length < 2) return 'stable'
    
    const recent = values.slice(-5) // 最近5个值
    const older = values.slice(-10, -5) // 之前5个值
    
    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length
    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length
    
    const diff = recentAvg - olderAvg
    
    if (diff > 2) return 'rising'
    if (diff < -2) return 'falling'
    return 'stable'
  }

  // 强制垃圾回收（仅在有--expose-gc标志时有效）
  forceGC(): boolean {
    if (global.gc) {
      const before = process.memoryUsage()
      global.gc()
      const after = process.memoryUsage()
      
      const freed = before.heapUsed - after.heapUsed
      logger.info(`强制垃圾回收释放了 ${(freed / 1024 / 1024).toFixed(2)} MB`)
      return true
    } else {
      logger.warn('垃圾回收不可用，需要 --expose-gc 标志')
      return false
    }
  }

  // 内存优化建议
  getOptimizationSuggestions(): string[] {
    const stats = this.getMemoryStats()
    if (!stats) return []

    const suggestions: string[] = []
    
    if (stats.current && stats.current.usagePercent > 80) {
      suggestions.push('当前内存使用率过高，考虑优化数据结构')
    }
    
    if (stats.trend === 'rising') {
      suggestions.push('内存使用趋势上升，检查是否存在内存泄漏')
    }
    
    if (stats.max > 90) {
      suggestions.push('内存峰值使用率超过90%，考虑增加堆内存限制')
    }

    if (suggestions.length === 0) {
      suggestions.push('内存使用情况良好，继续保持')
    }

    return suggestions
  }

  // 生成内存报告
  generateReport(): string {
    const stats = this.getMemoryStats()
    if (!stats) return '暂无内存统计数据'

    const current = stats.current!
    
    return `
📊 内存使用报告
================
当前使用率: ${current.usagePercent.toFixed(2)}%
堆内存: ${(current.heapUsed / 1024 / 1024).toFixed(2)} MB / ${(current.heapTotal / 1024 / 1024).toFixed(2)} MB
RSS: ${(current.rss / 1024 / 1024).toFixed(2)} MB
外部内存: ${(current.external / 1024 / 1024).toFixed(2)} MB

📈 统计信息
================
平均使用率: ${stats.avg.toFixed(2)}%
最大使用率: ${stats.max.toFixed(2)}%
最小使用率: ${stats.min.toFixed(2)}%
使用趋势: ${stats.trend}

💡 优化建议
================
${this.getOptimizationSuggestions().map(s => `• ${s}`).join('\n')}
`
  }
}
```

### 4.2 内存优化管理器

```typescript
// tools/monitoring/memory-optimizer.ts
import { EnterpriseMemoryMonitor, MemoryAlert, MemoryMetrics } from './memory-monitor'
import { createLogger } from '../generator/enterprise-logger'

const logger = createLogger('MemoryOptimizer')

export interface OptimizationAction {
  name: string
  description: string
  impact: 'low' | 'medium' | 'high'
  execute: () => Promise<boolean>
}

export class MemoryOptimizer {
  private monitor: EnterpriseMemoryMonitor
  private optimizationActions: OptimizationAction[] = []
  private autoOptimizationEnabled = false
  private isOptimizing = false

  constructor(monitor: EnterpriseMemoryMonitor) {
    this.monitor = monitor
    this.setupOptimizationActions()
    this.setupEventListeners()
  }

  private setupOptimizationActions(): void {
    this.optimizationActions = [
      {
        name: 'clearCache',
        description: '清理内存缓存',
        impact: 'medium',
        execute: async () => {
          // 实现缓存清理逻辑
          logger.info('执行缓存清理')
          return true
        }
      },
      {
        name: 'forceGC',
        description: '强制垃圾回收',
        impact: 'high',
        execute: async () => {
          return this.monitor.forceGC()
        }
      },
      {
        name: 'optimizeBuffers',
        description: '优化缓冲区',
        impact: 'medium',
        execute: async () => {
          // 实现缓冲区优化逻辑
          logger.info('优化缓冲区')
          return true
        }
      }
    ]
  }

  private setupEventListeners(): void {
    this.monitor.on('alert', async (alert: MemoryAlert) => {
      if (this.autoOptimizationEnabled && !this.isOptimizing) {
        await this.handleAlert(alert)
      }
    })
  }

  enableAutoOptimization(enabled: boolean = true): void {
    this.autoOptimizationEnabled = enabled
    logger.info(`自动内存优化: ${enabled ? '启用' : '禁用'}`)
  }

  private async handleAlert(alert: MemoryAlert): Promise<void> {
    if (this.isOptimizing) return

    this.isOptimizing = true
    logger.warn(`处理内存警报: ${alert.level}`)

    try {
      switch (alert.level) {
        case 'warning':
          await this.executeOptimization(['clearCache'])
          break
        case 'critical':
          await this.executeOptimization(['clearCache', 'optimizeBuffers'])
          break
        case 'emergency':
          await this.executeOptimization(['clearCache', 'optimizeBuffers', 'forceGC'])
          break
      }
    } finally {
      this.isOptimizing = false
    }
  }

  async executeOptimization(actionNames: string[]): Promise<void> {
    logger.info(`执行内存优化: ${actionNames.join(', ')}`)

    const beforeMetrics = this.monitor.getCurrentMetrics()
    
    for (const actionName of actionNames) {
      const action = this.optimizationActions.find(a => a.name === actionName)
      if (!action) {
        logger.warn(`未找到优化操作: ${actionName}`)
        continue
      }

      try {
        const success = await action.execute()
        if (success) {
          logger.info(`优化操作成功: ${action.description}`)
        } else {
          logger.warn(`优化操作失败: ${action.description}`)
        }
      } catch (error) {
        logger.error(`优化操作异常: ${action.description}`, error)
      }
    }

    // 等待一小段时间让GC完成
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    const afterMetrics = this.monitor.getCurrentMetrics()
    
    if (beforeMetrics && afterMetrics) {
      const memoryFreed = beforeMetrics.heapUsed - afterMetrics.heapUsed
      const usageReduction = beforeMetrics.usagePercent - afterMetrics.usagePercent
      
      logger.info(`内存优化完成`, {
        memoryFreed: `${(memoryFreed / 1024 / 1024).toFixed(2)} MB`,
        usageReduction: `${usageReduction.toFixed(2)}%`,
        currentUsage: `${afterMetrics.usagePercent.toFixed(2)}%`
      })
    }
  }

  // 获取优化建议
  getOptimizationSuggestions(): OptimizationAction[] {
    const currentMetrics = this.monitor.getCurrentMetrics()
    if (!currentMetrics) return []

    const suggestions: OptimizationAction[] = []
    
    if (currentMetrics.usagePercent > 70) {
      suggestions.push(...this.optimizationActions.filter(a => a.impact === 'medium' || a.impact === 'high'))
    } else if (currentMetrics.usagePercent > 50) {
      suggestions.push(...this.optimizationActions.filter(a => a.impact === 'low' || a.impact === 'medium'))
    }

    return suggestions
  }

  // 预测内存使用趋势
  predictMemoryTrend(): 'stable' | 'increasing' | 'critical' {
    const historical = this.monitor.getHistoricalMetrics(10)
    if (historical.length < 5) return 'stable'

    const recent = historical.slice(-3).map(m => m.usagePercent)
    const older = historical.slice(-6, -3).map(m => m.usagePercent)

    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length
    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length

    const trendSlope = recentAvg - olderAvg

    if (trendSlope > 5) return 'critical'
    if (trendSlope > 2) return 'increasing'
    return 'stable'
  }

  // 生成优化报告
  generateOptimizationReport(): string {
    const suggestions = this.getOptimizationSuggestions()
    const trend = this.predictMemoryTrend()
    const stats = this.monitor.getMemoryStats()

    return `
🔧 内存优化报告
================
预测趋势: ${trend}
自动优化: ${this.autoOptimizationEnabled ? '启用' : '禁用'}
正在优化: ${this.isOptimizing ? '是' : '否'}

💡 建议操作 (${suggestions.length}个)
================
${suggestions.map(s => `• ${s.description} [影响: ${s.impact}]`).join('\n')}

📊 当前状态
================
${stats ? `使用率: ${stats.current?.usagePercent.toFixed(2)}%` : '无数据'}
${stats ? `趋势: ${stats.trend}` : ''}
`
  }
}
```

---

继续阅读P2阶段的完整实现...
