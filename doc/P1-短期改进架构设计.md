# P1 çŸ­æœŸæ”¹è¿›æ¶æ„è®¾è®¡ï¼ˆ1-2ä¸ªæœˆï¼‰

## ğŸ¯ P1 æ”¹è¿›ç›®æ ‡
- âœ… ç­–ç•¥æ¨¡å¼è§£è€¦ï¼Œæ’ä»¶åŒ–æ¶æ„
- âœ… å®æ—¶å†…å­˜ç›‘æ§å’Œæ™ºèƒ½ç®¡ç†  
- âœ… ä¼ä¸šçº§é”™è¯¯å¤„ç†å’Œå®¡è®¡æ—¥å¿—

---

## Step 3: æ’ä»¶åŒ–ç­–ç•¥æ¶æ„é‡æ„

### 3.1 ä»£ç ç”Ÿæˆç­–ç•¥æ¥å£

```typescript
// tools/generator/strategies/generation-strategy.ts
export interface IGenerationStrategy {
  name: string
  version: string
  supportedFrameworks: string[]
  
  generateRoutes(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]>
  generateStores(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]>
  generateLifecycles(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]>
  generatePolicies(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]>
  
  validate(manifests: EnterpriseManifest[]): Promise<ValidationResult>
  cleanup(): Promise<void>
}

export interface GenerationContext {
  rootDir: string
  outputDir: string
  framework: string
  buildTarget: 'spa' | 'ssr' | 'ssg' | 'micro-frontend'
  environment: 'development' | 'production' | 'test'
  options: Record<string, any>
}

export interface GeneratedFile {
  path: string
  content: string
  checksum: string
  dependencies: string[]
  metadata: Record<string, any>
}

export interface ValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
  suggestions: string[]
}
```

### 3.2 Vue.js ç­–ç•¥å®ç°

```typescript
// tools/generator/strategies/vue-strategy.ts
import { IGenerationStrategy, GenerationContext, GeneratedFile, ValidationResult } from './generation-strategy'
import { EnterpriseManifest } from '../enhanced-schema'
import { createLogger } from '../enterprise-logger'

const logger = createLogger('VueStrategy')

export class VueGenerationStrategy implements IGenerationStrategy {
  name = 'vue'
  version = '3.4.0'
  supportedFrameworks = ['vue']

  async generateRoutes(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('ç”Ÿæˆ Vue è·¯ç”±é…ç½®')
    
    const imports: string[] = [
      "import type { RouteRecordRaw } from 'vue-router'",
      "import { defineAsyncComponent } from 'vue'"
    ]
    
    const routes: string[] = []
    const routeModuleMap: Record<string, string[]> = {}

    for (const manifest of manifests) {
      routeModuleMap[manifest.name] = []
      
      for (const route of manifest.routes) {
        if (route.framework !== 'vue') continue
        
        routeModuleMap[manifest.name].push(route.name)
        
        const componentImport = route.meta?.lazyLoad 
          ? `defineAsyncComponent(() => import('${route.component}'))`
          : `() => import('${route.component}')`

        routes.push(`  {
    name: '${route.name}',
    path: '${route.path}',
    component: ${componentImport},
    meta: ${JSON.stringify({
      ...route.meta,
      module: manifest.name,
      framework: 'vue'
    }, null, 6).replace(/\n/g, '\n    ')},
    props: true,
    beforeEnter: [
      ${route.meta?.policy ? `checkPolicy('${route.meta.policy}')` : ''},
      ${route.meta?.preload ? 'preloadDependencies' : ''}
    ].filter(Boolean)
  }`)
      }
    }

    const content = `${this.generateFileHeader()}

${imports.join('\n')}

// æƒé™æ£€æŸ¥å®ˆå«
function checkPolicy(policy: string) {
  return (to: any, from: any, next: any) => {
    // å®ç°æƒé™æ£€æŸ¥é€»è¾‘
    next()
  }
}

// ä¾èµ–é¢„åŠ è½½
function preloadDependencies(to: any, from: any, next: any) {
  // å®ç°ä¾èµ–é¢„åŠ è½½é€»è¾‘
  next()
}

export const vueRoutes: RouteRecordRaw[] = [
${routes.join(',\n')}
]

export const vueRouteModuleMap = ${JSON.stringify(routeModuleMap, null, 2)}

// è·¯ç”±æ‡’åŠ è½½ä¼˜åŒ–
export const routeChunks = {
${manifests.map(m => 
  `  '${m.name}': () => import(/* webpackChunkName: "${m.name.toLowerCase()}" */ '@/modules/${m.name}')`
).join(',\n')}
}
`

    return [{
      path: 'src/appshell/router/vue-routes.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        routeCount: routes.length,
        moduleCount: manifests.length
      }
    }]
  }

  async generateStores(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('ç”Ÿæˆ Vue Store é…ç½®')
    
    const imports: string[] = []
    const storeExports: string[] = []
    const storeModuleMap: Record<string, string[]> = {}

    for (const manifest of manifests) {
      storeModuleMap[manifest.name] = []
      
      for (const store of manifest.stores) {
        if (store.framework !== 'vue') continue
        
        imports.push(`import { ${store.symbol} } from '${store.modulePath}'`)
        storeExports.push(`  ${store.symbol}, // from ${manifest.name}`)
        storeModuleMap[manifest.name].push(store.id)
      }
    }

    const content = `${this.generateFileHeader()}

import { createPinia, type PiniaPluginContext } from 'pinia'

${imports.join('\n')}

// åˆ›å»º Pinia å®ä¾‹
export const pinia = createPinia()

// æ·»åŠ å¼€å‘å·¥å…·æ”¯æŒ
if (import.meta.env.DEV) {
  pinia.use(({ store }: PiniaPluginContext) => {
    // æ·»åŠ è°ƒè¯•ä¿¡æ¯
    store.$subscribe((mutation, state) => {
      console.log(\`[Store] \${mutation.storeId}: \${mutation.type}\`, mutation)
    })
  })
}

// å¯¼å‡ºæ‰€æœ‰ Store
export const vueStores = {
${storeExports.join(',\n')}
}

export const vueStoreModuleMap = ${JSON.stringify(storeModuleMap, null, 2)}

// Store æ‡’åŠ è½½
export const storeRegistry = new Map<string, () => Promise<any>>([
${manifests.flatMap(m => 
  m.stores.filter(s => s.framework === 'vue').map(s => 
    `  ['${s.id}', () => import('${s.modulePath}')]`
  )
).join(',\n')}
])

// åŠ¨æ€åŠ è½½ Store
export async function loadStore(storeId: string) {
  const loader = storeRegistry.get(storeId)
  if (!loader) {
    throw new Error(\`Store '\${storeId}' not found\`)
  }
  
  const storeModule = await loader()
  return storeModule
}
`

    return [{
      path: 'src/appshell/stores/vue-stores.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        storeCount: storeExports.length,
        moduleCount: manifests.length
      }
    }]
  }

  async generateLifecycles(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('ç”Ÿæˆ Vue ç”Ÿå‘½å‘¨æœŸç®¡ç†')
    
    const hooks = ['preInit', 'init', 'postInit', 'beforeMount', 'mounted', 'beforeUnmount', 'unmounted']
    const sections: string[] = []

    for (const hook of hooks) {
      const hookImports: string[] = []
      const hookCalls: string[] = []

      manifests.forEach(manifest => {
        const hookPath = manifest.lifecycle[hook as keyof typeof manifest.lifecycle]
        if (hookPath) {
          const importName = `${manifest.name}_${hook}`
          hookImports.push(`import ${importName} from '${hookPath}'`)
          hookCalls.push(`    await executeHookSafely('${manifest.name}', '${hook}', ${importName}, ctx)`)
        }
      })

      if (hookImports.length > 0) {
        sections.push(`// ${hook} hooks
${hookImports.join('\n')}

export async function run${hook.charAt(0).toUpperCase() + hook.slice(1)}(ctx: VueLifecycleContext) {
  const startTime = performance.now()
  logger.info('æ‰§è¡Œ ${hook} ç”Ÿå‘½å‘¨æœŸé’©å­')
  
  try {
${hookCalls.join('\n')}
    
    const duration = performance.now() - startTime
    logger.info(\`${hook} ç”Ÿå‘½å‘¨æœŸå®Œæˆï¼Œè€—æ—¶: \${duration.toFixed(2)}ms\`)
  } catch (error) {
    logger.error('${hook} ç”Ÿå‘½å‘¨æœŸæ‰§è¡Œå¤±è´¥:', error)
    throw new LifecycleError('${hook}', error)
  }
}`)
      } else {
        sections.push(`export async function run${hook.charAt(0).toUpperCase() + hook.slice(1)}(ctx: VueLifecycleContext) {
  logger.debug('è·³è¿‡ ${hook} - æœªæ³¨å†Œé’©å­')
}`)
      }
    }

    const content = `${this.generateFileHeader()}

import type { App } from 'vue'
import type { Router } from 'vue-router'
import type { Pinia } from 'pinia'
import { createLogger } from '../enterprise-logger'

const logger = createLogger('VueLifecycle')

export interface VueLifecycleContext {
  app: App
  router: Router
  pinia: Pinia
  config: Record<string, any>
}

export class LifecycleError extends Error {
  constructor(public hook: string, public originalError: any) {
    super(\`Lifecycle hook '\${hook}' failed: \${originalError.message}\`)
    this.name = 'LifecycleError'
  }
}

async function executeHookSafely(
  moduleName: string, 
  hookName: string, 
  hookFn: (ctx: VueLifecycleContext) => Promise<void> | void,
  ctx: VueLifecycleContext
) {
  try {
    await hookFn(ctx)
    logger.debug(\`æ¨¡å— \${moduleName} çš„ \${hookName} é’©å­æ‰§è¡ŒæˆåŠŸ\`)
  } catch (error) {
    logger.error(\`æ¨¡å— \${moduleName} çš„ \${hookName} é’©å­æ‰§è¡Œå¤±è´¥:\`, error)
    throw error
  }
}

${sections.join('\n\n')}

export const vueLifecycleModuleMap = {
${manifests.map(m => {
  const hooks = Object.entries(m.lifecycle)
    .filter(([_, v]) => v)
    .map(([k]) => `'${k}'`)
  return `  '${m.name}': [${hooks.join(', ')}]`
}).join(',\n')}
}

// ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
export class VueLifecycleManager {
  private executed = new Set<string>()
  
  async executeAll(ctx: VueLifecycleContext) {
    const hooks = ['preInit', 'init', 'postInit', 'beforeMount', 'mounted']
    
    for (const hook of hooks) {
      if (!this.executed.has(hook)) {
        await this[\`run\${hook.charAt(0).toUpperCase() + hook.slice(1)}\`](ctx)
        this.executed.add(hook)
      }
    }
  }
  
  async cleanup(ctx: VueLifecycleContext) {
    await this.runBeforeUnmount(ctx)
    await this.runUnmounted(ctx)
  }
}
`

    return [{
      path: 'src/appshell/lifecycle/vue-lifecycle.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        hookCount: sections.length,
        moduleCount: manifests.length
      }
    }]
  }

  async generatePolicies(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('ç”Ÿæˆ Vue æƒé™ç­–ç•¥')
    
    const allPolicies: Record<string, string> = {}
    const policyModuleMap: Record<string, string[]> = {}
    
    manifests.forEach(manifest => {
      policyModuleMap[manifest.name] = manifest.policies
      manifest.policies.forEach(policy => {
        allPolicies[policy] = manifest.name
      })
    })

    const content = `${this.generateFileHeader()}

import { inject, type InjectionKey } from 'vue'

export interface PolicyService {
  hasPolicy(policy: string): boolean
  hasAnyPolicy(policies: string[]): boolean
  hasAllPolicies(policies: string[]): boolean
  getUserPolicies(): string[]
}

export const POLICY_SERVICE_KEY: InjectionKey<PolicyService> = Symbol('PolicyService')

// ç”Ÿæˆçš„æƒé™ç­–ç•¥æ˜ å°„
export const vuePolicies = ${JSON.stringify(allPolicies, null, 2)}

export const vuePolicyModuleMap = ${JSON.stringify(policyModuleMap, null, 2)}

// Vue æƒé™æ£€æŸ¥ç»„åˆå‡½æ•°
export function usePermissions() {
  const policyService = inject(POLICY_SERVICE_KEY)
  
  if (!policyService) {
    throw new Error('PolicyService not provided')
  }
  
  return {
    hasPolicy: (policy: string) => policyService.hasPolicy(policy),
    hasAnyPolicy: (policies: string[]) => policyService.hasAnyPolicy(policies),
    hasAllPolicies: (policies: string[]) => policyService.hasAllPolicies(policies),
    canAccess: (policy?: string) => policy ? policyService.hasPolicy(policy) : true
  }
}

// Vue æƒé™æŒ‡ä»¤
export const vPermission = {
  mounted(el: HTMLElement, binding: { value: string | string[] }) {
    const policyService = inject(POLICY_SERVICE_KEY)
    if (!policyService) return
    
    const policies = Array.isArray(binding.value) ? binding.value : [binding.value]
    const hasPermission = policyService.hasAnyPolicy(policies)
    
    if (!hasPermission) {
      el.style.display = 'none'
    }
  }
}

// ç­–ç•¥æƒé‡è®¡ç®—
export const policyWeights = {
${Object.keys(allPolicies).map(policy => {
  const parts = policy.split('.')
  const weight = parts.length * 10 + (parts[parts.length - 1] === 'Admin' ? 100 : 0)
  return `  '${policy}': ${weight}`
}).join(',\n')}
}
`

    return [{
      path: 'src/appshell/security/vue-policies.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        policyCount: Object.keys(allPolicies).length,
        moduleCount: manifests.length
      }
    }]
  }

  async validate(manifests: EnterpriseManifest[]): Promise<ValidationResult> {
    const errors: string[] = []
    const warnings: string[] = []
    const suggestions: string[] = []

    // éªŒè¯ Vue ç‰¹å®šçš„çº¦æŸ
    for (const manifest of manifests) {
      // æ£€æŸ¥ç»„ä»¶è·¯å¾„
      for (const route of manifest.routes) {
        if (route.framework === 'vue' && !route.component.endsWith('.vue')) {
          warnings.push(`è·¯ç”± ${route.name} çš„ç»„ä»¶è·¯å¾„ ${route.component} ä¸æ˜¯ .vue æ–‡ä»¶`)
        }
      }

      // æ£€æŸ¥ Store å‘½åçº¦å®š
      for (const store of manifest.stores) {
        if (store.framework === 'vue') {
          if (!store.symbol.startsWith('use') || !store.symbol.endsWith('Store')) {
            errors.push(`Store ${store.id} çš„ç¬¦å· ${store.symbol} ä¸ç¬¦åˆ Vue Composition API å‘½åçº¦å®š`)
          }
        }
      }
    }

    // æ€§èƒ½å»ºè®®
    const routeCount = manifests.reduce((sum, m) => sum + m.routes.filter(r => r.framework === 'vue').length, 0)
    if (routeCount > 50) {
      suggestions.push('è·¯ç”±æ•°é‡è¾ƒå¤šï¼Œå»ºè®®å¯ç”¨è·¯ç”±æ‡’åŠ è½½å’Œä»£ç åˆ†å‰²')
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      suggestions
    }
  }

  async cleanup(): Promise<void> {
    // æ¸…ç†ä¸´æ—¶èµ„æº
    logger.debug('Vue ç­–ç•¥æ¸…ç†å®Œæˆ')
  }

  private generateFileHeader(): string {
    return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by: ${this.name} strategy v${this.version}
// Generated at: ${new Date().toISOString()}
// Framework: Vue.js ${this.version}`
  }

  private calculateChecksum(content: string): string {
    return require('crypto').createHash('sha256').update(content).digest('hex')
  }
}
```

### 3.3 React ç­–ç•¥å®ç°

```typescript
// tools/generator/strategies/react-strategy.ts
import { IGenerationStrategy, GenerationContext, GeneratedFile, ValidationResult } from './generation-strategy'
import { EnterpriseManifest } from '../enhanced-schema'
import { createLogger } from '../enterprise-logger'

const logger = createLogger('ReactStrategy')

export class ReactGenerationStrategy implements IGenerationStrategy {
  name = 'react'
  version = '18.2.0'
  supportedFrameworks = ['react']

  async generateRoutes(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('ç”Ÿæˆ React è·¯ç”±é…ç½®')
    
    const imports: string[] = [
      "import React, { lazy, Suspense } from 'react'",
      "import { createBrowserRouter, RouteObject } from 'react-router-dom'"
    ]
    
    const routes: string[] = []
    const routeModuleMap: Record<string, string[]> = {}

    for (const manifest of manifests) {
      routeModuleMap[manifest.name] = []
      
      for (const route of manifest.routes) {
        if (route.framework !== 'react') continue
        
        routeModuleMap[manifest.name].push(route.name)
        
        const componentName = route.name + 'Component'
        const componentImport = route.meta?.lazyLoad 
          ? `const ${componentName} = lazy(() => import('${route.component}'))`
          : `import ${componentName} from '${route.component}'`

        imports.push(componentImport)

        routes.push(`  {
    id: '${route.name}',
    path: '${route.path}',
    element: ${route.meta?.lazyLoad ? 
      `<Suspense fallback={<div>Loading...</div>}><${componentName} /></Suspense>` : 
      `<${componentName} />`
    },
    loader: async ({ params }) => {
      // æƒé™æ£€æŸ¥
      ${route.meta?.policy ? `await checkPolicy('${route.meta.policy}')` : ''}
      return { params }
    },
    meta: ${JSON.stringify({
      ...route.meta,
      module: manifest.name,
      framework: 'react'
    }, null, 6).replace(/\n/g, '\n    ')}
  }`)
      }
    }

    const content = `${this.generateFileHeader()}

${imports.join('\n')}

// æƒé™æ£€æŸ¥
async function checkPolicy(policy: string) {
  // å®ç°æƒé™æ£€æŸ¥é€»è¾‘
  return true
}

export const reactRoutes: RouteObject[] = [
${routes.join(',\n')}
]

export const reactRouter = createBrowserRouter(reactRoutes)

export const reactRouteModuleMap = ${JSON.stringify(routeModuleMap, null, 2)}
`

    return [{
      path: 'src/appshell/router/react-routes.generated.tsx',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        routeCount: routes.length,
        moduleCount: manifests.length
      }
    }]
  }

  async generateStores(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    logger.info('ç”Ÿæˆ React Store é…ç½® (Redux Toolkit)')
    
    const imports: string[] = [
      "import { configureStore } from '@reduxjs/toolkit'",
      "import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'"
    ]
    
    const sliceImports: string[] = []
    const reducers: string[] = []
    const storeModuleMap: Record<string, string[]> = {}

    for (const manifest of manifests) {
      storeModuleMap[manifest.name] = []
      
      for (const store of manifest.stores) {
        if (store.framework !== 'react') continue
        
        const sliceName = store.id + 'Slice'
        sliceImports.push(`import { ${sliceName} } from '${store.modulePath}'`)
        reducers.push(`  ${store.id}: ${sliceName}.reducer`)
        storeModuleMap[manifest.name].push(store.id)
      }
    }

    const content = `${this.generateFileHeader()}

${imports.join('\n')}
${sliceImports.join('\n')}

export const reactStore = configureStore({
  reducer: {
${reducers.join(',\n')}
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST']
      }
    }),
  devTools: process.env.NODE_ENV !== 'production'
})

export type RootState = ReturnType<typeof reactStore.getState>
export type AppDispatch = typeof reactStore.dispatch

export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector

export const reactStoreModuleMap = ${JSON.stringify(storeModuleMap, null, 2)}
`

    return [{
      path: 'src/appshell/stores/react-stores.generated.ts',
      content,
      checksum: this.calculateChecksum(content),
      dependencies: manifests.map(m => m.name),
      metadata: {
        strategy: this.name,
        storeCount: reducers.length,
        moduleCount: manifests.length
      }
    }]
  }

  // å…¶ä»–æ–¹æ³•å®ç°...
  async generateLifecycles(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    // React ç”Ÿå‘½å‘¨æœŸå®ç°
    return []
  }

  async generatePolicies(manifests: EnterpriseManifest[], context: GenerationContext): Promise<GeneratedFile[]> {
    // React æƒé™ç­–ç•¥å®ç°
    return []
  }

  async validate(manifests: EnterpriseManifest[]): ValidationResult {
    return { isValid: true, errors: [], warnings: [], suggestions: [] }
  }

  async cleanup(): Promise<void> {
    logger.debug('React ç­–ç•¥æ¸…ç†å®Œæˆ')
  }

  private generateFileHeader(): string {
    return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by: ${this.name} strategy v${this.version}
// Generated at: ${new Date().toISOString()}
// Framework: React ${this.version}`
  }

  private calculateChecksum(content: string): string {
    return require('crypto').createHash('sha256').update(content).digest('hex')
  }
}
```

### 3.4 ç­–ç•¥ç®¡ç†å™¨

```typescript
// tools/generator/strategy-manager.ts
import { IGenerationStrategy, GenerationContext } from './strategies/generation-strategy'
import { VueGenerationStrategy } from './strategies/vue-strategy'
import { ReactGenerationStrategy } from './strategies/react-strategy'
import { EnterpriseManifest } from './enhanced-schema'
import { createLogger } from './enterprise-logger'

const logger = createLogger('StrategyManager')

export class PluginableStrategyManager {
  private strategies = new Map<string, IGenerationStrategy>()
  private activeStrategies = new Set<string>()

  constructor() {
    // æ³¨å†Œå†…ç½®ç­–ç•¥
    this.registerStrategy(new VueGenerationStrategy())
    this.registerStrategy(new ReactGenerationStrategy())
  }

  registerStrategy(strategy: IGenerationStrategy): void {
    logger.info(`æ³¨å†Œç­–ç•¥: ${strategy.name} v${strategy.version}`)
    this.strategies.set(strategy.name, strategy)
  }

  unregisterStrategy(name: string): void {
    const strategy = this.strategies.get(name)
    if (strategy) {
      strategy.cleanup()
      this.strategies.delete(name)
      this.activeStrategies.delete(name)
      logger.info(`æ³¨é”€ç­–ç•¥: ${name}`)
    }
  }

  getStrategy(name: string): IGenerationStrategy | undefined {
    return this.strategies.get(name)
  }

  listStrategies(): string[] {
    return Array.from(this.strategies.keys())
  }

  async generateAll(manifests: EnterpriseManifest[], context: GenerationContext): Promise<void> {
    // ç¡®å®šéœ€è¦çš„ç­–ç•¥
    const requiredFrameworks = new Set<string>()
    manifests.forEach(manifest => {
      manifest.frameworks.forEach(fw => requiredFrameworks.add(fw))
    })

    logger.info(`éœ€è¦çš„æ¡†æ¶ç­–ç•¥: ${Array.from(requiredFrameworks).join(', ')}`)

    // å¹¶è¡Œæ‰§è¡Œå„ç­–ç•¥
    const tasks = Array.from(requiredFrameworks).map(async (framework) => {
      const strategy = this.strategies.get(framework)
      if (!strategy) {
        throw new Error(`ç­–ç•¥ ${framework} æœªæ³¨å†Œ`)
      }

      const frameworkManifests = manifests.filter(m => 
        m.frameworks.includes(framework as any)
      )

      const frameworkContext = { ...context, framework }

      logger.info(`æ‰§è¡Œ ${framework} ç­–ç•¥ç”Ÿæˆ`)
      
      // å¹¶è¡Œç”Ÿæˆå„ç±»å‹æ–‡ä»¶
      await Promise.all([
        strategy.generateRoutes(frameworkManifests, frameworkContext),
        strategy.generateStores(frameworkManifests, frameworkContext),
        strategy.generateLifecycles(frameworkManifests, frameworkContext),
        strategy.generatePolicies(frameworkManifests, frameworkContext)
      ])

      this.activeStrategies.add(framework)
    })

    await Promise.all(tasks)
    
    logger.info('æ‰€æœ‰ç­–ç•¥ç”Ÿæˆå®Œæˆ')
  }

  async validateAll(manifests: EnterpriseManifest[]): Promise<boolean> {
    const frameworks = new Set<string>()
    manifests.forEach(m => m.frameworks.forEach(fw => frameworks.add(fw)))

    let allValid = true
    
    for (const framework of frameworks) {
      const strategy = this.strategies.get(framework)
      if (!strategy) {
        logger.error(`ç­–ç•¥ ${framework} æœªæ‰¾åˆ°`)
        allValid = false
        continue
      }

      const result = await strategy.validate(manifests.filter(m => 
        m.frameworks.includes(framework as any)
      ))

      if (!result.isValid) {
        logger.error(`${framework} ç­–ç•¥éªŒè¯å¤±è´¥:`, result)
        allValid = false
      }
    }

    return allValid
  }

  async cleanup(): Promise<void> {
    const cleanupTasks = Array.from(this.strategies.values()).map(strategy => 
      strategy.cleanup()
    )
    
    await Promise.all(cleanupTasks)
    this.activeStrategies.clear()
    
    logger.info('ç­–ç•¥ç®¡ç†å™¨æ¸…ç†å®Œæˆ')
  }
}
```

---

## Step 4: ä¼ä¸šçº§å†…å­˜ç›‘æ§ç³»ç»Ÿ

### 4.1 å†…å­˜ç›‘æ§æœåŠ¡

```typescript
// tools/monitoring/memory-monitor.ts
import { EventEmitter } from 'events'
import { createLogger } from '../generator/enterprise-logger'

const logger = createLogger('MemoryMonitor')

export interface MemoryMetrics {
  heapUsed: number
  heapTotal: number
  external: number
  rss: number
  arrayBuffers: number
  timestamp: Date
  usagePercent: number
}

export interface MemoryAlert {
  level: 'warning' | 'critical' | 'emergency'
  message: string
  metrics: MemoryMetrics
  recommendations: string[]
}

export class EnterpriseMemoryMonitor extends EventEmitter {
  private isMonitoring = false
  private intervalId: NodeJS.Timeout | null = null
  private metricsHistory: MemoryMetrics[] = []
  private maxHistorySize = 1000
  
  // é˜ˆå€¼é…ç½®
  private thresholds = {
    warning: 70,    // 70% å†…å­˜ä½¿ç”¨ç‡
    critical: 85,   // 85% å†…å­˜ä½¿ç”¨ç‡
    emergency: 95   // 95% å†…å­˜ä½¿ç”¨ç‡
  }

  private lastAlertLevel: string | null = null
  private alertCooldown = 30000 // 30ç§’å†·å´æ—¶é—´
  private lastAlertTime = 0

  constructor(private options: {
    interval?: number
    historySize?: number
    thresholds?: Partial<typeof EnterpriseMemoryMonitor.prototype.thresholds>
  } = {}) {
    super()
    
    if (options.historySize) {
      this.maxHistorySize = options.historySize
    }
    
    if (options.thresholds) {
      this.thresholds = { ...this.thresholds, ...options.thresholds }
    }
  }

  start(): void {
    if (this.isMonitoring) {
      logger.warn('å†…å­˜ç›‘æ§å·²åœ¨è¿è¡Œ')
      return
    }

    logger.info('å¯åŠ¨ä¼ä¸šçº§å†…å­˜ç›‘æ§', {
      interval: this.options.interval || 5000,
      thresholds: this.thresholds
    })

    this.isMonitoring = true
    this.intervalId = setInterval(() => {
      this.collectMetrics()
    }, this.options.interval || 5000)

    // ç›‘å¬è¿›ç¨‹é€€å‡º
    process.on('exit', () => this.stop())
    process.on('SIGINT', () => this.stop())
  }

  stop(): void {
    if (!this.isMonitoring) return

    logger.info('åœæ­¢å†…å­˜ç›‘æ§')
    
    this.isMonitoring = false
    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = null
    }
  }

  private collectMetrics(): void {
    const memUsage = process.memoryUsage()
    
    const metrics: MemoryMetrics = {
      heapUsed: memUsage.heapUsed,
      heapTotal: memUsage.heapTotal,
      external: memUsage.external,
      rss: memUsage.rss,
      arrayBuffers: memUsage.arrayBuffers,
      timestamp: new Date(),
      usagePercent: (memUsage.heapUsed / memUsage.heapTotal) * 100
    }

    // æ·»åŠ åˆ°å†å²è®°å½•
    this.metricsHistory.push(metrics)
    if (this.metricsHistory.length > this.maxHistorySize) {
      this.metricsHistory.shift()
    }

    // æ£€æŸ¥å†…å­˜ä½¿ç”¨ç‡
    this.checkThresholds(metrics)
    
    // å‘å‡ºæŒ‡æ ‡äº‹ä»¶
    this.emit('metrics', metrics)
  }

  private checkThresholds(metrics: MemoryMetrics): void {
    const now = Date.now()
    const { usagePercent } = metrics
    
    // å†·å´æ—¶é—´æ£€æŸ¥
    if (now - this.lastAlertTime < this.alertCooldown) {
      return
    }

    let alertLevel: string | null = null
    let recommendations: string[] = []

    if (usagePercent >= this.thresholds.emergency) {
      alertLevel = 'emergency'
      recommendations = [
        'ç«‹å³é‡Šæ”¾ä¸å¿…è¦çš„å¯¹è±¡å¼•ç”¨',
        'å¼ºåˆ¶æ‰§è¡Œåƒåœ¾å›æ”¶ global.gc()',
        'è€ƒè™‘é‡å¯åº”ç”¨ç¨‹åº',
        'æ£€æŸ¥æ˜¯å¦å­˜åœ¨å†…å­˜æ³„æ¼'
      ]
    } else if (usagePercent >= this.thresholds.critical) {
      alertLevel = 'critical'
      recommendations = [
        'æ¸…ç†ä¸´æ—¶ç¼“å­˜',
        'é‡Šæ”¾å¤§å‹å¯¹è±¡',
        'æ£€æŸ¥å¾ªç¯å¼•ç”¨',
        'è€ƒè™‘å¢åŠ å †å†…å­˜é™åˆ¶'
      ]
    } else if (usagePercent >= this.thresholds.warning) {
      alertLevel = 'warning'
      recommendations = [
        'ç›‘æ§å†…å­˜å¢é•¿è¶‹åŠ¿',
        'ä¼˜åŒ–æ•°æ®ç»“æ„',
        'æ£€æŸ¥æ˜¯å¦æœ‰å†…å­˜å¯†é›†æ“ä½œ',
        'è€ƒè™‘å®ç°åˆ†é¡µæˆ–æ‡’åŠ è½½'
      ]
    }

    // åªåœ¨è­¦å‘Šçº§åˆ«å‡çº§æ—¶å‘é€è­¦æŠ¥
    if (alertLevel && (
      !this.lastAlertLevel || 
      this.getAlertPriority(alertLevel) > this.getAlertPriority(this.lastAlertLevel)
    )) {
      const alert: MemoryAlert = {
        level: alertLevel as 'warning' | 'critical' | 'emergency',
        message: `å†…å­˜ä½¿ç”¨ç‡è¾¾åˆ° ${usagePercent.toFixed(2)}%`,
        metrics,
        recommendations
      }

      this.emit('alert', alert)
      logger.warn('å†…å­˜è­¦æŠ¥', alert)
      
      this.lastAlertLevel = alertLevel
      this.lastAlertTime = now
    }

    // é‡ç½®è­¦æŠ¥çº§åˆ«ï¼ˆå¦‚æœä½¿ç”¨ç‡ä¸‹é™ï¼‰
    if (!alertLevel && this.lastAlertLevel) {
      this.lastAlertLevel = null
      logger.info('å†…å­˜ä½¿ç”¨ç‡å·²æ¢å¤æ­£å¸¸')
    }
  }

  private getAlertPriority(level: string): number {
    switch (level) {
      case 'warning': return 1
      case 'critical': return 2
      case 'emergency': return 3
      default: return 0
    }
  }

  // è·å–å½“å‰æŒ‡æ ‡
  getCurrentMetrics(): MemoryMetrics | null {
    return this.metricsHistory[this.metricsHistory.length - 1] || null
  }

  // è·å–å†å²æŒ‡æ ‡
  getHistoricalMetrics(minutes: number = 10): MemoryMetrics[] {
    const cutoff = new Date(Date.now() - minutes * 60 * 1000)
    return this.metricsHistory.filter(m => m.timestamp >= cutoff)
  }

  // è·å–å†…å­˜ç»Ÿè®¡
  getMemoryStats() {
    if (this.metricsHistory.length === 0) return null

    const recent = this.getHistoricalMetrics(5) // æœ€è¿‘5åˆ†é’Ÿ
    const usageValues = recent.map(m => m.usagePercent)
    
    return {
      current: this.getCurrentMetrics(),
      avg: usageValues.reduce((a, b) => a + b, 0) / usageValues.length,
      min: Math.min(...usageValues),
      max: Math.max(...usageValues),
      trend: this.calculateTrend(usageValues),
      historySize: this.metricsHistory.length
    }
  }

  private calculateTrend(values: number[]): 'rising' | 'stable' | 'falling' {
    if (values.length < 2) return 'stable'
    
    const recent = values.slice(-5) // æœ€è¿‘5ä¸ªå€¼
    const older = values.slice(-10, -5) // ä¹‹å‰5ä¸ªå€¼
    
    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length
    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length
    
    const diff = recentAvg - olderAvg
    
    if (diff > 2) return 'rising'
    if (diff < -2) return 'falling'
    return 'stable'
  }

  // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆä»…åœ¨æœ‰--expose-gcæ ‡å¿—æ—¶æœ‰æ•ˆï¼‰
  forceGC(): boolean {
    if (global.gc) {
      const before = process.memoryUsage()
      global.gc()
      const after = process.memoryUsage()
      
      const freed = before.heapUsed - after.heapUsed
      logger.info(`å¼ºåˆ¶åƒåœ¾å›æ”¶é‡Šæ”¾äº† ${(freed / 1024 / 1024).toFixed(2)} MB`)
      return true
    } else {
      logger.warn('åƒåœ¾å›æ”¶ä¸å¯ç”¨ï¼Œéœ€è¦ --expose-gc æ ‡å¿—')
      return false
    }
  }

  // å†…å­˜ä¼˜åŒ–å»ºè®®
  getOptimizationSuggestions(): string[] {
    const stats = this.getMemoryStats()
    if (!stats) return []

    const suggestions: string[] = []
    
    if (stats.current && stats.current.usagePercent > 80) {
      suggestions.push('å½“å‰å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜ï¼Œè€ƒè™‘ä¼˜åŒ–æ•°æ®ç»“æ„')
    }
    
    if (stats.trend === 'rising') {
      suggestions.push('å†…å­˜ä½¿ç”¨è¶‹åŠ¿ä¸Šå‡ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨å†…å­˜æ³„æ¼')
    }
    
    if (stats.max > 90) {
      suggestions.push('å†…å­˜å³°å€¼ä½¿ç”¨ç‡è¶…è¿‡90%ï¼Œè€ƒè™‘å¢åŠ å †å†…å­˜é™åˆ¶')
    }

    if (suggestions.length === 0) {
      suggestions.push('å†…å­˜ä½¿ç”¨æƒ…å†µè‰¯å¥½ï¼Œç»§ç»­ä¿æŒ')
    }

    return suggestions
  }

  // ç”Ÿæˆå†…å­˜æŠ¥å‘Š
  generateReport(): string {
    const stats = this.getMemoryStats()
    if (!stats) return 'æš‚æ— å†…å­˜ç»Ÿè®¡æ•°æ®'

    const current = stats.current!
    
    return `
ğŸ“Š å†…å­˜ä½¿ç”¨æŠ¥å‘Š
================
å½“å‰ä½¿ç”¨ç‡: ${current.usagePercent.toFixed(2)}%
å †å†…å­˜: ${(current.heapUsed / 1024 / 1024).toFixed(2)} MB / ${(current.heapTotal / 1024 / 1024).toFixed(2)} MB
RSS: ${(current.rss / 1024 / 1024).toFixed(2)} MB
å¤–éƒ¨å†…å­˜: ${(current.external / 1024 / 1024).toFixed(2)} MB

ğŸ“ˆ ç»Ÿè®¡ä¿¡æ¯
================
å¹³å‡ä½¿ç”¨ç‡: ${stats.avg.toFixed(2)}%
æœ€å¤§ä½¿ç”¨ç‡: ${stats.max.toFixed(2)}%
æœ€å°ä½¿ç”¨ç‡: ${stats.min.toFixed(2)}%
ä½¿ç”¨è¶‹åŠ¿: ${stats.trend}

ğŸ’¡ ä¼˜åŒ–å»ºè®®
================
${this.getOptimizationSuggestions().map(s => `â€¢ ${s}`).join('\n')}
`
  }
}
```

### 4.2 å†…å­˜ä¼˜åŒ–ç®¡ç†å™¨

```typescript
// tools/monitoring/memory-optimizer.ts
import { EnterpriseMemoryMonitor, MemoryAlert, MemoryMetrics } from './memory-monitor'
import { createLogger } from '../generator/enterprise-logger'

const logger = createLogger('MemoryOptimizer')

export interface OptimizationAction {
  name: string
  description: string
  impact: 'low' | 'medium' | 'high'
  execute: () => Promise<boolean>
}

export class MemoryOptimizer {
  private monitor: EnterpriseMemoryMonitor
  private optimizationActions: OptimizationAction[] = []
  private autoOptimizationEnabled = false
  private isOptimizing = false

  constructor(monitor: EnterpriseMemoryMonitor) {
    this.monitor = monitor
    this.setupOptimizationActions()
    this.setupEventListeners()
  }

  private setupOptimizationActions(): void {
    this.optimizationActions = [
      {
        name: 'clearCache',
        description: 'æ¸…ç†å†…å­˜ç¼“å­˜',
        impact: 'medium',
        execute: async () => {
          // å®ç°ç¼“å­˜æ¸…ç†é€»è¾‘
          logger.info('æ‰§è¡Œç¼“å­˜æ¸…ç†')
          return true
        }
      },
      {
        name: 'forceGC',
        description: 'å¼ºåˆ¶åƒåœ¾å›æ”¶',
        impact: 'high',
        execute: async () => {
          return this.monitor.forceGC()
        }
      },
      {
        name: 'optimizeBuffers',
        description: 'ä¼˜åŒ–ç¼“å†²åŒº',
        impact: 'medium',
        execute: async () => {
          // å®ç°ç¼“å†²åŒºä¼˜åŒ–é€»è¾‘
          logger.info('ä¼˜åŒ–ç¼“å†²åŒº')
          return true
        }
      }
    ]
  }

  private setupEventListeners(): void {
    this.monitor.on('alert', async (alert: MemoryAlert) => {
      if (this.autoOptimizationEnabled && !this.isOptimizing) {
        await this.handleAlert(alert)
      }
    })
  }

  enableAutoOptimization(enabled: boolean = true): void {
    this.autoOptimizationEnabled = enabled
    logger.info(`è‡ªåŠ¨å†…å­˜ä¼˜åŒ–: ${enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`)
  }

  private async handleAlert(alert: MemoryAlert): Promise<void> {
    if (this.isOptimizing) return

    this.isOptimizing = true
    logger.warn(`å¤„ç†å†…å­˜è­¦æŠ¥: ${alert.level}`)

    try {
      switch (alert.level) {
        case 'warning':
          await this.executeOptimization(['clearCache'])
          break
        case 'critical':
          await this.executeOptimization(['clearCache', 'optimizeBuffers'])
          break
        case 'emergency':
          await this.executeOptimization(['clearCache', 'optimizeBuffers', 'forceGC'])
          break
      }
    } finally {
      this.isOptimizing = false
    }
  }

  async executeOptimization(actionNames: string[]): Promise<void> {
    logger.info(`æ‰§è¡Œå†…å­˜ä¼˜åŒ–: ${actionNames.join(', ')}`)

    const beforeMetrics = this.monitor.getCurrentMetrics()
    
    for (const actionName of actionNames) {
      const action = this.optimizationActions.find(a => a.name === actionName)
      if (!action) {
        logger.warn(`æœªæ‰¾åˆ°ä¼˜åŒ–æ“ä½œ: ${actionName}`)
        continue
      }

      try {
        const success = await action.execute()
        if (success) {
          logger.info(`ä¼˜åŒ–æ“ä½œæˆåŠŸ: ${action.description}`)
        } else {
          logger.warn(`ä¼˜åŒ–æ“ä½œå¤±è´¥: ${action.description}`)
        }
      } catch (error) {
        logger.error(`ä¼˜åŒ–æ“ä½œå¼‚å¸¸: ${action.description}`, error)
      }
    }

    // ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©GCå®Œæˆ
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    const afterMetrics = this.monitor.getCurrentMetrics()
    
    if (beforeMetrics && afterMetrics) {
      const memoryFreed = beforeMetrics.heapUsed - afterMetrics.heapUsed
      const usageReduction = beforeMetrics.usagePercent - afterMetrics.usagePercent
      
      logger.info(`å†…å­˜ä¼˜åŒ–å®Œæˆ`, {
        memoryFreed: `${(memoryFreed / 1024 / 1024).toFixed(2)} MB`,
        usageReduction: `${usageReduction.toFixed(2)}%`,
        currentUsage: `${afterMetrics.usagePercent.toFixed(2)}%`
      })
    }
  }

  // è·å–ä¼˜åŒ–å»ºè®®
  getOptimizationSuggestions(): OptimizationAction[] {
    const currentMetrics = this.monitor.getCurrentMetrics()
    if (!currentMetrics) return []

    const suggestions: OptimizationAction[] = []
    
    if (currentMetrics.usagePercent > 70) {
      suggestions.push(...this.optimizationActions.filter(a => a.impact === 'medium' || a.impact === 'high'))
    } else if (currentMetrics.usagePercent > 50) {
      suggestions.push(...this.optimizationActions.filter(a => a.impact === 'low' || a.impact === 'medium'))
    }

    return suggestions
  }

  // é¢„æµ‹å†…å­˜ä½¿ç”¨è¶‹åŠ¿
  predictMemoryTrend(): 'stable' | 'increasing' | 'critical' {
    const historical = this.monitor.getHistoricalMetrics(10)
    if (historical.length < 5) return 'stable'

    const recent = historical.slice(-3).map(m => m.usagePercent)
    const older = historical.slice(-6, -3).map(m => m.usagePercent)

    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length
    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length

    const trendSlope = recentAvg - olderAvg

    if (trendSlope > 5) return 'critical'
    if (trendSlope > 2) return 'increasing'
    return 'stable'
  }

  // ç”Ÿæˆä¼˜åŒ–æŠ¥å‘Š
  generateOptimizationReport(): string {
    const suggestions = this.getOptimizationSuggestions()
    const trend = this.predictMemoryTrend()
    const stats = this.monitor.getMemoryStats()

    return `
ğŸ”§ å†…å­˜ä¼˜åŒ–æŠ¥å‘Š
================
é¢„æµ‹è¶‹åŠ¿: ${trend}
è‡ªåŠ¨ä¼˜åŒ–: ${this.autoOptimizationEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}
æ­£åœ¨ä¼˜åŒ–: ${this.isOptimizing ? 'æ˜¯' : 'å¦'}

ğŸ’¡ å»ºè®®æ“ä½œ (${suggestions.length}ä¸ª)
================
${suggestions.map(s => `â€¢ ${s.description} [å½±å“: ${s.impact}]`).join('\n')}

ğŸ“Š å½“å‰çŠ¶æ€
================
${stats ? `ä½¿ç”¨ç‡: ${stats.current?.usagePercent.toFixed(2)}%` : 'æ— æ•°æ®'}
${stats ? `è¶‹åŠ¿: ${stats.trend}` : ''}
`
  }
}
```

---

ç»§ç»­é˜…è¯»P2é˜¶æ®µçš„å®Œæ•´å®ç°...
