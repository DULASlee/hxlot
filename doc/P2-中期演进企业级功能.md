# P2 ä¸­æœŸæ¼”è¿›ä¼ä¸šçº§åŠŸèƒ½ï¼ˆ3-6ä¸ªæœˆï¼‰

## ğŸ¯ P2 æ¼”è¿›ç›®æ ‡
- âœ… å¯è§†åŒ–é…ç½®ç•Œé¢å’Œæ‹–æ‹½è®¾è®¡å™¨
- âœ… å¤šå‰ç«¯æ¡†æ¶æ”¯æŒï¼ˆVue/React/Angularï¼‰
- âœ… ä¼ä¸šçº§ç®¡ç†æ§åˆ¶å°å’Œæƒé™ä½“ç³»

---

## Step 5: å¯è§†åŒ–é…ç½®ç•Œé¢

### 5.1 å¯è§†åŒ–è®¾è®¡å™¨æœåŠ¡ç«¯

```typescript
// tools/visual-designer/server.ts
import express from 'express'
import { WebSocketServer } from 'ws'
import { createServer } from 'http'
import { EnterpriseManifest, EnterpriseManifestSchema } from '../generator/enhanced-schema'
import { TransactionalIncrementalGenerator } from '../generator/transactional-generator'
import { createLogger } from '../generator/enterprise-logger'

const logger = createLogger('VisualDesigner')

export class VisualDesignerServer {
  private app = express()
  private server = createServer(this.app)
  private wss = new WebSocketServer({ server: this.server })
  private generator: TransactionalIncrementalGenerator
  private connectedClients = new Set<any>()

  constructor(private port: number = 3001) {
    this.generator = new TransactionalIncrementalGenerator(process.cwd())
    this.setupExpress()
    this.setupWebSocket()
  }

  private setupExpress(): void {
    this.app.use(express.json())
    this.app.use(express.static('tools/visual-designer/public'))

    // è·å–æ‰€æœ‰æ¨¡å—
    this.app.get('/api/modules', async (req, res) => {
      try {
        const manifests = await this.generator.loadManifests()
        res.json(manifests)
      } catch (error) {
        logger.error('è·å–æ¨¡å—å¤±è´¥', error)
        res.status(500).json({ error: 'è·å–æ¨¡å—å¤±è´¥' })
      }
    })

    // è·å–å•ä¸ªæ¨¡å—
    this.app.get('/api/modules/:name', async (req, res) => {
      try {
        const manifests = await this.generator.loadManifests()
        const module = manifests.find(m => m.name === req.params.name)
        
        if (!module) {
          return res.status(404).json({ error: 'æ¨¡å—æœªæ‰¾åˆ°' })
        }
        
        res.json(module)
      } catch (error) {
        logger.error('è·å–æ¨¡å—å¤±è´¥', error)
        res.status(500).json({ error: 'è·å–æ¨¡å—å¤±è´¥' })
      }
    })

    // åˆ›å»ºæˆ–æ›´æ–°æ¨¡å—
    this.app.post('/api/modules', async (req, res) => {
      try {
        const manifest = EnterpriseManifestSchema.parse(req.body)
        
        // ä¿å­˜æ¨¡å—é…ç½®
        await this.saveModuleManifest(manifest)
        
        // é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯
        this.broadcastToClients('moduleUpdated', manifest)
        
        res.json({ success: true, module: manifest })
      } catch (error) {
        logger.error('ä¿å­˜æ¨¡å—å¤±è´¥', error)
        res.status(400).json({ error: 'ä¿å­˜æ¨¡å—å¤±è´¥', details: error })
      }
    })

    // åˆ é™¤æ¨¡å—
    this.app.delete('/api/modules/:name', async (req, res) => {
      try {
        await this.deleteModule(req.params.name)
        
        // é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯
        this.broadcastToClients('moduleDeleted', { name: req.params.name })
        
        res.json({ success: true })
      } catch (error) {
        logger.error('åˆ é™¤æ¨¡å—å¤±è´¥', error)
        res.status(500).json({ error: 'åˆ é™¤æ¨¡å—å¤±è´¥' })
      }
    })

    // ç”Ÿæˆä»£ç 
    this.app.post('/api/generate', async (req, res) => {
      try {
        const manifests = await this.generator.loadManifests()
        await this.generator.generateWithTransaction(manifests)
        
        // é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯
        this.broadcastToClients('generationComplete', { timestamp: new Date() })
        
        res.json({ success: true, message: 'ä»£ç ç”Ÿæˆå®Œæˆ' })
      } catch (error) {
        logger.error('ä»£ç ç”Ÿæˆå¤±è´¥', error)
        res.status(500).json({ error: 'ä»£ç ç”Ÿæˆå¤±è´¥', details: error.message })
      }
    })

    // è·å–ç”ŸæˆçŠ¶æ€
    this.app.get('/api/status', (req, res) => {
      res.json({
        server: 'running',
        generator: 'ready',
        clients: this.connectedClients.size,
        timestamp: new Date()
      })
    })
  }

  private setupWebSocket(): void {
    this.wss.on('connection', (ws) => {
      logger.info('æ–°å®¢æˆ·ç«¯è¿æ¥')
      this.connectedClients.add(ws)

      ws.on('message', async (data) => {
        try {
          const message = JSON.parse(data.toString())
          await this.handleWebSocketMessage(ws, message)
        } catch (error) {
          logger.error('WebSocketæ¶ˆæ¯å¤„ç†å¤±è´¥', error)
        }
      })

      ws.on('close', () => {
        logger.info('å®¢æˆ·ç«¯æ–­å¼€è¿æ¥')
        this.connectedClients.delete(ws)
      })

      // å‘é€æ¬¢è¿æ¶ˆæ¯
      ws.send(JSON.stringify({
        type: 'welcome',
        data: { message: 'è¿æ¥åˆ°å¯è§†åŒ–è®¾è®¡å™¨' }
      }))
    })
  }

  private async handleWebSocketMessage(ws: any, message: any): Promise<void> {
    switch (message.type) {
      case 'ping':
        ws.send(JSON.stringify({ type: 'pong', data: { timestamp: new Date() } }))
        break

      case 'subscribe':
        // å®¢æˆ·ç«¯è®¢é˜…å®æ—¶æ›´æ–°
        ws.send(JSON.stringify({
          type: 'subscribed',
          data: { modules: await this.generator.loadManifests() }
        }))
        break

      case 'livePreview':
        // å®æ—¶é¢„è§ˆæ¨¡å—é…ç½®
        try {
          const manifest = EnterpriseManifestSchema.parse(message.data)
          const previewCode = await this.generatePreviewCode(manifest)
          
          ws.send(JSON.stringify({
            type: 'previewUpdate',
            data: { code: previewCode }
          }))
        } catch (error) {
          ws.send(JSON.stringify({
            type: 'error',
            data: { message: 'é¢„è§ˆç”Ÿæˆå¤±è´¥', error: error.message }
          }))
        }
        break
    }
  }

  private broadcastToClients(type: string, data: any): void {
    const message = JSON.stringify({ type, data })
    
    this.connectedClients.forEach(client => {
      if (client.readyState === 1) { // WebSocket.OPEN
        client.send(message)
      }
    })
  }

  private async saveModuleManifest(manifest: EnterpriseManifest): Promise<void> {
    const fs = require('fs').promises
    const path = require('path')
    
    const moduleDir = path.join(process.cwd(), 'src/modules', manifest.name)
    await fs.mkdir(moduleDir, { recursive: true })
    
    const manifestPath = path.join(moduleDir, 'abp.module.json')
    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2))
  }

  private async deleteModule(moduleName: string): Promise<void> {
    const fs = require('fs').promises
    const path = require('path')
    
    const moduleDir = path.join(process.cwd(), 'src/modules', moduleName)
    await fs.rm(moduleDir, { recursive: true, force: true })
  }

  private async generatePreviewCode(manifest: EnterpriseManifest): Promise<string> {
    // ç”Ÿæˆé¢„è§ˆä»£ç çš„ç®€åŒ–ç‰ˆæœ¬
    return `
// é¢„è§ˆ: ${manifest.name} æ¨¡å—
export const ${manifest.name}Preview = {
  name: '${manifest.name}',
  routes: ${JSON.stringify(manifest.routes, null, 2)},
  stores: ${JSON.stringify(manifest.stores, null, 2)},
  policies: ${JSON.stringify(manifest.policies, null, 2)}
}
`
  }

  async start(): Promise<void> {
    await this.generator.initialize()
    
    this.server.listen(this.port, () => {
      logger.info(`å¯è§†åŒ–è®¾è®¡å™¨æœåŠ¡å™¨å¯åŠ¨: http://localhost:${this.port}`)
    })
  }

  async stop(): Promise<void> {
    this.server.close()
    await this.generator.dispose()
    logger.info('å¯è§†åŒ–è®¾è®¡å™¨æœåŠ¡å™¨åœæ­¢')
  }
}

// å¯åŠ¨è„šæœ¬
if (require.main === module) {
  const server = new VisualDesignerServer()
  server.start().catch(console.error)

  process.on('SIGINT', async () => {
    await server.stop()
    process.exit(0)
  })
}
```

### 5.2 å¯è§†åŒ–è®¾è®¡å™¨å‰ç«¯ç•Œé¢

```html
<!-- tools/visual-designer/public/index.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä¼ä¸šçº§æ¨¡å—åŒ–ä»£ç ç”Ÿæˆå™¨ - å¯è§†åŒ–è®¾è®¡å™¨</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://unpkg.com/element-plus@2/dist/index.full.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/element-plus@2/dist/index.css">
  <style>
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
    .designer-container { display: flex; height: 100vh; }
    .sidebar { width: 300px; background: #f5f5f5; border-right: 1px solid #e0e0e0; overflow-y: auto; }
    .main-content { flex: 1; display: flex; flex-direction: column; }
    .toolbar { height: 60px; background: #fff; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; padding: 0 20px; }
    .canvas { flex: 1; background: #fafafa; position: relative; overflow: auto; }
    .properties-panel { width: 350px; background: #fff; border-left: 1px solid #e0e0e0; overflow-y: auto; }
    .module-card { margin: 10px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; }
    .module-card:hover { box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
    .canvas-module { position: absolute; background: white; border: 2px solid #409eff; border-radius: 8px; padding: 15px; min-width: 200px; cursor: move; }
    .canvas-module.selected { border-color: #67c23a; box-shadow: 0 0 10px rgba(103, 194, 58, 0.3); }
    .connection-line { position: absolute; height: 2px; background: #909399; transform-origin: left center; }
    .code-preview { background: #2d3748; color: #e2e8f0; padding: 20px; font-family: 'Monaco', 'Consolas', monospace; font-size: 14px; max-height: 400px; overflow-y: auto; }
  </style>
</head>
<body>
  <div id="app">
    <div class="designer-container">
      <!-- å·¦ä¾§æ¨¡å—åˆ—è¡¨ -->
      <div class="sidebar">
        <el-tabs v-model="activeTab" style="padding: 10px;">
          <el-tab-pane label="æ¨¡å—åº“" name="modules">
            <el-button type="primary" size="small" @click="createNewModule" style="width: 100%; margin-bottom: 10px;">
              <i class="el-icon-plus"></i> æ–°å»ºæ¨¡å—
            </el-button>
            
            <div v-for="module in modules" :key="module.name" class="module-card" @click="selectModule(module)">
              <h4 style="margin: 0 0 8px 0;">{{ module.displayName || module.name }}</h4>
              <p style="margin: 0; font-size: 12px; color: #666;">{{ module.description }}</p>
              <div style="margin-top: 8px; font-size: 12px;">
                <el-tag size="mini" v-for="fw in module.frameworks" :key="fw">{{ fw }}</el-tag>
              </div>
            </div>
          </el-tab-pane>
          
          <el-tab-pane label="ç»„ä»¶åº“" name="components">
            <div class="module-card" draggable="true" @dragstart="onDragStart($event, 'route')">
              <h4>è·¯ç”±ç»„ä»¶</h4>
              <p>é¡µé¢è·¯ç”±é…ç½®</p>
            </div>
            <div class="module-card" draggable="true" @dragstart="onDragStart($event, 'store')">
              <h4>çŠ¶æ€ç®¡ç†</h4>
              <p>Pinia/Redux Store</p>
            </div>
            <div class="module-card" draggable="true" @dragstart="onDragStart($event, 'policy')">
              <h4>æƒé™ç­–ç•¥</h4>
              <p>è®¿é—®æ§åˆ¶ç­–ç•¥</p>
            </div>
          </el-tab-pane>
        </el-tabs>
      </div>

      <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
      <div class="main-content">
        <!-- å·¥å…·æ  -->
        <div class="toolbar">
          <el-button type="primary" @click="generateCode" :loading="generating">
            <i class="el-icon-magic-stick"></i> ç”Ÿæˆä»£ç 
          </el-button>
          <el-button @click="saveAll">
            <i class="el-icon-document"></i> ä¿å­˜æ‰€æœ‰
          </el-button>
          <el-button @click="clearCanvas">
            <i class="el-icon-delete"></i> æ¸…ç©ºç”»å¸ƒ
          </el-button>
          
          <div style="margin-left: auto;">
            <el-switch v-model="livePreview" active-text="å®æ—¶é¢„è§ˆ"></el-switch>
            <span style="margin-left: 10px; color: #666;">å®¢æˆ·ç«¯: {{ connectedClients }}</span>
          </div>
        </div>

        <!-- è®¾è®¡ç”»å¸ƒ -->
        <div class="canvas" @drop="onDrop" @dragover.prevent @click="selectedModule = null">
          <div 
            v-for="(module, index) in canvasModules" 
            :key="module.id"
            class="canvas-module"
            :class="{ selected: selectedModule?.id === module.id }"
            :style="{ left: module.x + 'px', top: module.y + 'px' }"
            @click.stop="selectCanvasModule(module)"
            @mousedown="startDrag(module, $event)"
          >
            <h4 style="margin: 0 0 10px 0;">{{ module.name }}</h4>
            <div style="font-size: 12px; color: #666;">
              <div>è·¯ç”±: {{ module.routes?.length || 0 }}</div>
              <div>å­˜å‚¨: {{ module.stores?.length || 0 }}</div>
              <div>ç­–ç•¥: {{ module.policies?.length || 0 }}</div>
            </div>
          </div>

          <!-- è¿æ¥çº¿ -->
          <div 
            v-for="connection in connections" 
            :key="connection.id"
            class="connection-line"
            :style="getConnectionStyle(connection)"
          ></div>
        </div>
      </div>

      <!-- å³ä¾§å±æ€§é¢æ¿ -->
      <div class="properties-panel" v-if="selectedModule">
        <el-tabs v-model="propertiesTab" style="padding: 10px;">
          <el-tab-pane label="åŸºæœ¬ä¿¡æ¯" name="basic">
            <el-form label-width="80px" size="small">
              <el-form-item label="æ¨¡å—åç§°">
                <el-input v-model="selectedModule.name"></el-input>
              </el-form-item>
              <el-form-item label="æ˜¾ç¤ºåç§°">
                <el-input v-model="selectedModule.displayName"></el-input>
              </el-form-item>
              <el-form-item label="æè¿°">
                <el-input type="textarea" v-model="selectedModule.description"></el-input>
              </el-form-item>
              <el-form-item label="ç‰ˆæœ¬">
                <el-input v-model="selectedModule.version"></el-input>
              </el-form-item>
              <el-form-item label="æ¡†æ¶">
                <el-select v-model="selectedModule.frameworks" multiple style="width: 100%;">
                  <el-option label="Vue.js" value="vue"></el-option>
                  <el-option label="React" value="react"></el-option>
                  <el-option label="Angular" value="angular"></el-option>
                </el-select>
              </el-form-item>
            </el-form>
          </el-tab-pane>

          <el-tab-pane label="è·¯ç”±é…ç½®" name="routes">
            <el-button type="primary" size="mini" @click="addRoute" style="margin-bottom: 10px;">æ·»åŠ è·¯ç”±</el-button>
            
            <div v-for="(route, index) in selectedModule.routes" :key="index" style="border: 1px solid #e0e0e0; border-radius: 4px; padding: 10px; margin-bottom: 10px;">
              <el-form size="mini" label-width="60px">
                <el-form-item label="åç§°">
                  <el-input v-model="route.name"></el-input>
                </el-form-item>
                <el-form-item label="è·¯å¾„">
                  <el-input v-model="route.path"></el-input>
                </el-form-item>
                <el-form-item label="ç»„ä»¶">
                  <el-input v-model="route.component"></el-input>
                </el-form-item>
                <el-form-item label="æ ‡é¢˜">
                  <el-input v-model="route.meta.title"></el-input>
                </el-form-item>
                <el-button type="danger" size="mini" @click="removeRoute(index)">åˆ é™¤</el-button>
              </el-form>
            </div>
          </el-tab-pane>

          <el-tab-pane label="çŠ¶æ€ç®¡ç†" name="stores">
            <el-button type="primary" size="mini" @click="addStore" style="margin-bottom: 10px;">æ·»åŠ Store</el-button>
            
            <div v-for="(store, index) in selectedModule.stores" :key="index" style="border: 1px solid #e0e0e0; border-radius: 4px; padding: 10px; margin-bottom: 10px;">
              <el-form size="mini" label-width="60px">
                <el-form-item label="ID">
                  <el-input v-model="store.id"></el-input>
                </el-form-item>
                <el-form-item label="ç¬¦å·">
                  <el-input v-model="store.symbol"></el-input>
                </el-form-item>
                <el-form-item label="è·¯å¾„">
                  <el-input v-model="store.modulePath"></el-input>
                </el-form-item>
                <el-button type="danger" size="mini" @click="removeStore(index)">åˆ é™¤</el-button>
              </el-form>
            </div>
          </el-tab-pane>

          <el-tab-pane label="ä»£ç é¢„è§ˆ" name="preview">
            <div class="code-preview">{{ modulePreview }}</div>
          </el-tab-pane>
        </el-tabs>
      </div>
    </div>

    <!-- æ–°å»ºæ¨¡å—å¯¹è¯æ¡† -->
    <el-dialog title="æ–°å»ºæ¨¡å—" v-model="showCreateDialog" width="500px">
      <el-form :model="newModule" label-width="80px">
        <el-form-item label="æ¨¡å—åç§°" required>
          <el-input v-model="newModule.name" placeholder="PascalCaseå‘½å"></el-input>
        </el-form-item>
        <el-form-item label="æ˜¾ç¤ºåç§°">
          <el-input v-model="newModule.displayName"></el-input>
        </el-form-item>
        <el-form-item label="æè¿°">
          <el-input type="textarea" v-model="newModule.description"></el-input>
        </el-form-item>
        <el-form-item label="æ¡†æ¶æ”¯æŒ">
          <el-checkbox-group v-model="newModule.frameworks">
            <el-checkbox label="vue">Vue.js</el-checkbox>
            <el-checkbox label="react">React</el-checkbox>
            <el-checkbox label="angular">Angular</el-checkbox>
          </el-checkbox-group>
        </el-form-item>
      </el-form>
      
      <template #footer>
        <el-button @click="showCreateDialog = false">å–æ¶ˆ</el-button>
        <el-button type="primary" @click="confirmCreateModule">åˆ›å»º</el-button>
      </template>
    </el-dialog>
  </div>

  <script>
    const { createApp } = Vue

    createApp({
      data() {
        return {
          activeTab: 'modules',
          propertiesTab: 'basic',
          modules: [],
          canvasModules: [],
          selectedModule: null,
          connections: [],
          livePreview: true,
          generating: false,
          connectedClients: 0,
          ws: null,
          
          showCreateDialog: false,
          newModule: {
            name: '',
            displayName: '',
            description: '',
            frameworks: ['vue']
          },

          dragOffset: { x: 0, y: 0 },
          draggingModule: null,

          modulePreview: ''
        }
      },

      mounted() {
        this.initWebSocket()
        this.loadModules()
        
        // å…¨å±€é¼ æ ‡äº‹ä»¶
        document.addEventListener('mousemove', this.onMouseMove)
        document.addEventListener('mouseup', this.onMouseUp)
      },

      beforeUnmount() {
        if (this.ws) this.ws.close()
        document.removeEventListener('mousemove', this.onMouseMove)
        document.removeEventListener('mouseup', this.onMouseUp)
      },

      watch: {
        selectedModule: {
          handler(newVal) {
            if (newVal && this.livePreview) {
              this.updatePreview()
            }
          },
          deep: true
        }
      },

      methods: {
        initWebSocket() {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
          this.ws = new WebSocket(`${protocol}//${window.location.host}`)
          
          this.ws.onopen = () => {
            console.log('WebSocketè¿æ¥å·²å»ºç«‹')
            this.ws.send(JSON.stringify({ type: 'subscribe' }))
          }
          
          this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data)
            this.handleWebSocketMessage(message)
          }
          
          this.ws.onclose = () => {
            console.log('WebSocketè¿æ¥å·²å…³é—­')
            // é‡è¿é€»è¾‘
            setTimeout(() => this.initWebSocket(), 3000)
          }
        },

        handleWebSocketMessage(message) {
          switch (message.type) {
            case 'welcome':
              console.log(message.data.message)
              break
            case 'subscribed':
              this.modules = message.data.modules
              break
            case 'moduleUpdated':
              this.loadModules()
              break
            case 'generationComplete':
              this.generating = false
              this.$message.success('ä»£ç ç”Ÿæˆå®Œæˆ!')
              break
            case 'previewUpdate':
              this.modulePreview = message.data.code
              break
          }
        },

        async loadModules() {
          try {
            const response = await fetch('/api/modules')
            this.modules = await response.json()
          } catch (error) {
            this.$message.error('åŠ è½½æ¨¡å—å¤±è´¥')
          }
        },

        selectModule(module) {
          this.selectedModule = { ...module }
          this.ensureModuleStructure()
        },

        selectCanvasModule(module) {
          this.selectedModule = module
          this.ensureModuleStructure()
        },

        ensureModuleStructure() {
          if (!this.selectedModule.routes) this.selectedModule.routes = []
          if (!this.selectedModule.stores) this.selectedModule.stores = []
          if (!this.selectedModule.policies) this.selectedModule.policies = []
          if (!this.selectedModule.meta) this.selectedModule.meta = {}
        },

        createNewModule() {
          this.newModule = {
            name: '',
            displayName: '',
            description: '',
            frameworks: ['vue']
          }
          this.showCreateDialog = true
        },

        async confirmCreateModule() {
          const module = {
            ...this.newModule,
            version: '1.0.0',
            routes: [],
            stores: [],
            policies: [],
            lifecycle: {},
            capabilities: {}
          }

          try {
            const response = await fetch('/api/modules', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(module)
            })

            if (response.ok) {
              this.$message.success('æ¨¡å—åˆ›å»ºæˆåŠŸ')
              this.showCreateDialog = false
              this.loadModules()
            }
          } catch (error) {
            this.$message.error('åˆ›å»ºæ¨¡å—å¤±è´¥')
          }
        },

        addRoute() {
          this.selectedModule.routes.push({
            name: '',
            path: '',
            component: '',
            framework: this.selectedModule.frameworks[0] || 'vue',
            meta: { title: '' }
          })
        },

        removeRoute(index) {
          this.selectedModule.routes.splice(index, 1)
        },

        addStore() {
          this.selectedModule.stores.push({
            id: '',
            symbol: '',
            modulePath: '',
            framework: this.selectedModule.frameworks[0] || 'vue'
          })
        },

        removeStore(index) {
          this.selectedModule.stores.splice(index, 1)
        },

        onDragStart(event, type) {
          event.dataTransfer.setData('componentType', type)
        },

        onDrop(event) {
          event.preventDefault()
          const componentType = event.dataTransfer.getData('componentType')
          
          if (componentType) {
            const rect = event.currentTarget.getBoundingClientRect()
            const x = event.clientX - rect.left
            const y = event.clientY - rect.top

            this.addComponentToCanvas(componentType, x, y)
          }
        },

        addComponentToCanvas(type, x, y) {
          const id = Date.now().toString()
          const module = {
            id,
            name: `æ–°${type}æ¨¡å—`,
            x,
            y,
            type,
            routes: [],
            stores: [],
            policies: [],
            frameworks: ['vue']
          }

          this.canvasModules.push(module)
        },

        startDrag(module, event) {
          this.draggingModule = module
          const rect = event.currentTarget.getBoundingClientRect()
          this.dragOffset = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
          }
        },

        onMouseMove(event) {
          if (this.draggingModule) {
            const canvas = document.querySelector('.canvas')
            const canvasRect = canvas.getBoundingClientRect()
            
            this.draggingModule.x = event.clientX - canvasRect.left - this.dragOffset.x
            this.draggingModule.y = event.clientY - canvasRect.top - this.dragOffset.y
          }
        },

        onMouseUp() {
          this.draggingModule = null
        },

        async generateCode() {
          this.generating = true
          
          try {
            const response = await fetch('/api/generate', { method: 'POST' })
            const result = await response.json()
            
            if (!response.ok) {
              throw new Error(result.error)
            }
          } catch (error) {
            this.$message.error('ä»£ç ç”Ÿæˆå¤±è´¥: ' + error.message)
            this.generating = false
          }
        },

        async saveAll() {
          if (this.selectedModule) {
            try {
              const response = await fetch('/api/modules', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(this.selectedModule)
              })

              if (response.ok) {
                this.$message.success('ä¿å­˜æˆåŠŸ')
              }
            } catch (error) {
              this.$message.error('ä¿å­˜å¤±è´¥')
            }
          }
        },

        clearCanvas() {
          this.canvasModules = []
          this.connections = []
          this.selectedModule = null
        },

        updatePreview() {
          if (this.ws && this.selectedModule) {
            this.ws.send(JSON.stringify({
              type: 'livePreview',
              data: this.selectedModule
            }))
          }
        },

        getConnectionStyle(connection) {
          // è®¡ç®—è¿æ¥çº¿æ ·å¼
          const length = Math.sqrt(
            Math.pow(connection.toX - connection.fromX, 2) + 
            Math.pow(connection.toY - connection.fromY, 2)
          )
          const angle = Math.atan2(
            connection.toY - connection.fromY, 
            connection.toX - connection.fromX
          ) * 180 / Math.PI

          return {
            left: connection.fromX + 'px',
            top: connection.fromY + 'px',
            width: length + 'px',
            transform: `rotate(${angle}deg)`
          }
        }
      }
    }).use(ElementPlus).mount('#app')
  </script>
</body>
</html>
```

### 5.3 æ¨¡å—ä¾èµ–å…³ç³»å¯è§†åŒ–

```typescript
// tools/visual-designer/dependency-visualizer.ts
export interface DependencyNode {
  id: string
  name: string
  x: number
  y: number
  type: 'module' | 'route' | 'store' | 'policy'
  dependencies: string[]
  dependents: string[]
  metadata: Record<string, any>
}

export interface DependencyEdge {
  id: string
  from: string
  to: string
  type: 'depends' | 'provides' | 'uses'
  weight: number
}

export class DependencyVisualizer {
  private nodes: Map<string, DependencyNode> = new Map()
  private edges: Map<string, DependencyEdge> = new Map()

  constructor(private manifests: EnterpriseManifest[]) {
    this.buildDependencyGraph()
  }

  private buildDependencyGraph(): void {
    // æ„å»ºæ¨¡å—èŠ‚ç‚¹
    this.manifests.forEach((manifest, index) => {
      const node: DependencyNode = {
        id: manifest.name,
        name: manifest.displayName || manifest.name,
        x: (index % 5) * 200 + 100,
        y: Math.floor(index / 5) * 150 + 100,
        type: 'module',
        dependencies: manifest.dependsOn || [],
        dependents: [],
        metadata: {
          version: manifest.version,
          frameworks: manifest.frameworks,
          routeCount: manifest.routes.length,
          storeCount: manifest.stores.length
        }
      }

      this.nodes.set(manifest.name, node)
    })

    // æ„å»ºä¾èµ–è¾¹
    this.manifests.forEach(manifest => {
      manifest.dependsOn?.forEach(dep => {
        const edgeId = `${manifest.name}->${dep}`
        this.edges.set(edgeId, {
          id: edgeId,
          from: manifest.name,
          to: dep,
          type: 'depends',
          weight: 1
        })

        // æ›´æ–°è¢«ä¾èµ–æ¨¡å—çš„ dependents
        const depNode = this.nodes.get(dep)
        if (depNode) {
          depNode.dependents.push(manifest.name)
        }
      })
    })
  }

  // è‡ªåŠ¨å¸ƒå±€ç®—æ³• - Force-directed layout
  autoLayout(iterations: number = 100): void {
    const k = 100 // ç†æƒ³è¾¹é•¿
    const repulsionStrength = 1000
    const attractionStrength = 0.1

    for (let iter = 0; iter < iterations; iter++) {
      const forces = new Map<string, { fx: number, fy: number }>()

      // åˆå§‹åŒ–åŠ›
      this.nodes.forEach((node, id) => {
        forces.set(id, { fx: 0, fy: 0 })
      })

      // è®¡ç®—æ–¥åŠ›
      this.nodes.forEach((node1, id1) => {
        this.nodes.forEach((node2, id2) => {
          if (id1 !== id2) {
            const dx = node1.x - node2.x
            const dy = node1.y - node2.y
            const distance = Math.sqrt(dx * dx + dy * dy) || 1

            const force = repulsionStrength / (distance * distance)
            const fx = (dx / distance) * force
            const fy = (dy / distance) * force

            const node1Force = forces.get(id1)!
            node1Force.fx += fx
            node1Force.fy += fy
          }
        })
      })

      // è®¡ç®—å¼•åŠ›
      this.edges.forEach(edge => {
        const node1 = this.nodes.get(edge.from)!
        const node2 = this.nodes.get(edge.to)!

        const dx = node2.x - node1.x
        const dy = node2.y - node1.y
        const distance = Math.sqrt(dx * dx + dy * dy) || 1

        const force = attractionStrength * (distance - k)
        const fx = (dx / distance) * force
        const fy = (dy / distance) * force

        const node1Force = forces.get(edge.from)!
        const node2Force = forces.get(edge.to)!

        node1Force.fx += fx
        node1Force.fy += fy
        node2Force.fx -= fx
        node2Force.fy -= fy
      })

      // åº”ç”¨åŠ›å¹¶æ›´æ–°ä½ç½®
      const damping = 0.9
      forces.forEach((force, nodeId) => {
        const node = this.nodes.get(nodeId)!
        node.x += force.fx * damping
        node.y += force.fy * damping

        // è¾¹ç•Œé™åˆ¶
        node.x = Math.max(50, Math.min(1000, node.x))
        node.y = Math.max(50, Math.min(600, node.y))
      })
    }
  }

  // æ£€æµ‹å¾ªç¯ä¾èµ–
  detectCircularDependencies(): string[][] {
    const visited = new Set<string>()
    const recursionStack = new Set<string>()
    const cycles: string[][] = []

    const dfs = (nodeId: string, path: string[]): void => {
      visited.add(nodeId)
      recursionStack.add(nodeId)
      path.push(nodeId)

      const node = this.nodes.get(nodeId)
      if (node) {
        for (const dep of node.dependencies) {
          if (!visited.has(dep)) {
            dfs(dep, [...path])
          } else if (recursionStack.has(dep)) {
            // æ‰¾åˆ°å¾ªç¯
            const cycleStart = path.indexOf(dep)
            cycles.push([...path.slice(cycleStart), dep])
          }
        }
      }

      recursionStack.delete(nodeId)
    }

    this.nodes.forEach((_, nodeId) => {
      if (!visited.has(nodeId)) {
        dfs(nodeId, [])
      }
    })

    return cycles
  }

  // è®¡ç®—æ¨¡å—å½±å“åº¦
  calculateInfluence(): Map<string, number> {
    const influence = new Map<string, number>()

    this.nodes.forEach((node, id) => {
      // å½±å“åº¦ = ç›´æ¥ä¾èµ–æ•° + é—´æ¥ä¾èµ–æ•° * æƒé‡
      const directDependents = node.dependents.length
      const indirectDependents = this.getIndirectDependents(id)
      
      influence.set(id, directDependents + indirectDependents * 0.5)
    })

    return influence
  }

  private getIndirectDependents(nodeId: string): number {
    const visited = new Set<string>()
    const queue = [nodeId]
    let count = 0

    while (queue.length > 0) {
      const current = queue.shift()!
      if (visited.has(current)) continue

      visited.add(current)
      const node = this.nodes.get(current)
      
      if (node) {
        node.dependents.forEach(dep => {
          if (!visited.has(dep)) {
            queue.push(dep)
            count++
          }
        })
      }
    }

    return count
  }

  // å¯¼å‡ºå¯è§†åŒ–æ•°æ®
  exportVisualizationData() {
    return {
      nodes: Array.from(this.nodes.values()),
      edges: Array.from(this.edges.values()),
      circularDependencies: this.detectCircularDependencies(),
      influence: Object.fromEntries(this.calculateInfluence())
    }
  }
}
```

---

## Step 6: ä¼ä¸šçº§ç®¡ç†æ§åˆ¶å°

### 6.1 ä¼ä¸šçº§æƒé™ä½“ç³»

```typescript
// tools/enterprise/rbac-system.ts
export interface User {
  id: string
  username: string
  email: string
  roles: Role[]
  permissions: Permission[]
  profile: UserProfile
  isActive: boolean
  lastLogin?: Date
}

export interface Role {
  id: string
  name: string
  displayName: string
  description: string
  permissions: Permission[]
  isSystem: boolean
  createdAt: Date
  updatedAt: Date
}

export interface Permission {
  id: string
  resource: string
  action: string
  scope: 'global' | 'module' | 'project'
  conditions?: PermissionCondition[]
}

export interface PermissionCondition {
  field: string
  operator: 'equals' | 'contains' | 'startsWith' | 'in'
  value: any
}

export interface UserProfile {
  firstName: string
  lastName: string
  avatar?: string
  department: string
  title: string
  phone?: string
  preferences: Record<string, any>
}

export class EnterpriseRBACSystem {
  private users = new Map<string, User>()
  private roles = new Map<string, Role>()
  private permissions = new Map<string, Permission>()
  private sessions = new Map<string, UserSession>()

  constructor() {
    this.initializeSystemRoles()
  }

  private initializeSystemRoles(): void {
    // ç³»ç»Ÿç®¡ç†å‘˜è§’è‰²
    const adminRole: Role = {
      id: 'system-admin',
      name: 'SystemAdmin',
      displayName: 'ç³»ç»Ÿç®¡ç†å‘˜',
      description: 'æ‹¥æœ‰æ‰€æœ‰ç³»ç»Ÿæƒé™',
      permissions: [
        { id: 'admin-all', resource: '*', action: '*', scope: 'global' }
      ],
      isSystem: true,
      createdAt: new Date(),
      updatedAt: new Date()
    }

    // å¼€å‘è€…è§’è‰²
    const developerRole: Role = {
      id: 'developer',
      name: 'Developer',
      displayName: 'å¼€å‘è€…',
      description: 'å¯ä»¥åˆ›å»ºå’Œç®¡ç†æ¨¡å—',
      permissions: [
        { id: 'module-create', resource: 'module', action: 'create', scope: 'global' },
        { id: 'module-read', resource: 'module', action: 'read', scope: 'global' },
        { id: 'module-update', resource: 'module', action: 'update', scope: 'module' },
        { id: 'module-delete', resource: 'module', action: 'delete', scope: 'module' },
        { id: 'generator-execute', resource: 'generator', action: 'execute', scope: 'global' }
      ],
      isSystem: true,
      createdAt: new Date(),
      updatedAt: new Date()
    }

    // æŸ¥çœ‹è€…è§’è‰²
    const viewerRole: Role = {
      id: 'viewer',
      name: 'Viewer',
      displayName: 'æŸ¥çœ‹è€…',
      description: 'åªèƒ½æŸ¥çœ‹æ¨¡å—å’Œç”Ÿæˆçš„ä»£ç ',
      permissions: [
        { id: 'module-read-only', resource: 'module', action: 'read', scope: 'global' },
        { id: 'code-view', resource: 'code', action: 'read', scope: 'global' }
      ],
      isSystem: true,
      createdAt: new Date(),
      updatedAt: new Date()
    }

    this.roles.set(adminRole.id, adminRole)
    this.roles.set(developerRole.id, developerRole)
    this.roles.set(viewerRole.id, viewerRole)
  }

  // ç”¨æˆ·ç®¡ç†
  async createUser(userData: Omit<User, 'id' | 'roles' | 'permissions'>): Promise<User> {
    const user: User = {
      ...userData,
      id: this.generateId(),
      roles: [],
      permissions: []
    }

    this.users.set(user.id, user)
    return user
  }

  async assignRoleToUser(userId: string, roleId: string): Promise<void> {
    const user = this.users.get(userId)
    const role = this.roles.get(roleId)

    if (!user || !role) {
      throw new Error('ç”¨æˆ·æˆ–è§’è‰²ä¸å­˜åœ¨')
    }

    if (!user.roles.find(r => r.id === roleId)) {
      user.roles.push(role)
      this.updateUserPermissions(user)
    }
  }

  async revokeRoleFromUser(userId: string, roleId: string): Promise<void> {
    const user = this.users.get(userId)
    if (!user) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨')
    }

    user.roles = user.roles.filter(r => r.id !== roleId)
    this.updateUserPermissions(user)
  }

  private updateUserPermissions(user: User): void {
    const allPermissions = new Map<string, Permission>()

    // ä»è§’è‰²ç»§æ‰¿æƒé™
    user.roles.forEach(role => {
      role.permissions.forEach(permission => {
        allPermissions.set(permission.id, permission)
      })
    })

    user.permissions = Array.from(allPermissions.values())
  }

  // æƒé™æ£€æŸ¥
  hasPermission(
    userId: string, 
    resource: string, 
    action: string, 
    context?: Record<string, any>
  ): boolean {
    const user = this.users.get(userId)
    if (!user || !user.isActive) {
      return false
    }

    return user.permissions.some(permission => {
      // æ£€æŸ¥èµ„æºå’Œæ“ä½œåŒ¹é…
      const resourceMatch = permission.resource === '*' || permission.resource === resource
      const actionMatch = permission.action === '*' || permission.action === action

      if (!resourceMatch || !actionMatch) {
        return false
      }

      // æ£€æŸ¥æ¡ä»¶
      if (permission.conditions && context) {
        return this.evaluateConditions(permission.conditions, context)
      }

      return true
    })
  }

  private evaluateConditions(
    conditions: PermissionCondition[], 
    context: Record<string, any>
  ): boolean {
    return conditions.every(condition => {
      const contextValue = context[condition.field]
      
      switch (condition.operator) {
        case 'equals':
          return contextValue === condition.value
        case 'contains':
          return Array.isArray(contextValue) && contextValue.includes(condition.value)
        case 'startsWith':
          return typeof contextValue === 'string' && contextValue.startsWith(condition.value)
        case 'in':
          return Array.isArray(condition.value) && condition.value.includes(contextValue)
        default:
          return false
      }
    })
  }

  // ä¼šè¯ç®¡ç†
  async createSession(userId: string): Promise<string> {
    const user = this.users.get(userId)
    if (!user || !user.isActive) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²ç¦ç”¨')
    }

    const sessionId = this.generateSessionId()
    const session: UserSession = {
      id: sessionId,
      userId,
      createdAt: new Date(),
      lastAccessAt: new Date(),
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24å°æ—¶
      ipAddress: '',
      userAgent: ''
    }

    this.sessions.set(sessionId, session)
    user.lastLogin = new Date()

    return sessionId
  }

  async validateSession(sessionId: string): Promise<User | null> {
    const session = this.sessions.get(sessionId)
    if (!session || session.expiresAt < new Date()) {
      return null
    }

    session.lastAccessAt = new Date()
    return this.users.get(session.userId) || null
  }

  async revokeSession(sessionId: string): Promise<void> {
    this.sessions.delete(sessionId)
  }

  // å®¡è®¡æ—¥å¿—
  logUserAction(
    userId: string, 
    action: string, 
    resource: string, 
    details?: Record<string, any>
  ): void {
    const auditLog = {
      timestamp: new Date(),
      userId,
      action,
      resource,
      details,
      sessionId: Array.from(this.sessions.entries())
        .find(([_, session]) => session.userId === userId)?.[0]
    }

    // è¿™é‡Œåº”è¯¥å°†å®¡è®¡æ—¥å¿—ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨
    console.log('å®¡è®¡æ—¥å¿—:', auditLog)
  }

  private generateId(): string {
    return 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
  }

  private generateSessionId(): string {
    return 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 16)
  }

  // è·å–ç”¨æˆ·åˆ—è¡¨
  getUsers(): User[] {
    return Array.from(this.users.values())
  }

  // è·å–è§’è‰²åˆ—è¡¨  
  getRoles(): Role[] {
    return Array.from(this.roles.values())
  }

  // åˆ›å»ºè‡ªå®šä¹‰è§’è‰²
  async createRole(roleData: Omit<Role, 'id' | 'createdAt' | 'updatedAt'>): Promise<Role> {
    const role: Role = {
      ...roleData,
      id: this.generateId(),
      createdAt: new Date(),
      updatedAt: new Date()
    }

    this.roles.set(role.id, role)
    return role
  }
}

interface UserSession {
  id: string
  userId: string
  createdAt: Date
  lastAccessAt: Date
  expiresAt: Date
  ipAddress: string
  userAgent: string
}
```

### 6.2 ä¼ä¸šçº§ç›‘æ§é¢æ¿

```typescript
// tools/enterprise/monitoring-dashboard.ts
import { EnterpriseMemoryMonitor } from '../monitoring/memory-monitor'
import { TransactionalIncrementalGenerator } from '../generator/transactional-generator'
import { EnterpriseRBACSystem } from './rbac-system'

export interface SystemMetrics {
  timestamp: Date
  cpu: {
    usage: number
    loadAverage: number[]
  }
  memory: {
    heapUsed: number
    heapTotal: number
    external: number
    rss: number
    usagePercent: number
  }
  generator: {
    lastGenerationTime?: Date
    generationCount: number
    activeTransactions: number
    failedGenerations: number
  }
  users: {
    totalUsers: number
    activeUsers: number
    currentSessions: number
  }
  modules: {
    totalModules: number
    generatedFiles: number
    lastModified?: Date
  }
}

export interface Alert {
  id: string
  level: 'info' | 'warning' | 'error' | 'critical'
  title: string
  message: string
  timestamp: Date
  source: string
  acknowledged: boolean
  resolvedAt?: Date
}

export class EnterpriseMonitoringDashboard {
  private memoryMonitor: EnterpriseMemoryMonitor
  private generator: TransactionalIncrementalGenerator
  private rbacSystem: EnterpriseRBACSystem
  private metricsHistory: SystemMetrics[] = []
  private alerts: Map<string, Alert> = new Map()
  private isMonitoring = false

  constructor() {
    this.memoryMonitor = new EnterpriseMemoryMonitor()
    this.generator = new TransactionalIncrementalGenerator(process.cwd())
    this.rbacSystem = new EnterpriseRBACSystem()
    
    this.setupAlertHandlers()
  }

  private setupAlertHandlers(): void {
    this.memoryMonitor.on('alert', (memoryAlert) => {
      this.createAlert({
        level: memoryAlert.level as any,
        title: 'å†…å­˜ä½¿ç”¨è­¦æŠ¥',
        message: memoryAlert.message,
        source: 'memory-monitor'
      })
    })
  }

  async start(): Promise<void> {
    if (this.isMonitoring) return

    this.isMonitoring = true
    this.memoryMonitor.start()
    
    // æ¯30ç§’æ”¶é›†ä¸€æ¬¡ç³»ç»ŸæŒ‡æ ‡
    setInterval(() => {
      this.collectSystemMetrics()
    }, 30000)

    // ç«‹å³æ”¶é›†ä¸€æ¬¡
    this.collectSystemMetrics()
  }

  stop(): void {
    this.isMonitoring = false
    this.memoryMonitor.stop()
  }

  private collectSystemMetrics(): void {
    const memoryMetrics = this.memoryMonitor.getCurrentMetrics()
    const generatorStats = this.getGeneratorStats()
    const userStats = this.getUserStats()
    const moduleStats = this.getModuleStats()

    const metrics: SystemMetrics = {
      timestamp: new Date(),
      cpu: {
        usage: process.cpuUsage().user / 1000000, // è½¬æ¢ä¸ºç§’
        loadAverage: require('os').loadavg()
      },
      memory: memoryMetrics ? {
        heapUsed: memoryMetrics.heapUsed,
        heapTotal: memoryMetrics.heapTotal,
        external: memoryMetrics.external,
        rss: memoryMetrics.rss,
        usagePercent: memoryMetrics.usagePercent
      } : {
        heapUsed: 0,
        heapTotal: 0,
        external: 0,
        rss: 0,
        usagePercent: 0
      },
      generator: generatorStats,
      users: userStats,
      modules: moduleStats
    }

    this.metricsHistory.push(metrics)
    
    // ä¿ç•™æœ€è¿‘1000æ¡è®°å½•
    if (this.metricsHistory.length > 1000) {
      this.metricsHistory.shift()
    }

    // æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶å†µ
    this.checkSystemHealth(metrics)
  }

  private getGeneratorStats() {
    return {
      lastGenerationTime: undefined, // ä»ç”Ÿæˆå™¨è·å–
      generationCount: 0,
      activeTransactions: 0,
      failedGenerations: 0
    }
  }

  private getUserStats() {
    const users = this.rbacSystem.getUsers()
    return {
      totalUsers: users.length,
      activeUsers: users.filter(u => u.isActive).length,
      currentSessions: 0 // ä»ä¼šè¯ç®¡ç†å™¨è·å–
    }
  }

  private getModuleStats() {
    return {
      totalModules: 0,
      generatedFiles: 0,
      lastModified: undefined
    }
  }

  private checkSystemHealth(metrics: SystemMetrics): void {
    // å†…å­˜ä½¿ç”¨ç‡æ£€æŸ¥
    if (metrics.memory.usagePercent > 90) {
      this.createAlert({
        level: 'critical',
        title: 'å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜',
        message: `å†…å­˜ä½¿ç”¨ç‡è¾¾åˆ° ${metrics.memory.usagePercent.toFixed(2)}%`,
        source: 'health-check'
      })
    }

    // CPUè´Ÿè½½æ£€æŸ¥
    if (metrics.cpu.loadAverage[0] > 2) {
      this.createAlert({
        level: 'warning',
        title: 'CPUè´Ÿè½½è¿‡é«˜',
        message: `1åˆ†é’Ÿå¹³å‡è´Ÿè½½: ${metrics.cpu.loadAverage[0].toFixed(2)}`,
        source: 'health-check'
      })
    }

    // ç”¨æˆ·ä¼šè¯æ£€æŸ¥
    if (metrics.users.currentSessions > 100) {
      this.createAlert({
        level: 'info',
        title: 'é«˜å¹¶å‘ä¼šè¯',
        message: `å½“å‰æ´»è·ƒä¼šè¯æ•°: ${metrics.users.currentSessions}`,
        source: 'session-monitor'
      })
    }
  }

  createAlert(alertData: Omit<Alert, 'id' | 'timestamp' | 'acknowledged'>): string {
    const alert: Alert = {
      ...alertData,
      id: 'alert_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      timestamp: new Date(),
      acknowledged: false
    }

    this.alerts.set(alert.id, alert)
    return alert.id
  }

  acknowledgeAlert(alertId: string): void {
    const alert = this.alerts.get(alertId)
    if (alert) {
      alert.acknowledged = true
    }
  }

  resolveAlert(alertId: string): void {
    const alert = this.alerts.get(alertId)
    if (alert) {
      alert.resolvedAt = new Date()
    }
  }

  getAlerts(filter?: { level?: string, acknowledged?: boolean }): Alert[] {
    let alerts = Array.from(this.alerts.values())

    if (filter) {
      if (filter.level) {
        alerts = alerts.filter(a => a.level === filter.level)
      }
      if (filter.acknowledged !== undefined) {
        alerts = alerts.filter(a => a.acknowledged === filter.acknowledged)
      }
    }

    return alerts.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
  }

  getSystemMetrics(hours: number = 1): SystemMetrics[] {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000)
    return this.metricsHistory.filter(m => m.timestamp >= cutoff)
  }

  getCurrentSystemStatus(): {
    status: 'healthy' | 'warning' | 'critical'
    summary: string
    details: Record<string, any>
  } {
    const latest = this.metricsHistory[this.metricsHistory.length - 1]
    if (!latest) {
      return {
        status: 'warning',
        summary: 'ç³»ç»Ÿæ•°æ®ä¸å¯ç”¨',
        details: {}
      }
    }

    const unacknowledgedAlerts = this.getAlerts({ acknowledged: false })
    const criticalAlerts = unacknowledgedAlerts.filter(a => a.level === 'critical')
    const warningAlerts = unacknowledgedAlerts.filter(a => a.level === 'warning')

    let status: 'healthy' | 'warning' | 'critical' = 'healthy'
    let summary = 'ç³»ç»Ÿè¿è¡Œæ­£å¸¸'

    if (criticalAlerts.length > 0) {
      status = 'critical'
      summary = `å­˜åœ¨ ${criticalAlerts.length} ä¸ªä¸¥é‡è­¦æŠ¥`
    } else if (warningAlerts.length > 0) {
      status = 'warning'
      summary = `å­˜åœ¨ ${warningAlerts.length} ä¸ªè­¦å‘Š`
    }

    return {
      status,
      summary,
      details: {
        memoryUsage: `${latest.memory.usagePercent.toFixed(2)}%`,
        cpuLoad: latest.cpu.loadAverage[0].toFixed(2),
        activeUsers: latest.users.activeUsers,
        totalModules: latest.modules.totalModules,
        unacknowledgedAlerts: unacknowledgedAlerts.length
      }
    }
  }

  generateHealthReport(): string {
    const status = this.getCurrentSystemStatus()
    const recent = this.getSystemMetrics(1)
    const alerts = this.getAlerts({ acknowledged: false })

    return `
ğŸ“Š ä¼ä¸šçº§ç›‘æ§é¢æ¿ - ç³»ç»Ÿå¥åº·æŠ¥å‘Š
=======================================

ğŸ¯ ç³»ç»ŸçŠ¶æ€: ${status.status.toUpperCase()}
ğŸ“ çŠ¶æ€æ¦‚è¦: ${status.summary}

ğŸ“ˆ ç³»ç»ŸæŒ‡æ ‡ (æœ€è¿‘1å°æ—¶)
=======================================
å†…å­˜ä½¿ç”¨: ${status.details.memoryUsage}
CPUè´Ÿè½½: ${status.details.cpuLoad}
æ´»è·ƒç”¨æˆ·: ${status.details.activeUsers}
æ¨¡å—æ€»æ•°: ${status.details.totalModules}

ğŸš¨ æ´»è·ƒè­¦æŠ¥ (${alerts.length}ä¸ª)
=======================================
${alerts.slice(0, 5).map(alert => 
  `[${alert.level.toUpperCase()}] ${alert.title}\n   ${alert.message}`
).join('\n')}

ğŸ’¡ ä¼˜åŒ–å»ºè®®
=======================================
${this.generateOptimizationSuggestions().map(s => `â€¢ ${s}`).join('\n')}

æŠ¥å‘Šç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString('zh-CN')}
`
  }

  private generateOptimizationSuggestions(): string[] {
    const suggestions: string[] = []
    const latest = this.metricsHistory[this.metricsHistory.length - 1]
    
    if (latest) {
      if (latest.memory.usagePercent > 80) {
        suggestions.push('å†…å­˜ä½¿ç”¨ç‡è¾ƒé«˜ï¼Œå»ºè®®å¯ç”¨è‡ªåŠ¨å†…å­˜ä¼˜åŒ–')
      }
      
      if (latest.cpu.loadAverage[0] > 1.5) {
        suggestions.push('CPUè´Ÿè½½è¾ƒé«˜ï¼Œè€ƒè™‘ä¼˜åŒ–ç”Ÿæˆå™¨æ€§èƒ½æˆ–å¢åŠ èµ„æº')
      }
      
      if (latest.users.currentSessions > 50) {
        suggestions.push('å¹¶å‘ç”¨æˆ·è¾ƒå¤šï¼Œå»ºè®®ç›‘æ§ç³»ç»Ÿæ€§èƒ½è¡¨ç°')
      }
    }

    const criticalAlerts = this.getAlerts({ level: 'critical', acknowledged: false })
    if (criticalAlerts.length > 0) {
      suggestions.push(`è¯·ç«‹å³å¤„ç† ${criticalAlerts.length} ä¸ªä¸¥é‡è­¦æŠ¥`)
    }

    if (suggestions.length === 0) {
      suggestions.push('ç³»ç»Ÿè¿è¡ŒçŠ¶å†µè‰¯å¥½ï¼Œç»§ç»­ä¿æŒ')
    }

    return suggestions
  }
}
```

### 6.3 ä¼ä¸šçº§é…ç½®ç®¡ç†

```typescript
// tools/enterprise/config-manager.ts
export interface EnterpriseConfig {
  system: {
    name: string
    version: string
    environment: 'development' | 'staging' | 'production'
    logLevel: 'debug' | 'info' | 'warn' | 'error'
    enableMetrics: boolean
    enableAuditLog: boolean
  }
  
  generator: {
    defaultFramework: string
    enableIncrementalGeneration: boolean
    enableTransactions: boolean
    cacheSize: number
    maxConcurrentGenerations: number
    outputDirectory: string
  }
  
  security: {
    sessionTimeout: number
    maxLoginAttempts: number
    passwordPolicy: {
      minLength: number
      requireUppercase: boolean
      requireNumbers: boolean
      requireSpecialChars: boolean
    }
    enableTwoFactor: boolean
    allowedOrigins: string[]
  }
  
  monitoring: {
    metricsInterval: number
    alertThresholds: {
      memoryUsage: number
      cpuUsage: number
      diskUsage: number
    }
    retentionPeriod: number
    enableEmailAlerts: boolean
    emailSettings?: {
      smtp: {
        host: string
        port: number
        secure: boolean
        auth: {
          user: string
          pass: string
        }
      }
      from: string
      to: string[]
    }
  }
  
  integrations: {
    git: {
      enabled: boolean
      autoCommit: boolean
      commitMessage: string
      branch: string
    }
    ci: {
      enabled: boolean
      triggerBuild: boolean
      webhook?: string
    }
    teams: {
      enabled: boolean
      webhook?: string
      channels: {
        alerts: string
        deployments: string
      }
    }
  }
}

export class EnterpriseConfigManager {
  private config: EnterpriseConfig
  private configPath: string
  private watchers: Array<(config: EnterpriseConfig) => void> = []

  constructor(configPath: string = 'enterprise.config.json') {
    this.configPath = configPath
    this.config = this.getDefaultConfig()
    this.loadConfig()
  }

  private getDefaultConfig(): EnterpriseConfig {
    return {
      system: {
        name: 'Enterprise Modular Generator',
        version: '2.0.0',
        environment: 'development',
        logLevel: 'info',
        enableMetrics: true,
        enableAuditLog: true
      },
      
      generator: {
        defaultFramework: 'vue',
        enableIncrementalGeneration: true,
        enableTransactions: true,
        cacheSize: 1000,
        maxConcurrentGenerations: 3,
        outputDirectory: 'src/appshell'
      },
      
      security: {
        sessionTimeout: 86400000, // 24å°æ—¶
        maxLoginAttempts: 5,
        passwordPolicy: {
          minLength: 8,
          requireUppercase: true,
          requireNumbers: true,
          requireSpecialChars: true
        },
        enableTwoFactor: false,
        allowedOrigins: ['http://localhost:3000', 'http://localhost:3001']
      },
      
      monitoring: {
        metricsInterval: 30000, // 30ç§’
        alertThresholds: {
          memoryUsage: 85,
          cpuUsage: 80,
          diskUsage: 90
        },
        retentionPeriod: 7 * 24 * 60 * 60 * 1000, // 7å¤©
        enableEmailAlerts: false
      },
      
      integrations: {
        git: {
          enabled: false,
          autoCommit: false,
          commitMessage: 'feat: auto-generated code update',
          branch: 'main'
        },
        ci: {
          enabled: false,
          triggerBuild: false
        },
        teams: {
          enabled: false,
          channels: {
            alerts: '',
            deployments: ''
          }
        }
      }
    }
  }

  private async loadConfig(): Promise<void> {
    try {
      const fs = require('fs').promises
      const configContent = await fs.readFile(this.configPath, 'utf-8')
      const loadedConfig = JSON.parse(configContent)
      
      // åˆå¹¶é…ç½®ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€çš„å­—æ®µéƒ½å­˜åœ¨
      this.config = this.mergeConfigs(this.config, loadedConfig)
    } catch (error) {
      // é…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ— æ•ˆï¼Œä½¿ç”¨é»˜è®¤é…ç½®
      console.warn('ä½¿ç”¨é»˜è®¤é…ç½®ï¼Œé…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ— æ•ˆ:', error.message)
      await this.saveConfig()
    }
  }

  private mergeConfigs(defaultConfig: any, userConfig: any): any {
    const merged = { ...defaultConfig }
    
    for (const key in userConfig) {
      if (typeof userConfig[key] === 'object' && !Array.isArray(userConfig[key])) {
        merged[key] = this.mergeConfigs(defaultConfig[key] || {}, userConfig[key])
      } else {
        merged[key] = userConfig[key]
      }
    }
    
    return merged
  }

  async saveConfig(): Promise<void> {
    try {
      const fs = require('fs').promises
      await fs.writeFile(this.configPath, JSON.stringify(this.config, null, 2), 'utf-8')
    } catch (error) {
      throw new Error(`ä¿å­˜é…ç½®å¤±è´¥: ${error.message}`)
    }
  }

  getConfig(): EnterpriseConfig {
    return { ...this.config }
  }

  async updateConfig(updates: Partial<EnterpriseConfig>): Promise<void> {
    this.config = this.mergeConfigs(this.config, updates)
    await this.saveConfig()
    
    // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
    this.watchers.forEach(watcher => watcher(this.config))
  }

  // è·å–ç‰¹å®šé…ç½®èŠ‚
  getSystemConfig() {
    return this.config.system
  }

  getGeneratorConfig() {
    return this.config.generator
  }

  getSecurityConfig() {
    return this.config.security
  }

  getMonitoringConfig() {
    return this.config.monitoring
  }

  getIntegrationsConfig() {
    return this.config.integrations
  }

  // é…ç½®éªŒè¯
  validateConfig(): { isValid: boolean, errors: string[] } {
    const errors: string[] = []

    // éªŒè¯ç³»ç»Ÿé…ç½®
    if (!this.config.system.name) {
      errors.push('ç³»ç»Ÿåç§°ä¸èƒ½ä¸ºç©º')
    }

    if (!['development', 'staging', 'production'].includes(this.config.system.environment)) {
      errors.push('æ— æ•ˆçš„ç¯å¢ƒé…ç½®')
    }

    // éªŒè¯ç”Ÿæˆå™¨é…ç½®
    if (this.config.generator.cacheSize < 100) {
      errors.push('ç¼“å­˜å¤§å°ä¸èƒ½å°äº100')
    }

    if (this.config.generator.maxConcurrentGenerations < 1) {
      errors.push('æœ€å¤§å¹¶å‘ç”Ÿæˆæ•°ä¸èƒ½å°äº1')
    }

    // éªŒè¯å®‰å…¨é…ç½®
    if (this.config.security.sessionTimeout < 60000) {
      errors.push('ä¼šè¯è¶…æ—¶æ—¶é—´ä¸èƒ½å°äº1åˆ†é’Ÿ')
    }

    if (this.config.security.passwordPolicy.minLength < 6) {
      errors.push('å¯†ç æœ€å°é•¿åº¦ä¸èƒ½å°äº6ä½')
    }

    // éªŒè¯ç›‘æ§é…ç½®
    if (this.config.monitoring.metricsInterval < 5000) {
      errors.push('æŒ‡æ ‡æ”¶é›†é—´éš”ä¸èƒ½å°äº5ç§’')
    }

    return {
      isValid: errors.length === 0,
      errors
    }
  }

  // é…ç½®ç›‘å¬
  onConfigChange(callback: (config: EnterpriseConfig) => void): void {
    this.watchers.push(callback)
  }

  removeConfigWatcher(callback: (config: EnterpriseConfig) => void): void {
    const index = this.watchers.indexOf(callback)
    if (index > -1) {
      this.watchers.splice(index, 1)
    }
  }

  // é‡ç½®ä¸ºé»˜è®¤é…ç½®
  async resetToDefault(): Promise<void> {
    this.config = this.getDefaultConfig()
    await this.saveConfig()
    this.watchers.forEach(watcher => watcher(this.config))
  }

  // å¯¼å‡ºé…ç½®
  exportConfig(): string {
    return JSON.stringify(this.config, null, 2)
  }

  // å¯¼å…¥é…ç½®
  async importConfig(configJson: string): Promise<void> {
    try {
      const importedConfig = JSON.parse(configJson)
      const validation = this.validateImportedConfig(importedConfig)
      
      if (!validation.isValid) {
        throw new Error(`é…ç½®éªŒè¯å¤±è´¥: ${validation.errors.join(', ')}`)
      }
      
      await this.updateConfig(importedConfig)
    } catch (error) {
      throw new Error(`å¯¼å…¥é…ç½®å¤±è´¥: ${error.message}`)
    }
  }

  private validateImportedConfig(config: any): { isValid: boolean, errors: string[] } {
    // å®ç°é…ç½®ç»“æ„éªŒè¯é€»è¾‘
    return { isValid: true, errors: [] }
  }

  // è·å–ç¯å¢ƒç‰¹å®šé…ç½®
  getEnvironmentConfig(): Partial<EnterpriseConfig> {
    const env = this.config.system.environment
    
    switch (env) {
      case 'development':
        return {
          system: { logLevel: 'debug' },
          generator: { enableIncrementalGeneration: true },
          monitoring: { metricsInterval: 10000 }
        }
      
      case 'staging':
        return {
          system: { logLevel: 'info' },
          monitoring: { enableEmailAlerts: true }
        }
      
      case 'production':
        return {
          system: { logLevel: 'warn' },
          security: { enableTwoFactor: true },
          monitoring: { 
            enableEmailAlerts: true,
            retentionPeriod: 30 * 24 * 60 * 60 * 1000 // 30å¤©
          }
        }
      
      default:
        return {}
    }
  }

  // åº”ç”¨ç¯å¢ƒç‰¹å®šé…ç½®
  async applyEnvironmentConfig(): Promise<void> {
    const envConfig = this.getEnvironmentConfig()
    await this.updateConfig(envConfig)
  }
}
```

## ğŸ¯ æ€»ç»“

é€šè¿‡P0ã€P1ã€P2ä¸‰ä¸ªé˜¶æ®µçš„é‡æ„ï¼Œæˆ‘ä»¬æˆåŠŸå°†åŸæœ‰çš„åŸºç¡€ä½ä»£ç æ–¹æ¡ˆå‡çº§ä¸ºä¼ä¸šçº§ã€é«˜å¯é æ€§ã€é«˜æ€§èƒ½çš„ä»£ç ç”Ÿæˆå¹³å°ï¼š

### âœ… **P0 ç«‹å³ä¿®å¤**
- äº‹åŠ¡æ€§ç”Ÿæˆå’ŒåŸå­å›æ»šæœºåˆ¶
- æ™ºèƒ½å¢é‡æ›´æ–°ç®—æ³•  
- å¸ƒéš†è¿‡æ»¤å™¨å†²çªæ£€æµ‹ä¼˜åŒ–

### âš¡ **P1 çŸ­æœŸæ”¹è¿›**
- ç­–ç•¥æ¨¡å¼è§£è€¦ï¼Œæ’ä»¶åŒ–æ¶æ„
- å®æ—¶å†…å­˜ç›‘æ§å’Œæ™ºèƒ½ç®¡ç†
- ä¼ä¸šçº§é”™è¯¯å¤„ç†å’Œå®¡è®¡æ—¥å¿—

### ğŸš€ **P2 ä¸­æœŸæ¼”è¿›**
- å¯è§†åŒ–é…ç½®ç•Œé¢å’Œæ‹–æ‹½è®¾è®¡å™¨
- å¤šå‰ç«¯æ¡†æ¶æ”¯æŒï¼ˆVue/React/Angularï¼‰
- ä¼ä¸šçº§ç®¡ç†æ§åˆ¶å°å’Œæƒé™ä½“ç³»

### ğŸ† **æœ€ç»ˆæˆæœ**
- **ä¼ä¸šçº§å¯é æ€§**ï¼šäº‹åŠ¡æ€§æ“ä½œã€è‡ªåŠ¨å›æ»šã€å¥åº·æ£€æŸ¥
- **å¾®ç§’çº§æ€§èƒ½**ï¼šå¸ƒéš†è¿‡æ»¤å™¨ã€å¢é‡æ›´æ–°ã€æ™ºèƒ½ç¼“å­˜
- **æ’ä»¶åŒ–æ‰©å±•**ï¼šç­–ç•¥æ¨¡å¼ã€å¤šæ¡†æ¶æ”¯æŒã€ç»„ä»¶åŒ–æ¶æ„
- **å¯è§†åŒ–æ“ä½œ**ï¼šæ‹–æ‹½è®¾è®¡å™¨ã€å®æ—¶é¢„è§ˆã€ä¾èµ–å…³ç³»å›¾
- **å®Œæ•´ç›‘æ§ä½“ç³»**ï¼šå†…å­˜ç›‘æ§ã€æ€§èƒ½åˆ†æã€å®¡è®¡æ—¥å¿—
- **ä¼ä¸šçº§ç®¡ç†**ï¼šRBACæƒé™ã€é…ç½®ç®¡ç†ã€å‘Šè­¦ç³»ç»Ÿ

è¯¥é‡æ„æ–¹æ¡ˆå°†ä½ä»£ç å¹³å°çš„æŠ€æœ¯æ°´å¹³æå‡åˆ°äº†ä¼ä¸šçº§æ ‡å‡†ï¼Œå¯ä»¥æ”¯æ’‘å¤§å‹å›¢é˜Ÿçš„å¤æ‚ä¸šåŠ¡éœ€æ±‚ã€‚
