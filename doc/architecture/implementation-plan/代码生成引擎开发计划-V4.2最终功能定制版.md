# 代码生成第一步：“新建模块”

#### 核心原则

1. 三分钟原则: 核心目标是让开发者在三分钟内，通过最少的、最直观的配置，创建一个功能完整、立即可用的新模块。
2. 隐藏复杂性: 90%的场景下，用户只需要关心模块叫什么。高级配置（如数据库连接）必须默认折叠，绝不能成为用户的入门障碍。
3. 配置即生产: 界面上的每一个选项，都必须直接映射到后端，成为可部署、可运行的生产环境配置，绝不允许出现“生成后再手动修改”的情况。

---

#### “新建模块”界面与功能点详细分解 (V4.2 终版)

| 界面组件                | 对应元数据字段                    | 示例与选项              | 校验规则与默认值        | 企业级设计思想与前后端实现细则                                                                                                                                                                                                                                                                                                                                                             |
| :---------------------- | :-------------------------------- | :---------------------- | :---------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 输入框 (系统名称)       | systemName                        | SmartConstruction       | 必填, 帕斯卡命名法      | 思想: 决定根命名空间和解决方案文件夹。`<br>`实现: 后端生成器用此字段创建 src/SmartConstruction.{ModuleName}.xxx 的项目路径。                                                                                                                                                                                                                                                             |
| 输入框 (模块名称)       | name                              | ProjectManagement       | 必填, 帕斯卡命名法      | 思想: 模块的技术ID。`<br>`实现: 用于生成 ProjectManagementDomainModule 等类名。                                                                                                                                                                                                                                                                                                          |
| 输入框 (显示名称)       | displayName                       | 项目管理                | 必填                    | 思想: 面向用户的名称。`<br>`实现: 后端: 写入生成的 Localization 资源文件。前端: 为菜单和页面标题提供显示文本。                                                                                                                                                                                                                                                                           |
| ElTreeSelect (父级菜单) | frontend.parentId                 | (通过API加载的树形菜单) | 可选, 默认为根          | 思想: 绝对禁止用户手填ID。所见即所得。`<br>`实现: `<br>`1. 后端: 新增一个API (/api/sys/menus/tree)，返回当前系统所有菜单的树形结构数据。 `<br>`2. 前端: ModuleWizardView.vue 调用此API，将数据绑定到 ElTreeSelect 组件，用户提交的是所选节点的ID。                                                                                                                                   |
| 单选框组 (架构模式)     | architecturePattern               | Crud (默认), DDD(置灰)  | 必选, 默认 Crud         | 思想: 核心技术选型。`<br>`实现: 后端 CodeGenerationAppService 根据此字段路由到不同的 IArchitectureGenerator 实现。                                                                                                                                                                                                                                                                       |
| 输入框 (前端路由前缀)   | frontend.routePrefix              | /project-mgr            | 必填, /开头, kebab-case | 思想: 定义前端路由的命名空间，避免冲突。`<br>`实现: 前端生成器用此字段生成 router.ts (path: 'project-mgr') 和API请求的BaseURL。                                                                                                                                                                                                                                                          |
| 折叠面板 (高级)         | (UI状态)                          | 默认折叠                |                         | 思想: 隐藏复杂性。90%的用户不需要关心这些。                                                                                                                                                                                                                                                                                                                                                |
| L 下拉框 (数据库连接)   | databaseInfo.connectionStringName | Default (默认)          | 必选, 默认 Default      | 思想: 必须关联真实配置。`<br>`实现: `<br>`1. 后端: CodeGenerationAppService 提供一个API，读取 appsettings.json 中的 ConnectionStrings 节点，返回所有可用的连接字符串名称列表。`<br>`2. 前端: 下拉框选项由API动态填充。`<br>`3. 后端: 生成器在 *Module.cs 中配置 AbpDbConnectionOptions，将模块与连接字符串绑定。同时必须在 DbMigrator 项目中为新模块的迁移器注册正确的连接字符串。 |
| L 输入框 (数据库Schema) | databaseInfo.schema               | sm_project              | 必填, 小写+下划线       | 思想: 数据表隔离。`<br>`实现: 后端生成器在EF Core配置中为每个实体调用 .ToTable("TableName", "sm_project")。                                                                                                                                                                                                                                                                              |
| L 开关 (生成移动端页面) | generateMobilePages               | 是/否                   | 默认 否                 | 思想: 为未来多端支持预留架构扩展点。`<br>`实现: `<br>`- 此布尔值存入元数据。`<br>`- 当前阶段，所有生成器都将忽略此选项。                                                                                                                                                                                                                                                             |

---

# 代码生成第二步：领域建模

### 第二步: 领域建模 (Domain Modeling) - V4.2终版技术实现方案

#### 核心原则

1. 契约先行 (Contract First): 先定义健壮的、无歧义的元数据模型，再谈实现。
2. 数据驱动视图 (Data Drives View): 前端画布只是后端元数据的可视化镜像，所有操作的最终结果都是修改元数据，再由元数据变更来驱动UI刷新。
3. 后端负责复杂性 (Backend Handles Complexity): 所有关于关系、外键、删除行为的复杂逻辑，都在后端生成器中处理，前端只负责收集用户的选择。

---

#### 第一阶段：后端契约补全 (最高优先级)

- 🎯 目标: 彻底重构 EntityRelationshipDto，使其能够完整、精确地描述企业级应用中的所有实体关系。
- 📝 任务:

1. 修改 Dtos.cs:

- 为 EntityRelationshipDto 新增以下字段：
- public bool IsForeignKeyRequired { get; set; } = true;
- public DeleteBehavior OnDeleteBehavior { get; set; } = DeleteBehavior.Cascade; (需要为此创建一个 DeleteBehavior 枚举)
- public EnhancedEntityModelDto JoinEntity { get; set; } (用于多对多)

1. 同步 types.ts: 在前端TypeScript接口中，1:1地添加上述所有新字段和枚举。

- ✅ 验收标准: 新的 EntityRelationshipDto 和 EntityRelationship (TS) 结构，必须能完整表达“一对多”和“多对多”关系中的外键可空性、删除行为和（可选的）中间表定义。

---

#### 第二阶段：后端生成器升级 (核心任务)

- 🎯 目标: 让后端的代码生成器能够完全理解并精确实现新的 EntityRelationshipDto 契约。
- 📝 DomainGenerator (实体生成器) 升级任务:

1. 生成导航属性:

- 当处理一个实体（如 Project）时，遍历所有以它为源的关系。
- 对于“一对多”关系 (to Task)，生成 public virtual ICollection `<Task>` Tasks { get; set; }。
- 对于“多对一”关系 (to User)，生成 public virtual User User { get; set; }。

1. 生成外键属性:

- 当处理一个实体（如 Task）时，遍历所有以它为目标的“多对一”关系。
- 根据 IsForeignKeyRequired 字段，生成 public Guid ProjectId { get; set; } 或 public Guid? ProjectId { get; set; }。
- 📝 EntityFrameworkCoreGenerator (EF配置生成器) 升级任务:

1. 生成关系配置:

- 在生成实体配置时（如 TaskConfiguration），查找相关的 EntityRelationshipDto。
- 使用Roslyn，精确生成如下Fluent API代码：

  csharp

  builder.HasOne(t => t.Project)

  .WithMany(p => p.Tasks)

  .HasForeignKey(t => t.ProjectId)

  .IsRequired(metadata.IsForeignKeyRequired) // 动态设置

  .OnDelete(DeleteBehavior.Cascade); // 动态设置

1. 生成多对多关系配置:

- 当检测到关系类型为 ManyToMany 时：
- 首先，调用 DomainGenerator 生成中间实体（如 ProjectMember.cs）。
- 然后，在EF配置中，生成使用 HasMany...WithMany...UsingEntity 的复杂配置，正确指定左右键。
- ✅ 验收标准:
- 生成的实体 .cs 文件中，必须包含正确的导航属性和外键属性（包括可空性）。
- 生成的 *Configuration.cs 文件中，必须包含与元数据完全匹配的 HasOne/WithMany 或 HasMany/WithMany 配置，特别是 IsRequired 和 OnDelete 的设置。

---

# 代码生成第三步：权限设置

### （最终修正版）第三步: 功能与权限设计

🎯 核心架构原则: 权限的系统名称 (System Name) 必须是稳定的、唯一的、与UI显示解耦的。它由系统生成和管理，绝不能被用户的界面操作间接污染。

👨‍💻 全新用户体验: 界面和交互流程将进行重构，以严格执行上述架构原则。

#### 第一部分: 标准功能配置 (Standard Features)

此部分保持不变，因为它天然符合“约定优于配置”的原则。系统将为标准CRUD操作，自动生成稳定的、符合新命名规范的权限。

- 例如：启用“创建”功能，系统后台自动生成 ProjectManagement.Project.Create 权限。

---

#### 第二部分: 扩展功能配置 (Extended Features) - 【已按指令重构】

此部分将彻底重构，以消除致命漏洞。

重构后的界面设计:

\> [ + 添加自定义操作 ]

点击后，弹出的对话框将变为：

| 字段                          | UI组件              | 示例                              | 架构设计与说明                                                                                                                            |
| :---------------------------- | :------------------ | :-------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------- |
| 操作 (Action)                 | 下拉选择框 (Select) | Approve                           | 【核心修正】 不再是文本输入框！选项为系统预定义的、安全的英文动词（如Approve, Reject, Publish, Assign）。这保证了操作名的稳定性和规范性。 |
| 关联实体 (Entity)             | 下拉选择框 (Select) | Project                           | 自动列出本模块已定义的所有实体。                                                                                                          |
| 显示名称 (Display Name)       | 文本输入框 (Input)  | 审核项目                          | 用户可以自由输入，用于UI显示和管理员后台的权限列表。此项与系统权限名完全解耦。                                                            |
| 权限预览 (Permission Preview) | (只读文本)          | ProjectManagement.Project.Approve | 【核心修正】 根据前两项的选择，自动、实时、只读地显示最终生成的、稳定的权限系统名称。用户无法修改，只能预览。                             |

---

### 重构后的元数据与生成器逻辑

| 技术环节                   | 【按指令重构】 的实现方案                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| :------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 元数据模型 (PermissionDto) | 元数据中将包含以下字段，完全遵循您的指令：`<br>` - string ActionKey (存储选择的操作，如 "Approve")`<br>` - string EntityName (存储关联的实体名，如 "Project")`<br>` - string DisplayName (存储UI显示名，如 "审核项目")`<br>` 绝不存储最终拼接的权限字符串！                                                                                                                                                                                                                                                                                                                                                                                   |
| 后端生成器: 权限类         | ApplicationContractsGenerator 将读取元数据，并生成强类型的权限常量类：`<br>` ``csharp <br> // SmartAbp.ProjectManagement.Application.Contracts/Permissions/ProjectManagementPermissions.cs <br> public static class ProjectManagementPermissions <br> { <br> public const string GroupName = "ProjectManagement"; <br> <br> // Standard Permissions <br> public const string ProjectCreate = "ProjectManagement.Project.Create"; <br> public const string ProjectUpdate = "ProjectManagement.Project.Update"; <br> <br> // Custom Permissions from UI <br> public const string ProjectApprove = "ProjectManagement.Project.Approve"; <br> } <br> `` |
| 后端生成器: API授权        | ApplicationGenerator 在生成 AppService 时，必须引用上述强类型常量：`<br>` ``csharp <br> // ...AppService.cs <br> [Authorize(ProjectManagementPermissions.ProjectApprove)] // 正确！类型安全，可重构！ <br> public virtual async Task ApproveAsync(Guid id) <br> { <br> // ... <br> } <br> `` `<br>` 绝不使用 "ProjectManagement.Project.Approve" 这样的魔法字符串。                                                                                                                                                                                                                                                                               |

---

D爷，这，才是一个真正坚如磐石、无可指摘的企业级架构方案

# 代码生成第四步：智能生成默认UI和全栈代码

直接生成前后端所有代码，并能够在主菜单真实访问。


* **后台实现 (总编排)**: `CodeGenerationAppService` 将严格执行：

1. **后端代码生成** (Roslyn)
2. **后端项目集成** (Microsoft.Build.Construction)
3. **自动化数据库迁移** (`dotnet ef` CLI)
4. **前端代码生成** (TypeScript Compiler API)
5. **前端自动集成** (TypeScript Compiler API)

### （全新）第四步: 智能生成默认UI (Intelligent Default UI Generation)

🎯 核心目标: 这是一个完全自动化、零配置的步骤。它的唯一使命，就是扮演一个拥有20年经验的“企业级UI架构师”，在接收到前三步的元数据后，瞬间为开发者生成一套功能完整、布局合理、交互专业的“90分”默认UI方案。

👨‍💻 用户体验: 对开发者而言，这一步是“隐形”的。他只需要在完成第三步“权限管理”后，点击“下一步”。引擎将在后台，依据我们共同制定的“企业级品味”规则，自动完成所有UI布局的计算和预设。开发者将直接进入第五步“UI设计器”，看到的就是这一步智能计算的结果。

⚙️ 引擎内置的“企业级品味”规则库 (功能要点分解):

| UI区域                               | 智能决策规则 (Intelligent Decision Rules)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 元数据产出 (Metadata Output)                                                                                                         |
| :----------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| 1. 高级查询区 (Advanced Search Area) | 1. 自动包含: 默认将所有string, DateTime, int, decimal, bool, enum 以及“多对一”外键关联字段，作为查询条件。`<br>`2. 智能排除: 自动排除 Id、长文本字段（MaxLength > 500）、审计字段（CreationTime 等）和文件字段。`<br>`3. 组件匹配: 根据数据类型，自动匹配最佳查询组件：string -> `<el-input>`, DateTime -> `<el-date-picker type="daterange">`, enum/bool -> `<el-select>`。 `<br>`4. 逻辑匹配: 根据数据类型，自动设置默认查询逻辑：string -> 模糊包含, DateTime/数值 -> 范围查询, enum/bool/外键 -> 精确等于。 | 引擎将计算结果，自动填充 EntityUIConfigDto 中的 List `<QueryFieldDto>` QueryFields 列表。                                          |
| 2. 功能操作区 (Action Bar)           | 1. 权限联动: 严格读取第三步“权限管理”的配置。只有用户启用了Create权限，[新增]按钮的元数据才会生成。[批量删除]、[导出]同理。`<br>`2. 标准布局: 表格上方默认生成 [新增]、[批量删除]、[导出] 按钮。每一行数据默认生成 [编辑]、[删除] 操作。                                                                                                                                                                                                                                                                                  | 引擎将计算结果，自动填充 EntityUIConfigDto 中的 ActionBarConfigDto ActionBar 对象，其中的布尔开关（如 EnableCreate）完全由权限决定。 |
| 3. 数据表格区 (Data Table Area)      | 1. 智能列选: 默认显示所有非Id、非长文本、非导航属性的字段。`<br>`2. 审计字段: 默认包含 CreationTime 和 LastModificationTime 列，让数据可追溯。`<br>`3. 外键显示: 对于外键字段（如ProjectId），自动显示其关联实体的Name或DisplayName，而不是枯燥的GUID。`<br>`4. 默认功能: 所有列默认可排序。表格默认集成分页功能。                                                                                                                                                                                                      | 引擎将计算结果，自动填充 EntityUIConfigDto 中的 List `<TableColumnDto>` TableColumns 列表。                                        |
| 4. 模态框表单 (Modal Form)           | 1. 字段筛选: 表单中自动包含所有可编辑的字段。自动排除Id、审计字段和集合导航属性。`<br>`2. 组件匹配: 同样根据数据类型，为每个字段匹配最佳的表单组件（`<el-input>`, `<el-date-picker>`, `<el-select>`等）。`<br>`3. 校验规则: 自动从第二步“领域建模”的元数据中，继承 IsRequired、MaxLength 等校验规则，并生成对应的表单验证配置。                                                                                                                                                                                   | 引擎将计算结果，自动填充 EntityUIConfigDto 中的 List `<FormFieldDto>` FormFields 列表。                                            |

---

### 本步骤的最终产物

这一步完成后，引擎已经在内存中，基于我们共同制定的“最佳实践”，构建了一份完整的、高质量的、描述了整个UI蓝图的配置文件——EntityUIConfigDto。

这份配置，将作为第五步“UI设计器”的初始状态。开发者在第五步看到的所有预设好的组件和布局，都来源于这份智能生成的配置。

# 代码生成第五步：UI定制

取消代码生成的第五个步骤，而是在每个UI界面添加一个“UI定制”按钮，进入UI定制模块，进行表单拖拽可视化定制开发。

**🎯 目标**: 提供一个极致的、企业级的、所见即所得的可视化页面构建体验。

**👨‍💻 用户体验**: 开发者将进入一个三栏式布局的“页面设计器”。

* **左侧**: **组件库 (Component Library)**，提供 `查询表单`、`数据表格`、`操作按钮`等预设组件。
* **中间**: **实时画布 (Live Canvas)**，实时、可交互地预览正在设计的页面。
* **右侧**: **属性检查器 (Property Inspector)**，选中画布中的任何组件，都可以在此配置其详细属性。

| 设计区域                       | 功能要点               | 交互流程                                                                                                                                                                                                                  | 元数据模型 (新增/修改)                                                                                                                                | **生成器实现**                                                                                                                                                                        |
| :----------------------------- | :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **1. 查询区域设计**      | 可视化配置高级查询条件 | 开发者从“数据源”（实体属性列表）中，**拖拽**一个字段（如 `UserName`）到画布的“查询表单”组件上。右侧属性检查器立刻显示配置项，可设置 `标签名`、`占位符`、`查询方式`（等于/包含/范围）。                  | `EnhancedEntityModelDto` 中新增: `<br>` `EntityUIConfigDto UIConfig` `<br>` `UIConfig` 中包含: `<br>` `List<QueryFieldDto> QueryFields` | **前端 (`FrontendGenerator`)**: 读取 `QueryFields`列表，在 `Index.vue` 中循环生成 `<el-form-item>`和对应的 `<el-input>`或 `<el-select>`，并自动构建查询参数对象。         |
| **2. 数据表格设计**      | 可视化配置列表的列     | 开发者从“数据源”中，**拖拽**字段到画布的“数据表格”组件上，表格**实时增加一列**。选中任意列，可在右侧配置其 `列标题`、`宽度`、`是否可排序`、`内容格式化`（如日期、金额）。                         | `UIConfig` 中包含: `<br>` `List<TableColumnDto> TableColumns`                                                                                   | **前端 (`FrontendGenerator`)**: 读取 `TableColumns`列表，在 `Index.vue` 中循环生成 `<el-table-column>`，并精确绑定 `prop`, `label`, `sortable`, `formatter`等属性。   |
| **3. 操作按钮设计**      | 配置表格行内/外的操作  | 选中“数据表格”组件，可在右侧属性检查器中，通过**开关**启用/禁用 `创建`、`编辑`、`删除`、`导出`等常用按钮，并可配置其权限（关联第三步定义的权限）。                                                        | `UIConfig` 中包含: `<br>` `ActionBarConfigDto ActionBar`                                                                                        | **前端 (`FrontendGenerator`)**: 根据 `ActionBar`的配置，生成对应的 `<el-button>`组件，并使用 `v-if`指令，结合从后端获取的用户权限信息，实现按钮的动态显示/隐藏。              |
| **4. 创建/编辑表单设计** | 可视化设计弹窗表单     | 点击“编辑表单”按钮，进入表单设计模式。开发者可以从“数据源”中**拖拽**字段到表单画布上，并通过拖拽**调整字段顺序**。右侧属性检查器可配置 `组件类型`(`Input`/`Select`/`DatePicker`)和 `校验规则`。 | `UIConfig` 中包含: `<br>` `List<FormFieldDto> FormFields`                                                                                       | **前端 (`FrontendGenerator`)**: 读取 `FormFields`列表，在 `*Modal.vue`组件中，按照顺序循环生成 `<el-form-item>`和内部组件，并自动绑定 `v-model`和从元数据中读取的校验规则。 |

# 代码生成第六步：生成与集成

#### **第六步: 生成与集成 (Generation & Integration)**

* **🎯 目标**: 接收最终的元数据，执行全栈代码的生成、集成和部署准备工作。
* **👨‍💻 用户体验**: 这是一个**后台执行**的步骤，用户看到的是一个包含详细日志的进度条。
* **⚙️ 后台实现 (总编排)**: `CodeGenerationAppService` 将严格执行：
  1. **后端代码生成** (Roslyn)
  2. **后端项目集成** (Microsoft.Build.Construction)
  3. **自动化数据库迁移** (`dotnet ef` CLI)
  4. **前端代码生成** (TypeScript Compiler API)
  5. **前端自动集成** (TypeScript Compiler API)
