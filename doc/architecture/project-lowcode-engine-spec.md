# 项目全栈低代码引擎技术架构和功能模块说明书

## 1. 概述与核心架构思想

本说明书旨在全面、系统地阐述 SmartAbp 项目现有全栈低代码引擎的技术架构与核心功能，为后续的重构和迭代提供坚实的、达成共识的基准。

**核心架构思想：混合模式驱动**

项目当前的低代码引擎在事实上已经形成了一种先进的“混合模式”架构：
*   **后端：企业级代码生成引擎**: 一个以**领域驱动设计（DDD）**为核心、基于 **Roslyn AST（抽象语法树）操作**的强大后端代码生成器。它的核心职责是根据精确的领域模型定义，生成高质量、结构良好、符合ABP vNext最佳实践的C#后端代码。
*   **前端：全栈元数据可视化设计器**: 一个以**元数据驱动**为核心、基于 **Vue3** 的可视化设计界面。它的核心职责是为开发者提供一个直观的界面，用以定义涵盖了**数据结构、关系、校验、UI布局、权限**等全链路概念的元数据模型。

**核心现状：两强并立，但连接薄弱**
我们拥有一个强大的后端和一个思想先进的前端，但连接两者的API层目前是一个**信息瓶颈**，导致前端丰富的元数据无法被后端完全理解和利用。本文将详细阐述两大引擎的现有能力，并剖析此瓶颈。

---

## 2. 后端引擎：`SmartAbp.CodeGenerator`

### 2.1. 技术架构核心
*   **核心技术**: C# .NET + **Roslyn API**。
*   **架构剖析**: 引擎的核心是 `RoslynCodeEngine`，它不采用简单的字符串模板替换，而是通过直接操作C#代码的**抽象语法树（AST）**来生成代码。这意味着它能深刻理解代码结构，智能处理`using`引用、依赖注入、异步方法、代码格式化等，确保了生成代码的**高质量和可维护性**。

### 2.2. 核心服务 (`ICodeGenerationAppService`)
引擎通过一组定义清晰的应用服务接口暴露其强大的生成能力：
*   **单一实体生成**: `GenerateEntityAsync` - 生成单个实体类的基础。
*   **DDD全域生成**: `GenerateDddDomainAsync` - 支持一次性生成聚合、值对象、领域事件、规约等完整的DDD领域层。
*   **架构模式生成**: `GenerateCqrsAsync` - 支持生成完整的CQRS架构模式代码。
*   **分层代码生成**: `GenerateApplicationServicesAsync`, `GenerateInfrastructureAsync` - 支持按层生成应用服务和基础设施代码。
*   **解决方案级生成**: `GenerateAspireSolutionAsync`, `GenerateEnterpriseSolutionAsync` - 支持生成包含微服务、缓存、消息队列、测试、遥测在内的企业级解决方案。

### 2.3. 数据输入模型 (DTOs)
引擎的“语言”是一系列在 `Dtos.cs` 中定义的C#类。
*   **已实现功能**:
    *   `EntityDefinitionDto`: 能够精确描述实体的**名称、模块、聚合关系、是否多租户/软删除**等特性。
    *   `PropertyDefinitionDto`: 能够描述属性的**名称、类型、是否必须、最大/最小长度**等。
    *   `NavigationPropertyDefinitionDto`: 能够描述**实体间的导航关系**（一对一，一对多等）。
*   **功能边界与缺陷**:
    *   当前的DTOs**完全聚焦于后端领域模型和数据结构**。
    *   **严重缺失**对以下前端概念的描述能力：**UI布局、表单分组、高级校验规则（如正则）、权限策略、菜单配置**等。

### 2.4. 总结
`SmartAbp.CodeGenerator`是一个**专业、强大、面向后端**的代码生成器。它已经达到了企业级标准，是项目的坚实后盾。其主要局限性在于它的“视野”目前仅限于后端，无法理解前端传递过来的更丰富的全栈元数据。

---

## 3. 前端引擎 (`packages` monorepo)

### 3.1. 技术架构核心
*   **核心技术**: TypeScript, Vue 3, Pinia, Element Plus, Vite，以 **Monorepo** 结构组织。
*   **架构剖析**: 前端引擎的核心思想是**“内存中的全链路元数据模型”**。所有可视化操作的最终目的，都是为了构建和维护一个名为 `EnhancedEntityModel` 的、极其丰富的TypeScript对象。同时，`lowcode-core/runtime` 和相关组件的存在，证明了系统已具备**运行时元数据加载**和**实时预览**的核心能力。

### 3.2. 核心数据模型 (`EnhancedEntityModel`)
这是前端引擎的灵魂，定义在 `packages/lowcode-designer/src/types/index.ts`。
*   **已实现功能**: `EnhancedEntityModel` 是一个远比后端DTO丰富的“超级模型”，它除了包含后端所需的所有信息外，还额外定义了：
    *   **`EntityUIConfig`**: 极其详尽的UI配置，包括**列表页的列定义、表单的布局与分组、详情页的布局（支持Tabs）**。
    *   **`EntityPermission`**: 权限配置，支持**角色级别的CRUD权限**，甚至包含**字段级的读写权限**。
    *   **`ValidationRule`**: 高级校验规则，支持**正则表达式 (`pattern`)、范围 (`range`)** 等。
    *   **`BusinessRule`**: 预留了业务规则的定义空间。

### 3.3. 核心功能模块
*   **`lowcode-designer` (可视化设计器)**:
    *   `EntityDesigner.vue`: 核心的实体设计界面，用于编辑实体及其属性。
    *   `RelationshipDesigner.vue`: 提供一个**可视化画布**，允许用户通过拖拽和连线的方式定义实体间的关系。
    *   `ValidationRuleDesigner.vue`: 用于为实体属性配置校验规则。
*   **`lowcode-core` (核心与运行时)**:
    *   提供了插件管理器、事件总线、缓存等底层能力。
    *   **`runtime` 目录**: 包含了实现**运行时元数据驱动UI**和**实时预览**的关键逻辑。
*   **`lowcode-api` (API适配层)**:
    *   作为前后端通信的桥梁。

### 3.4. 总结
前端引擎是一个**思想超前、功能强大**的全链路元数据设计器。它不仅能设计数据，更能设计UI、权限和行为。它的核心潜力在于其丰富的元数据模型和已具备的运行时能力。其主要局限性在于，这份丰富的元数据目前“走不出”前端。

---

## 4. 全栈交互与核心瓶颈

### 4.1. API 适配层 (`lowcode-api`)
*   **已实现功能**: `code-generator.ts` 文件中的 `codeGeneratorApi` 对象，通过调用 `axios` 实例与后端API进行通信。
*   **核心瓶颈：信息降级 (Information Downgrade)**:
    *   当用户在 `EntityDesigner` 中完成设计后，点击“生成”按钮，会调用 `codeGeneratorApi.generateEntity` 方法。
    *   此方法接收的参数类型是 `EntityDefinition`，其结构与后端的 `EntityDefinitionDto` 基本一致。
    *   这意味着，在调用发生之前，前端必须将内容丰富的 `EnhancedEntityModel` 对象，**“压缩”和“降级”**成一个简单的 `EntityDefinition` 对象。
    *   在这个“降级”过程中，所有关于**UI、权限、高级校验、业务规则**的宝贵元数据都**被完全丢弃了**。

### 4.2. 结论：元数据信息鸿沟
项目当前的核心瓶颈，是一个清晰的**“元数据信息鸿沟”**。
*   前端引擎能“说”一套**内容丰富的全栈语言**。
*   后端引擎能“听懂”的却只是一套**精炼的纯领域语言**。
*   连接两者的API层，扮演了一个过于严格的“翻译官”，在翻译过程中丢失了大量关键信息。

---

## 5. 总结与后续迭代方向

本说明书完整地阐述了项目低代码引擎的现状：我们拥有两个**各自领域内都非常强大**的前后端引擎，以及一套**具备运行时能力**的前端架构。

这份分析坚实地证明了**V9开发计划**的正确性。V9计划的核心，正是为了**精准地解决上述“元数据信息鸿-沟”**，其所有阶段性目标——从扩展后端DTO，到实现运行时渲染器，再到最终的实时元数据编辑器——都是为了**加宽前后端的“信息大桥”**，让前端的全栈元数据能够顺畅地流动到后端，并最终驱动整个全栈应用的生成与实时调整。
