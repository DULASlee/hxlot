# ä¼ä¸šçº§é…ç½®é©±åŠ¨å‰ç«¯æ¨¡å—åŒ–ä»£ç ç”Ÿæˆå™¨é‡æ„æ–¹æ¡ˆ

> **é‡æ„ç›®æ ‡**: å°†åŸæœ‰çš„åŸºç¡€ä½ä»£ç æ–¹æ¡ˆå‡çº§ä¸ºä¼ä¸šçº§ã€é«˜å¯é æ€§ã€é«˜æ€§èƒ½çš„ä»£ç ç”Ÿæˆå¹³å°
> 
> **æ”¹è¿›å±‚çº§**: P0ç«‹å³ä¿®å¤ â†’ P1çŸ­æœŸæ”¹è¿› â†’ P2ä¸­æœŸæ¼”è¿›
> 
> **æŠ€æœ¯æ ‡å‡†**: ä¼ä¸šçº§å¯é æ€§ã€å¾®ç§’çº§æ€§èƒ½ã€æ’ä»¶åŒ–æ‰©å±•

## ğŸ—ï¸ é‡æ„åç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                ä¼ä¸šçº§ä»£ç ç”Ÿæˆå¹³å°æ¶æ„                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å¯è§†åŒ–è®¾è®¡å™¨ â†’ æ’ä»¶åŒ–å¼•æ“ â†’ äº‹åŠ¡ç”Ÿæˆ â†’ å¢é‡æ›´æ–° â†’ ç›‘æ§è¿ç»´  â”‚
â”‚       â†“            â†“           â†“         â†“         â†“       â”‚
â”‚   UI Builder   Strategies   Transaction  Delta    Analytics â”‚
â”‚                                                             â”‚
â”‚  å¤šæ¡†æ¶æ”¯æŒ â† å†…å­˜ç®¡ç† â† å†²çªä¼˜åŒ– â† æ—¥å¿—ç³»ç»Ÿ â† ä¼ä¸šç®¡ç†      â”‚
â”‚       â†‘           â†‘          â†‘          â†‘          â†‘       â”‚
â”‚  Multi-Stack   Memory     BloomFilter   Logger   Enterprise â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ é‡æ„å®æ–½è®¡åˆ’

### ğŸ”¥ **P0 - ç«‹å³ä¿®å¤ï¼ˆé˜»å¡ä½¿ç”¨ï¼‰**
- âœ… äº‹åŠ¡æ€§ç”Ÿæˆå’ŒåŸå­å›æ»šæœºåˆ¶
- âœ… æ™ºèƒ½å¢é‡æ›´æ–°ç®—æ³•
- âœ… å¸ƒéš†è¿‡æ»¤å™¨å†²çªæ£€æµ‹ä¼˜åŒ–

### âš¡ **P1 - çŸ­æœŸæ”¹è¿›ï¼ˆ1-2ä¸ªæœˆï¼‰**  
- âœ… ç­–ç•¥æ¨¡å¼è§£è€¦ï¼Œæ’ä»¶åŒ–æ¶æ„
- âœ… å®æ—¶å†…å­˜ç›‘æ§å’Œæ™ºèƒ½ç®¡ç†
- âœ… ä¼ä¸šçº§é”™è¯¯å¤„ç†å’Œå®¡è®¡æ—¥å¿—

### ğŸš€ **P2 - ä¸­æœŸæ¼”è¿›ï¼ˆ3-6ä¸ªæœˆï¼‰**
- âœ… å¯è§†åŒ–é…ç½®ç•Œé¢å’Œæ‹–æ‹½è®¾è®¡å™¨
- âœ… å¤šå‰ç«¯æ¡†æ¶æ”¯æŒï¼ˆVue/React/Angularï¼‰
- âœ… ä¼ä¸šçº§ç®¡ç†æ§åˆ¶å°å’Œæƒé™ä½“ç³»

---

## Step 1: ä¼ä¸šçº§é¡¹ç›®åˆå§‹åŒ–

### 1.1 å¢å¼ºçš„é¡¹ç›®ç»“æ„

```bash
mkdir enterprise-modular-generator
cd enterprise-modular-generator
```

### 1.2 ä¼ä¸šçº§ package.json

```json
{
  "name": "@enterprise/modular-generator",
  "version": "2.0.0",
  "private": false,
  "type": "module",
  "scripts": {
    "dev": "npm run gen && vite",
    "dev:watch": "concurrently \"npm run gen:watch\" \"npm run monitor\" \"vite\"",
    "build": "npm run gen && npm run test:coverage && vite build",
    "preview": "vite preview",
    "gen": "tsx tools/generator/cli.ts",
    "gen:watch": "tsx tools/generator/cli.ts --watch",
    "gen:check": "tsx tools/generator/cli.ts --check",
    "gen:rollback": "tsx tools/generator/cli.ts --rollback",
    "module:create": "tsx tools/generator/cli.ts create-module",
    "module:visual": "tsx tools/visual-designer/server.ts",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "type-check": "tsc --noEmit",
    "monitor": "tsx tools/monitoring/dashboard.ts",
    "analyze": "tsx tools/analyzer/performance.ts",
    "enterprise:setup": "tsx tools/enterprise/setup.ts"
  },
  "dependencies": {
    "pinia": "^2.2.0",
    "vue": "^3.4.0",
    "vue-router": "^4.4.0",
    "react": "^18.2.0",
    "react-router-dom": "^6.8.0",
    "@angular/core": "^17.0.0",
    "@angular/router": "^17.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@vitejs/plugin-vue": "^5.0.0",
    "@vitejs/plugin-react": "^4.2.0",
    "chalk": "^5.3.0",
    "chokidar": "^3.6.0",
    "concurrently": "^8.2.0",
    "inquirer": "^9.2.0",
    "tsx": "^4.7.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "vitest": "^1.0.0",
    "zod": "^3.22.0",
    "bloom-filters": "^3.0.1",
    "lodash": "^4.17.21",
    "express": "^4.18.2",
    "ws": "^8.16.0",
    "pino": "^8.17.0",
    "pino-pretty": "^10.3.0",
    "@prometheus-io/client": "^1.1.0"
  }
}
```

---

## Step 2: P0æ ¸å¿ƒå¼•æ“é‡æ„ - ç«‹å³ä¿®å¤

### 2.1 äº‹åŠ¡æ€§Schemaå®šä¹‰å’ŒéªŒè¯

```typescript
// tools/generator/enhanced-schema.ts
import { z } from 'zod'
import { createHash } from 'crypto'

// å¢å¼ºçš„è·¯ç”±é…ç½®Schema
export const EnhancedRouteSchema = z.object({
  name: z.string().min(1).regex(/^[A-Z][a-zA-Z0-9]+$/),
  path: z.string().startsWith('/'),
  component: z.string().startsWith('@/'),
  framework: z.enum(['vue', 'react', 'angular']).default('vue'),
  meta: z.object({
    title: z.string().optional(),
    icon: z.string().optional(),
    policy: z.string().optional(),
    keepAlive: z.boolean().optional(),
    hidden: z.boolean().optional(),
    lazyLoad: z.boolean().default(true),
    preload: z.boolean().default(false)
  }).optional(),
  dependencies: z.array(z.string()).default([]),
  cacheStrategy: z.enum(['memory', 'disk', 'none']).default('memory')
})

// ç‰ˆæœ¬åŒ–Storeé…ç½®Schema
export const EnhancedStoreSchema = z.object({
  symbol: z.string().regex(/^use[A-Z]\w+Store$/),
  id: z.string().min(1).regex(/^[a-z][a-z0-9-]*$/),
  modulePath: z.string().startsWith('@/'),
  framework: z.enum(['vue', 'react', 'angular']).default('vue'),
  stateType: z.enum(['global', 'module', 'component']).default('module'),
  persistence: z.boolean().default(false),
  version: z.string().regex(/^\d+\.\d+\.\d+$/).default('1.0.0')
})

// ä¼ä¸šçº§ç”Ÿå‘½å‘¨æœŸSchema
export const EnhancedLifecycleSchema = z.object({
  preInit: z.string().startsWith('@/').optional(),
  init: z.string().startsWith('@/').optional(),
  postInit: z.string().startsWith('@/').optional(),
  beforeMount: z.string().startsWith('@/').optional(),
  mounted: z.string().startsWith('@/').optional(),
  beforeUnmount: z.string().startsWith('@/').optional(),
  unmounted: z.string().startsWith('@/').optional(),
  errorHandler: z.string().startsWith('@/').optional(),
  performanceMonitor: z.string().startsWith('@/').optional()
})

// ä¼ä¸šçº§æƒé™ç­–ç•¥Schema
export const EnhancedPolicySchema = z.string().regex(/^[A-Z][a-zA-Z0-9]*\.[A-Z][a-zA-Z0-9]*(\.[A-Z][a-zA-Z0-9]*)?$/)

// æ¨¡å—èƒ½åŠ›å¥‘çº¦Schema
export const ModuleCapabilitySchema = z.object({
  apis: z.array(z.object({
    name: z.string(),
    endpoint: z.string(),
    method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']),
    version: z.string().regex(/^\d+\.\d+\.\d+$/)
  })).default([]),
  events: z.array(z.object({
    name: z.string(),
    payload: z.string(),
    version: z.string().regex(/^\d+\.\d+\.\d+$/)
  })).default([]),
  dependencies: z.array(z.object({
    service: z.string(),
    version: z.string(),
    required: z.boolean().default(true)
  })).default([]),
  exports: z.array(z.string()).default([]),
  imports: z.array(z.string()).default([])
})

// å®Œæ•´çš„ä¼ä¸šçº§æ¨¡å—æ¸…å•Schema
export const EnterpriseManifestSchema = z.object({
  $schema: z.string().optional(),
  name: z.string().min(1).regex(/^[A-Z][a-zA-Z0-9]+$/),
  displayName: z.string().optional(),
  description: z.string().optional(),
  version: z.string().regex(/^\d+\.\d+\.\d+$/).default('1.0.0'),
  author: z.string().optional(),
  license: z.string().default('MIT'),
  abpStyle: z.boolean().default(true),
  order: z.number().int().min(0).default(100),
  dependsOn: z.array(z.string()).default([]),
  routes: z.array(EnhancedRouteSchema).default([]),
  stores: z.array(EnhancedStoreSchema).default([]),
  policies: z.array(EnhancedPolicySchema).default([]),
  lifecycle: EnhancedLifecycleSchema.default({}),
  capabilities: ModuleCapabilitySchema.default({}),
  features: z.object({
    enableAuth: z.boolean().default(true),
    enableCache: z.boolean().default(true),
    enableI18n: z.boolean().default(true),
    enableAnalytics: z.boolean().default(false),
    enableMonitoring: z.boolean().default(true)
  }).optional(),
  frameworks: z.array(z.enum(['vue', 'react', 'angular'])).default(['vue']),
  buildTarget: z.enum(['spa', 'ssr', 'ssg', 'micro-frontend']).default('spa'),
  security: z.object({
    csp: z.string().optional(),
    permissions: z.array(z.string()).default([]),
    encryption: z.boolean().default(false)
  }).optional(),
  performance: z.object({
    bundleSize: z.number().optional(),
    loadingStrategy: z.enum(['eager', 'lazy', 'preload']).default('lazy'),
    cacheStrategy: z.enum(['memory', 'disk', 'hybrid']).default('hybrid')
  }).optional(),
  monitoring: z.object({
    enabled: z.boolean().default(true),
    metricsEndpoint: z.string().optional(),
    logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info')
  }).optional()
})

// ç”Ÿæˆæ¸…å•å“ˆå¸Œç”¨äºå¢é‡æ›´æ–°
export function generateManifestHash(manifest: EnterpriseManifest): string {
  const content = JSON.stringify(manifest, Object.keys(manifest).sort())
  return createHash('sha256').update(content).digest('hex')
}

// ç‰ˆæœ¬æ¯”è¾ƒå·¥å…·
export function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split('.').map(Number)
  const parts2 = v2.split('.').map(Number)
  
  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const part1 = parts1[i] || 0
    const part2 = parts2[i] || 0
    
    if (part1 < part2) return -1
    if (part1 > part2) return 1
  }
  
  return 0
}

export type EnterpriseManifest = z.infer<typeof EnterpriseManifestSchema>
export type EnhancedRoute = z.infer<typeof EnhancedRouteSchema>
export type EnhancedStore = z.infer<typeof EnhancedStoreSchema>
export type EnhancedLifecycle = z.infer<typeof EnhancedLifecycleSchema>
export type ModuleCapability = z.infer<typeof ModuleCapabilitySchema>
```

### 2.2 å¸ƒéš†è¿‡æ»¤å™¨ä¼˜åŒ–çš„å†²çªæ£€æµ‹

```typescript
// tools/generator/optimized-conflict-detector.ts
import { BloomFilter } from 'bloom-filters'
import { EnterpriseManifest } from './enhanced-schema'
import chalk from 'chalk'
import { createLogger } from './enterprise-logger'

const logger = createLogger('ConflictDetector')

interface ConflictReport {
  hasConflicts: boolean
  routeConflicts: ConflictItem[]
  storeConflicts: ConflictItem[]
  policyConflicts: ConflictItem[]
  dependencyConflicts: ConflictItem[]
  performance: {
    totalCheckTime: number
    bloomFilterHits: number
    exactChecks: number
  }
}

interface ConflictItem {
  type: 'route' | 'store' | 'policy' | 'dependency'
  resource: string
  conflictingModules: string[]
  severity: 'warning' | 'error' | 'critical'
  suggestion?: string
}

export class OptimizedConflictDetector {
  private routeNameFilter: BloomFilter
  private routePathFilter: BloomFilter
  private storeIdFilter: BloomFilter
  private policyFilter: BloomFilter
  
  private routeNames = new Map<string, string>()
  private routePaths = new Map<string, string>()
  private storeIds = new Map<string, string>()
  private policies = new Map<string, string>()
  
  private performance = {
    bloomFilterHits: 0,
    exactChecks: 0,
    startTime: 0
  }

  constructor() {
    // åˆå§‹åŒ–å¸ƒéš†è¿‡æ»¤å™¨ - ä¼˜åŒ–å‚æ•°
    this.routeNameFilter = new BloomFilter(10000, 0.001)
    this.routePathFilter = new BloomFilter(10000, 0.001)
    this.storeIdFilter = new BloomFilter(5000, 0.001)
    this.policyFilter = new BloomFilter(5000, 0.001)
  }

  async detect(manifests: EnterpriseManifest[]): Promise<ConflictReport> {
    this.performance.startTime = performance.now()
    logger.info(`å¼€å§‹å†²çªæ£€æµ‹ï¼Œæ¨¡å—æ•°é‡: ${manifests.length}`)

    const report: ConflictReport = {
      hasConflicts: false,
      routeConflicts: [],
      storeConflicts: [],
      policyConflicts: [],
      dependencyConflicts: [],
      performance: {
        totalCheckTime: 0,
        bloomFilterHits: 0,
        exactChecks: 0
      }
    }

    // ç¬¬ä¸€è½®ï¼šæ„å»ºå¸ƒéš†è¿‡æ»¤å™¨ç´¢å¼•
    await this.buildBloomFilterIndex(manifests)

    // ç¬¬äºŒè½®ï¼šå¿«é€Ÿå†²çªæ£€æµ‹
    for (const manifest of manifests) {
      await this.checkManifestConflicts(manifest, report)
    }

    // ç¬¬ä¸‰è½®ï¼šä¾èµ–å†²çªæ£€æµ‹
    await this.checkDependencyConflicts(manifests, report)

    // è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    const totalTime = performance.now() - this.performance.startTime
    report.performance = {
      totalCheckTime: totalTime,
      bloomFilterHits: this.performance.bloomFilterHits,
      exactChecks: this.performance.exactChecks
    }

    report.hasConflicts = report.routeConflicts.length > 0 || 
                         report.storeConflicts.length > 0 || 
                         report.policyConflicts.length > 0 ||
                         report.dependencyConflicts.length > 0

    if (report.hasConflicts) {
      logger.error('æ£€æµ‹åˆ°å†²çª', { report })
      this.logConflictReport(report)
    } else {
      logger.info('å†²çªæ£€æµ‹å®Œæˆï¼Œæ— å†²çªå‘ç°', { 
        performance: report.performance 
      })
    }

    return report
  }

  private async buildBloomFilterIndex(manifests: EnterpriseManifest[]): Promise<void> {
    logger.debug('æ„å»ºå¸ƒéš†è¿‡æ»¤å™¨ç´¢å¼•')
    
    for (const manifest of manifests) {
      // ç´¢å¼•è·¯ç”±
      for (const route of manifest.routes) {
        this.routeNameFilter.add(route.name)
        this.routePathFilter.add(this.normalizePath(route.path))
      }

      // ç´¢å¼•å­˜å‚¨
      for (const store of manifest.stores) {
        this.storeIdFilter.add(store.id)
      }

      // ç´¢å¼•ç­–ç•¥
      for (const policy of manifest.policies) {
        this.policyFilter.add(policy)
      }
    }
  }

  private async checkManifestConflicts(
    manifest: EnterpriseManifest, 
    report: ConflictReport
  ): Promise<void> {
    await Promise.all([
      this.checkRouteConflicts(manifest, report),
      this.checkStoreConflicts(manifest, report),
      this.checkPolicyConflicts(manifest, report)
    ])
  }

  private async checkRouteConflicts(
    manifest: EnterpriseManifest,
    report: ConflictReport
  ): Promise<void> {
    for (const route of manifest.routes) {
      // å¿«é€Ÿå¸ƒéš†è¿‡æ»¤å™¨æ£€æŸ¥
      if (this.routeNameFilter.has(route.name)) {
        this.performance.bloomFilterHits++
        
        // ç²¾ç¡®æ£€æŸ¥
        if (this.routeNames.has(route.name)) {
          this.performance.exactChecks++
          const conflictingModule = this.routeNames.get(route.name)!
          
          report.routeConflicts.push({
            type: 'route',
            resource: route.name,
            conflictingModules: [conflictingModule, manifest.name],
            severity: 'error',
            suggestion: `è€ƒè™‘é‡å‘½åè·¯ç”± "${route.name}" æˆ–ä½¿ç”¨æ¨¡å—å‰ç¼€`
          })
        } else {
          this.routeNames.set(route.name, manifest.name)
        }
      } else {
        this.routeNames.set(route.name, manifest.name)
      }

      // è·¯å¾„å†²çªæ£€æŸ¥
      const normalizedPath = this.normalizePath(route.path)
      if (this.routePathFilter.has(normalizedPath)) {
        this.performance.bloomFilterHits++
        
        if (this.routePaths.has(normalizedPath)) {
          this.performance.exactChecks++
          const conflictingModule = this.routePaths.get(normalizedPath)!
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯çœŸå®å†²çªï¼ˆä¸åŒæ¡†æ¶å¯èƒ½å…±äº«è·¯å¾„ï¼‰
          if (conflictingModule !== manifest.name) {
            report.routeConflicts.push({
              type: 'route',
              resource: route.path,
              conflictingModules: [conflictingModule, manifest.name],
              severity: 'warning',
              suggestion: `è·¯å¾„å†²çªå¯èƒ½å¯¼è‡´è·¯ç”±è¦†ç›–ï¼Œè¯·æ£€æŸ¥è·¯ç”±ä¼˜å…ˆçº§`
            })
          }
        } else {
          this.routePaths.set(normalizedPath, manifest.name)
        }
      } else {
        this.routePaths.set(normalizedPath, manifest.name)
      }
    }
  }

  private async checkStoreConflicts(
    manifest: EnterpriseManifest,
    report: ConflictReport
  ): Promise<void> {
    for (const store of manifest.stores) {
      if (this.storeIdFilter.has(store.id)) {
        this.performance.bloomFilterHits++
        
        if (this.storeIds.has(store.id)) {
          this.performance.exactChecks++
          const conflictingModule = this.storeIds.get(store.id)!
          
          report.storeConflicts.push({
            type: 'store',
            resource: store.id,
            conflictingModules: [conflictingModule, manifest.name],
            severity: 'critical',
            suggestion: `Store ID "${store.id}" å†²çªï¼Œå¯èƒ½å¯¼è‡´çŠ¶æ€è¦†ç›–`
          })
        } else {
          this.storeIds.set(store.id, manifest.name)
        }
      } else {
        this.storeIds.set(store.id, manifest.name)
      }
    }
  }

  private async checkPolicyConflicts(
    manifest: EnterpriseManifest,
    report: ConflictReport
  ): Promise<void> {
    for (const policy of manifest.policies) {
      if (this.policyFilter.has(policy)) {
        this.performance.bloomFilterHits++
        
        if (this.policies.has(policy)) {
          this.performance.exactChecks++
          const conflictingModule = this.policies.get(policy)!
          
          report.policyConflicts.push({
            type: 'policy',
            resource: policy,
            conflictingModules: [conflictingModule, manifest.name],
            severity: 'warning',
            suggestion: `æƒé™ç­–ç•¥é‡å¤å®šä¹‰ï¼Œå»ºè®®ç»Ÿä¸€ç®¡ç†`
          })
        } else {
          this.policies.set(policy, manifest.name)
        }
      } else {
        this.policies.set(policy, manifest.name)
      }
    }
  }

  private async checkDependencyConflicts(
    manifests: EnterpriseManifest[],
    report: ConflictReport
  ): Promise<void> {
    const moduleVersions = new Map<string, string>()
    
    for (const manifest of manifests) {
      if (moduleVersions.has(manifest.name)) {
        const existingVersion = moduleVersions.get(manifest.name)!
        if (existingVersion !== manifest.version) {
          report.dependencyConflicts.push({
            type: 'dependency',
            resource: manifest.name,
            conflictingModules: [manifest.name],
            severity: 'critical',
            suggestion: `æ¨¡å—ç‰ˆæœ¬å†²çª: ${existingVersion} vs ${manifest.version}`
          })
        }
      } else {
        moduleVersions.set(manifest.name, manifest.version)
      }
    }
  }

  private normalizePath(path: string): string {
    return path
      .replace(/:\w+/g, ':param')
      .replace(/\*/g, '*')
      .replace(/\/+$/, '')
      .toLowerCase()
  }

  private logConflictReport(report: ConflictReport): void {
    console.log(chalk.red('\nğŸš¨ å†²çªæ£€æµ‹æŠ¥å‘Š'))
    console.log(chalk.red('=' .repeat(50)))
    
    if (report.routeConflicts.length > 0) {
      console.log(chalk.red('\nğŸ“ è·¯ç”±å†²çª:'))
      report.routeConflicts.forEach(conflict => {
        console.log(chalk.red(`  âœ— ${conflict.resource}`))
        console.log(chalk.gray(`    æ¨¡å—: ${conflict.conflictingModules.join(' vs ')}`))
        if (conflict.suggestion) {
          console.log(chalk.yellow(`    å»ºè®®: ${conflict.suggestion}`))
        }
      })
    }

    if (report.storeConflicts.length > 0) {
      console.log(chalk.red('\nğŸª Storeå†²çª:'))
      report.storeConflicts.forEach(conflict => {
        console.log(chalk.red(`  âœ— ${conflict.resource}`))
        console.log(chalk.gray(`    æ¨¡å—: ${conflict.conflictingModules.join(' vs ')}`))
        if (conflict.suggestion) {
          console.log(chalk.yellow(`    å»ºè®®: ${conflict.suggestion}`))
        }
      })
    }

    console.log(chalk.blue('\nğŸ“Š æ€§èƒ½ç»Ÿè®¡:'))
    console.log(chalk.blue(`  æ£€æµ‹æ—¶é—´: ${report.performance.totalCheckTime.toFixed(2)}ms`))
    console.log(chalk.blue(`  å¸ƒéš†è¿‡æ»¤å™¨å‘½ä¸­: ${report.performance.bloomFilterHits}`))
    console.log(chalk.blue(`  ç²¾ç¡®æ£€æŸ¥æ¬¡æ•°: ${report.performance.exactChecks}`))
  }

  // æ¸…ç†èµ„æº
  dispose(): void {
    this.routeNames.clear()
    this.routePaths.clear()
    this.storeIds.clear()
    this.policies.clear()
  }
}
```

### 2.3 äº‹åŠ¡æ€§å¢é‡æ›´æ–°ç”Ÿæˆå™¨

```typescript
// tools/generator/transactional-generator.ts
import { promises as fs } from 'fs'
import path from 'path'
import { createHash } from 'crypto'
import { EnterpriseManifest, generateManifestHash } from './enhanced-schema'
import { OptimizedConflictDetector } from './optimized-conflict-detector'
import { createLogger } from './enterprise-logger'
import chalk from 'chalk'

const logger = createLogger('TransactionalGenerator')

interface GenerationTransaction {
  id: string
  timestamp: Date
  manifests: EnterpriseManifest[]
  changes: FileChange[]
  backupPath: string
  status: 'pending' | 'committed' | 'rolled-back'
}

interface FileChange {
  filePath: string
  operation: 'create' | 'update' | 'delete'
  previousContent?: string
  newContent?: string
  checksum: string
}

interface IncrementalCache {
  manifestHashes: Map<string, string>
  fileChecksums: Map<string, string>
  lastGenerationTime: Date
  generationCount: number
}

export class TransactionalIncrementalGenerator {
  private rootDir: string
  private backupDir: string
  private cacheDir: string
  private cache: IncrementalCache
  private conflictDetector: OptimizedConflictDetector
  private currentTransaction: GenerationTransaction | null = null

  constructor(rootDir: string) {
    this.rootDir = rootDir
    this.backupDir = path.join(rootDir, '.generator-backups')
    this.cacheDir = path.join(rootDir, '.generator-cache')
    this.conflictDetector = new OptimizedConflictDetector()
    
    this.cache = {
      manifestHashes: new Map(),
      fileChecksums: new Map(),
      lastGenerationTime: new Date(0),
      generationCount: 0
    }
  }

  async initialize(): Promise<void> {
    logger.info('åˆå§‹åŒ–äº‹åŠ¡æ€§å¢é‡ç”Ÿæˆå™¨')
    
    // åˆ›å»ºå¿…è¦ç›®å½•
    await fs.mkdir(this.backupDir, { recursive: true })
    await fs.mkdir(this.cacheDir, { recursive: true })
    
    // åŠ è½½ç¼“å­˜
    await this.loadCache()
    
    logger.info('ç”Ÿæˆå™¨åˆå§‹åŒ–å®Œæˆ', {
      cacheEntries: this.cache.manifestHashes.size,
      lastGeneration: this.cache.lastGenerationTime
    })
  }

  async generateWithTransaction(manifests: EnterpriseManifest[]): Promise<void> {
    const transactionId = this.generateTransactionId()
    logger.info(`å¼€å§‹äº‹åŠ¡ ${transactionId}`)

    try {
      // 1. åˆ›å»ºäº‹åŠ¡
      this.currentTransaction = await this.createTransaction(transactionId, manifests)

      // 2. å†²çªæ£€æµ‹
      const conflictReport = await this.conflictDetector.detect(manifests)
      if (conflictReport.hasConflicts) {
        throw new Error('æ£€æµ‹åˆ°æ¨¡å—å†²çªï¼Œäº‹åŠ¡ä¸­æ­¢')
      }

      // 3. å¢é‡åˆ†æ
      const incrementalPlan = await this.analyzeIncrementalChanges(manifests)
      logger.info('å¢é‡åˆ†æå®Œæˆ', {
        totalModules: manifests.length,
        changedModules: incrementalPlan.changedModules.length,
        newModules: incrementalPlan.newModules.length,
        deletedModules: incrementalPlan.deletedModules.length
      })

      // 4. åˆ›å»ºå¤‡ä»½
      await this.createBackup()

      // 5. æ‰§è¡Œå¢é‡ç”Ÿæˆ
      await this.executeIncrementalGeneration(incrementalPlan)

      // 6. éªŒè¯ç”Ÿæˆç»“æœ
      await this.validateGeneratedFiles()

      // 7. æäº¤äº‹åŠ¡
      await this.commitTransaction()

      logger.info(`äº‹åŠ¡ ${transactionId} æˆåŠŸæäº¤`)

    } catch (error) {
      logger.error(`äº‹åŠ¡ ${transactionId} å¤±è´¥`, error)
      
      if (this.currentTransaction) {
        await this.rollbackTransaction()
      }
      
      throw error
    } finally {
      this.currentTransaction = null
    }
  }

  private async createTransaction(
    id: string, 
    manifests: EnterpriseManifest[]
  ): Promise<GenerationTransaction> {
    const transaction: GenerationTransaction = {
      id,
      timestamp: new Date(),
      manifests: structuredClone(manifests),
      changes: [],
      backupPath: path.join(this.backupDir, `backup-${id}`),
      status: 'pending'
    }

    // ä¿å­˜äº‹åŠ¡ä¿¡æ¯
    const transactionFile = path.join(this.cacheDir, `transaction-${id}.json`)
    await fs.writeFile(transactionFile, JSON.stringify(transaction, null, 2))

    return transaction
  }

  private async analyzeIncrementalChanges(manifests: EnterpriseManifest[]) {
    logger.debug('åˆ†æå¢é‡å˜æ›´')
    
    const currentHashes = new Map<string, string>()
    const changedModules: string[] = []
    const newModules: string[] = []
    const deletedModules: string[] = []

    // åˆ†æå½“å‰æ¨¡å—çŠ¶æ€
    for (const manifest of manifests) {
      const currentHash = generateManifestHash(manifest)
      currentHashes.set(manifest.name, currentHash)

      const previousHash = this.cache.manifestHashes.get(manifest.name)
      
      if (!previousHash) {
        newModules.push(manifest.name)
        logger.debug(`æ–°æ¨¡å—: ${manifest.name}`)
      } else if (previousHash !== currentHash) {
        changedModules.push(manifest.name)
        logger.debug(`å˜æ›´æ¨¡å—: ${manifest.name}`)
      }
    }

    // æ£€æµ‹åˆ é™¤çš„æ¨¡å—
    for (const [moduleName] of this.cache.manifestHashes) {
      if (!currentHashes.has(moduleName)) {
        deletedModules.push(moduleName)
        logger.debug(`åˆ é™¤æ¨¡å—: ${moduleName}`)
      }
    }

    return {
      currentHashes,
      changedModules,
      newModules,
      deletedModules,
      requiresFullRegeneration: newModules.length > 0 || deletedModules.length > 0
    }
  }

  private async createBackup(): Promise<void> {
    if (!this.currentTransaction) return

    logger.debug('åˆ›å»ºå¤‡ä»½')
    
    const backupPath = this.currentTransaction.backupPath
    await fs.mkdir(backupPath, { recursive: true })

    // å¤‡ä»½é‡è¦çš„ç”Ÿæˆæ–‡ä»¶
    const criticalFiles = [
      'src/appshell/router/routes.generated.ts',
      'src/appshell/stores/stores.generated.ts',
      'src/appshell/lifecycle.generated.ts',
      'src/appshell/security/policies.generated.ts'
    ]

    for (const filePath of criticalFiles) {
      const fullPath = path.join(this.rootDir, filePath)
      
      if (await this.fileExists(fullPath)) {
        const content = await fs.readFile(fullPath, 'utf-8')
        const backupFilePath = path.join(backupPath, path.basename(filePath))
        await fs.writeFile(backupFilePath, content)
        
        logger.debug(`å¤‡ä»½æ–‡ä»¶: ${filePath}`)
      }
    }

    // å¤‡ä»½ç¼“å­˜çŠ¶æ€
    const cacheBackupPath = path.join(backupPath, 'cache.json')
    await fs.writeFile(cacheBackupPath, JSON.stringify({
      manifestHashes: Array.from(this.cache.manifestHashes.entries()),
      fileChecksums: Array.from(this.cache.fileChecksums.entries()),
      lastGenerationTime: this.cache.lastGenerationTime,
      generationCount: this.cache.generationCount
    }, null, 2))
  }

  private async executeIncrementalGeneration(incrementalPlan: any): Promise<void> {
    logger.info('æ‰§è¡Œå¢é‡ç”Ÿæˆ')

    const { changedModules, newModules, requiresFullRegeneration } = incrementalPlan

    if (requiresFullRegeneration) {
      logger.info('æ‰§è¡Œå®Œæ•´é‡æ–°ç”Ÿæˆ')
      await this.executeFullGeneration()
    } else if (changedModules.length > 0) {
      logger.info(`å¢é‡æ›´æ–° ${changedModules.length} ä¸ªæ¨¡å—`)
      await this.executePartialGeneration(changedModules)
    } else {
      logger.info('æ— å˜æ›´ï¼Œè·³è¿‡ç”Ÿæˆ')
      return
    }

    // æ›´æ–°ç¼“å­˜
    this.cache.manifestHashes = incrementalPlan.currentHashes
    this.cache.lastGenerationTime = new Date()
    this.cache.generationCount++
    
    await this.saveCache()
  }

  private async executeFullGeneration(): Promise<void> {
    if (!this.currentTransaction) return

    const manifests = this.currentTransaction.manifests

    // å¹¶è¡Œç”Ÿæˆæ‰€æœ‰æ–‡ä»¶
    await Promise.all([
      this.generateRoutes(manifests),
      this.generateStores(manifests),
      this.generateLifecycles(manifests),
      this.generatePolicies(manifests),
      this.generateModuleRegistry(manifests)
    ])
  }

  private async executePartialGeneration(changedModules: string[]): Promise<void> {
    if (!this.currentTransaction) return

    const manifests = this.currentTransaction.manifests
    const changedManifests = manifests.filter(m => changedModules.includes(m.name))

    logger.info(`éƒ¨åˆ†æ›´æ–°æ¨¡å—: ${changedModules.join(', ')}`)

    // æ™ºèƒ½éƒ¨åˆ†æ›´æ–°
    await this.updateSpecificModules(changedManifests)
  }

  private async updateSpecificModules(changedManifests: EnterpriseManifest[]): Promise<void> {
    // è¿™é‡Œå®ç°æ™ºèƒ½çš„éƒ¨åˆ†æ›´æ–°é€»è¾‘
    // åªæ›´æ–°å—å½±å“çš„ä»£ç æ®µ
    
    for (const manifest of changedManifests) {
      logger.debug(`æ›´æ–°æ¨¡å—: ${manifest.name}`)
      
      // æ›´æ–°æ¨¡å—ç‰¹å®šçš„è·¯ç”±ã€çŠ¶æ€ç­‰
      await this.updateModuleRoutes(manifest)
      await this.updateModuleStores(manifest)
      await this.updateModulePolicies(manifest)
    }
  }

  private async commitTransaction(): Promise<void> {
    if (!this.currentTransaction) return

    logger.info(`æäº¤äº‹åŠ¡ ${this.currentTransaction.id}`)
    
    this.currentTransaction.status = 'committed'
    
    // æ›´æ–°äº‹åŠ¡çŠ¶æ€
    const transactionFile = path.join(this.cacheDir, `transaction-${this.currentTransaction.id}.json`)
    await fs.writeFile(transactionFile, JSON.stringify(this.currentTransaction, null, 2))

    // æ¸…ç†æ—§å¤‡ä»½ï¼ˆä¿ç•™æœ€è¿‘5ä¸ªï¼‰
    await this.cleanupOldBackups()
  }

  private async rollbackTransaction(): Promise<void> {
    if (!this.currentTransaction) return

    logger.warn(`å›æ»šäº‹åŠ¡ ${this.currentTransaction.id}`)
    
    const backupPath = this.currentTransaction.backupPath
    
    if (await this.fileExists(backupPath)) {
      // æ¢å¤å¤‡ä»½æ–‡ä»¶
      const backupFiles = await fs.readdir(backupPath)
      
      for (const file of backupFiles) {
        if (file === 'cache.json') continue
        
        const backupFilePath = path.join(backupPath, file)
        const originalFilePath = path.join(this.rootDir, 'src/appshell', file)
        
        const backupContent = await fs.readFile(backupFilePath, 'utf-8')
        await fs.writeFile(originalFilePath, backupContent)
        
        logger.debug(`æ¢å¤æ–‡ä»¶: ${file}`)
      }

      // æ¢å¤ç¼“å­˜çŠ¶æ€
      const cacheBackupPath = path.join(backupPath, 'cache.json')
      if (await this.fileExists(cacheBackupPath)) {
        const cacheBackup = JSON.parse(await fs.readFile(cacheBackupPath, 'utf-8'))
        this.cache.manifestHashes = new Map(cacheBackup.manifestHashes)
        this.cache.fileChecksums = new Map(cacheBackup.fileChecksums)
        this.cache.lastGenerationTime = new Date(cacheBackup.lastGenerationTime)
        this.cache.generationCount = cacheBackup.generationCount
      }
    }

    this.currentTransaction.status = 'rolled-back'
    
    // æ›´æ–°äº‹åŠ¡çŠ¶æ€
    const transactionFile = path.join(this.cacheDir, `transaction-${this.currentTransaction.id}.json`)
    await fs.writeFile(transactionFile, JSON.stringify(this.currentTransaction, null, 2))
  }

  // ç”Ÿæˆæ–‡ä»¶çš„å…·ä½“å®ç°æ–¹æ³•
  private async generateRoutes(manifests: EnterpriseManifest[]): Promise<void> {
    // å®ç°è·¯ç”±ç”Ÿæˆé€»è¾‘
    logger.debug('ç”Ÿæˆè·¯ç”±æ–‡ä»¶')
    // ... å…·ä½“å®ç°
  }

  private async generateStores(manifests: EnterpriseManifest[]): Promise<void> {
    // å®ç°çŠ¶æ€ç®¡ç†ç”Ÿæˆé€»è¾‘
    logger.debug('ç”ŸæˆçŠ¶æ€ç®¡ç†æ–‡ä»¶')
    // ... å…·ä½“å®ç°
  }

  private async generateLifecycles(manifests: EnterpriseManifest[]): Promise<void> {
    // å®ç°ç”Ÿå‘½å‘¨æœŸç”Ÿæˆé€»è¾‘
    logger.debug('ç”Ÿæˆç”Ÿå‘½å‘¨æœŸæ–‡ä»¶')
    // ... å…·ä½“å®ç°
  }

  private async generatePolicies(manifests: EnterpriseManifest[]): Promise<void> {
    // å®ç°æƒé™ç­–ç•¥ç”Ÿæˆé€»è¾‘
    logger.debug('ç”Ÿæˆæƒé™ç­–ç•¥æ–‡ä»¶')
    // ... å…·ä½“å®ç°
  }

  private async generateModuleRegistry(manifests: EnterpriseManifest[]): Promise<void> {
    // ç”Ÿæˆæ¨¡å—æ³¨å†Œè¡¨
    logger.debug('ç”Ÿæˆæ¨¡å—æ³¨å†Œè¡¨')
    // ... å…·ä½“å®ç°
  }

  // å·¥å…·æ–¹æ³•
  private generateTransactionId(): string {
    return `tx-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  }

  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath)
      return true
    } catch {
      return false
    }
  }

  private async loadCache(): Promise<void> {
    const cacheFile = path.join(this.cacheDir, 'generation-cache.json')
    
    if (await this.fileExists(cacheFile)) {
      try {
        const cacheData = JSON.parse(await fs.readFile(cacheFile, 'utf-8'))
        this.cache.manifestHashes = new Map(cacheData.manifestHashes || [])
        this.cache.fileChecksums = new Map(cacheData.fileChecksums || [])
        this.cache.lastGenerationTime = new Date(cacheData.lastGenerationTime || 0)
        this.cache.generationCount = cacheData.generationCount || 0
      } catch (error) {
        logger.warn('ç¼“å­˜æ–‡ä»¶æŸåï¼Œé‡ç½®ç¼“å­˜', error)
      }
    }
  }

  private async saveCache(): Promise<void> {
    const cacheFile = path.join(this.cacheDir, 'generation-cache.json')
    
    await fs.writeFile(cacheFile, JSON.stringify({
      manifestHashes: Array.from(this.cache.manifestHashes.entries()),
      fileChecksums: Array.from(this.cache.fileChecksums.entries()),
      lastGenerationTime: this.cache.lastGenerationTime,
      generationCount: this.cache.generationCount
    }, null, 2))
  }

  private async cleanupOldBackups(): Promise<void> {
    const backupDirs = await fs.readdir(this.backupDir)
    const backupDirList = backupDirs
      .filter(dir => dir.startsWith('backup-'))
      .sort()
      .reverse()

    // ä¿ç•™æœ€è¿‘5ä¸ªå¤‡ä»½
    const backupsToDelete = backupDirList.slice(5)
    
    for (const backup of backupsToDelete) {
      const backupPath = path.join(this.backupDir, backup)
      await fs.rm(backupPath, { recursive: true, force: true })
      logger.debug(`æ¸…ç†æ—§å¤‡ä»½: ${backup}`)
    }
  }

  async dispose(): Promise<void> {
    this.conflictDetector.dispose()
    await this.saveCache()
  }
}
```

---

ç»§ç»­é˜…è¯»æ›´å¤šé‡æ„å†…å®¹...
