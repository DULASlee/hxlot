# 企业级配置驱动前端模块化代码生成器重构方案

> **重构目标**: 将原有的基础低代码方案升级为企业级、高可靠性、高性能的代码生成平台
> 
> **改进层级**: P0立即修复 → P1短期改进 → P2中期演进
> 
> **技术标准**: 企业级可靠性、微秒级性能、插件化扩展

## 🏗️ 重构后系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                企业级代码生成平台架构                        │
├─────────────────────────────────────────────────────────────┤
│  可视化设计器 → 插件化引擎 → 事务生成 → 增量更新 → 监控运维  │
│       ↓            ↓           ↓         ↓         ↓       │
│   UI Builder   Strategies   Transaction  Delta    Analytics │
│                                                             │
│  多框架支持 ← 内存管理 ← 冲突优化 ← 日志系统 ← 企业管理      │
│       ↑           ↑          ↑          ↑          ↑       │
│  Multi-Stack   Memory     BloomFilter   Logger   Enterprise │
└─────────────────────────────────────────────────────────────┘
```

## 📋 重构实施计划

### 🔥 **P0 - 立即修复（阻塞使用）**
- ✅ 事务性生成和原子回滚机制
- ✅ 智能增量更新算法
- ✅ 布隆过滤器冲突检测优化

### ⚡ **P1 - 短期改进（1-2个月）**  
- ✅ 策略模式解耦，插件化架构
- ✅ 实时内存监控和智能管理
- ✅ 企业级错误处理和审计日志

### 🚀 **P2 - 中期演进（3-6个月）**
- ✅ 可视化配置界面和拖拽设计器
- ✅ 多前端框架支持（Vue/React/Angular）
- ✅ 企业级管理控制台和权限体系

---

## Step 1: 企业级项目初始化

### 1.1 增强的项目结构

```bash
mkdir enterprise-modular-generator
cd enterprise-modular-generator
```

### 1.2 企业级 package.json

```json
{
  "name": "@enterprise/modular-generator",
  "version": "2.0.0",
  "private": false,
  "type": "module",
  "scripts": {
    "dev": "npm run gen && vite",
    "dev:watch": "concurrently \"npm run gen:watch\" \"npm run monitor\" \"vite\"",
    "build": "npm run gen && npm run test:coverage && vite build",
    "preview": "vite preview",
    "gen": "tsx tools/generator/cli.ts",
    "gen:watch": "tsx tools/generator/cli.ts --watch",
    "gen:check": "tsx tools/generator/cli.ts --check",
    "gen:rollback": "tsx tools/generator/cli.ts --rollback",
    "module:create": "tsx tools/generator/cli.ts create-module",
    "module:visual": "tsx tools/visual-designer/server.ts",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "type-check": "tsc --noEmit",
    "monitor": "tsx tools/monitoring/dashboard.ts",
    "analyze": "tsx tools/analyzer/performance.ts",
    "enterprise:setup": "tsx tools/enterprise/setup.ts"
  },
  "dependencies": {
    "pinia": "^2.2.0",
    "vue": "^3.4.0",
    "vue-router": "^4.4.0",
    "react": "^18.2.0",
    "react-router-dom": "^6.8.0",
    "@angular/core": "^17.0.0",
    "@angular/router": "^17.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@vitejs/plugin-vue": "^5.0.0",
    "@vitejs/plugin-react": "^4.2.0",
    "chalk": "^5.3.0",
    "chokidar": "^3.6.0",
    "concurrently": "^8.2.0",
    "inquirer": "^9.2.0",
    "tsx": "^4.7.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "vitest": "^1.0.0",
    "zod": "^3.22.0",
    "bloom-filters": "^3.0.1",
    "lodash": "^4.17.21",
    "express": "^4.18.2",
    "ws": "^8.16.0",
    "pino": "^8.17.0",
    "pino-pretty": "^10.3.0",
    "@prometheus-io/client": "^1.1.0"
  }
}
```

---

## Step 2: P0核心引擎重构 - 立即修复

### 2.1 事务性Schema定义和验证

```typescript
// tools/generator/enhanced-schema.ts
import { z } from 'zod'
import { createHash } from 'crypto'

// 增强的路由配置Schema
export const EnhancedRouteSchema = z.object({
  name: z.string().min(1).regex(/^[A-Z][a-zA-Z0-9]+$/),
  path: z.string().startsWith('/'),
  component: z.string().startsWith('@/'),
  framework: z.enum(['vue', 'react', 'angular']).default('vue'),
  meta: z.object({
    title: z.string().optional(),
    icon: z.string().optional(),
    policy: z.string().optional(),
    keepAlive: z.boolean().optional(),
    hidden: z.boolean().optional(),
    lazyLoad: z.boolean().default(true),
    preload: z.boolean().default(false)
  }).optional(),
  dependencies: z.array(z.string()).default([]),
  cacheStrategy: z.enum(['memory', 'disk', 'none']).default('memory')
})

// 版本化Store配置Schema
export const EnhancedStoreSchema = z.object({
  symbol: z.string().regex(/^use[A-Z]\w+Store$/),
  id: z.string().min(1).regex(/^[a-z][a-z0-9-]*$/),
  modulePath: z.string().startsWith('@/'),
  framework: z.enum(['vue', 'react', 'angular']).default('vue'),
  stateType: z.enum(['global', 'module', 'component']).default('module'),
  persistence: z.boolean().default(false),
  version: z.string().regex(/^\d+\.\d+\.\d+$/).default('1.0.0')
})

// 企业级生命周期Schema
export const EnhancedLifecycleSchema = z.object({
  preInit: z.string().startsWith('@/').optional(),
  init: z.string().startsWith('@/').optional(),
  postInit: z.string().startsWith('@/').optional(),
  beforeMount: z.string().startsWith('@/').optional(),
  mounted: z.string().startsWith('@/').optional(),
  beforeUnmount: z.string().startsWith('@/').optional(),
  unmounted: z.string().startsWith('@/').optional(),
  errorHandler: z.string().startsWith('@/').optional(),
  performanceMonitor: z.string().startsWith('@/').optional()
})

// 企业级权限策略Schema
export const EnhancedPolicySchema = z.string().regex(/^[A-Z][a-zA-Z0-9]*\.[A-Z][a-zA-Z0-9]*(\.[A-Z][a-zA-Z0-9]*)?$/)

// 模块能力契约Schema
export const ModuleCapabilitySchema = z.object({
  apis: z.array(z.object({
    name: z.string(),
    endpoint: z.string(),
    method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']),
    version: z.string().regex(/^\d+\.\d+\.\d+$/)
  })).default([]),
  events: z.array(z.object({
    name: z.string(),
    payload: z.string(),
    version: z.string().regex(/^\d+\.\d+\.\d+$/)
  })).default([]),
  dependencies: z.array(z.object({
    service: z.string(),
    version: z.string(),
    required: z.boolean().default(true)
  })).default([]),
  exports: z.array(z.string()).default([]),
  imports: z.array(z.string()).default([])
})

// 完整的企业级模块清单Schema
export const EnterpriseManifestSchema = z.object({
  $schema: z.string().optional(),
  name: z.string().min(1).regex(/^[A-Z][a-zA-Z0-9]+$/),
  displayName: z.string().optional(),
  description: z.string().optional(),
  version: z.string().regex(/^\d+\.\d+\.\d+$/).default('1.0.0'),
  author: z.string().optional(),
  license: z.string().default('MIT'),
  abpStyle: z.boolean().default(true),
  order: z.number().int().min(0).default(100),
  dependsOn: z.array(z.string()).default([]),
  routes: z.array(EnhancedRouteSchema).default([]),
  stores: z.array(EnhancedStoreSchema).default([]),
  policies: z.array(EnhancedPolicySchema).default([]),
  lifecycle: EnhancedLifecycleSchema.default({}),
  capabilities: ModuleCapabilitySchema.default({}),
  features: z.object({
    enableAuth: z.boolean().default(true),
    enableCache: z.boolean().default(true),
    enableI18n: z.boolean().default(true),
    enableAnalytics: z.boolean().default(false),
    enableMonitoring: z.boolean().default(true)
  }).optional(),
  frameworks: z.array(z.enum(['vue', 'react', 'angular'])).default(['vue']),
  buildTarget: z.enum(['spa', 'ssr', 'ssg', 'micro-frontend']).default('spa'),
  security: z.object({
    csp: z.string().optional(),
    permissions: z.array(z.string()).default([]),
    encryption: z.boolean().default(false)
  }).optional(),
  performance: z.object({
    bundleSize: z.number().optional(),
    loadingStrategy: z.enum(['eager', 'lazy', 'preload']).default('lazy'),
    cacheStrategy: z.enum(['memory', 'disk', 'hybrid']).default('hybrid')
  }).optional(),
  monitoring: z.object({
    enabled: z.boolean().default(true),
    metricsEndpoint: z.string().optional(),
    logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info')
  }).optional()
})

// 生成清单哈希用于增量更新
export function generateManifestHash(manifest: EnterpriseManifest): string {
  const content = JSON.stringify(manifest, Object.keys(manifest).sort())
  return createHash('sha256').update(content).digest('hex')
}

// 版本比较工具
export function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split('.').map(Number)
  const parts2 = v2.split('.').map(Number)
  
  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const part1 = parts1[i] || 0
    const part2 = parts2[i] || 0
    
    if (part1 < part2) return -1
    if (part1 > part2) return 1
  }
  
  return 0
}

export type EnterpriseManifest = z.infer<typeof EnterpriseManifestSchema>
export type EnhancedRoute = z.infer<typeof EnhancedRouteSchema>
export type EnhancedStore = z.infer<typeof EnhancedStoreSchema>
export type EnhancedLifecycle = z.infer<typeof EnhancedLifecycleSchema>
export type ModuleCapability = z.infer<typeof ModuleCapabilitySchema>
```

### 2.2 布隆过滤器优化的冲突检测

```typescript
// tools/generator/optimized-conflict-detector.ts
import { BloomFilter } from 'bloom-filters'
import { EnterpriseManifest } from './enhanced-schema'
import chalk from 'chalk'
import { createLogger } from './enterprise-logger'

const logger = createLogger('ConflictDetector')

interface ConflictReport {
  hasConflicts: boolean
  routeConflicts: ConflictItem[]
  storeConflicts: ConflictItem[]
  policyConflicts: ConflictItem[]
  dependencyConflicts: ConflictItem[]
  performance: {
    totalCheckTime: number
    bloomFilterHits: number
    exactChecks: number
  }
}

interface ConflictItem {
  type: 'route' | 'store' | 'policy' | 'dependency'
  resource: string
  conflictingModules: string[]
  severity: 'warning' | 'error' | 'critical'
  suggestion?: string
}

export class OptimizedConflictDetector {
  private routeNameFilter: BloomFilter
  private routePathFilter: BloomFilter
  private storeIdFilter: BloomFilter
  private policyFilter: BloomFilter
  
  private routeNames = new Map<string, string>()
  private routePaths = new Map<string, string>()
  private storeIds = new Map<string, string>()
  private policies = new Map<string, string>()
  
  private performance = {
    bloomFilterHits: 0,
    exactChecks: 0,
    startTime: 0
  }

  constructor() {
    // 初始化布隆过滤器 - 优化参数
    this.routeNameFilter = new BloomFilter(10000, 0.001)
    this.routePathFilter = new BloomFilter(10000, 0.001)
    this.storeIdFilter = new BloomFilter(5000, 0.001)
    this.policyFilter = new BloomFilter(5000, 0.001)
  }

  async detect(manifests: EnterpriseManifest[]): Promise<ConflictReport> {
    this.performance.startTime = performance.now()
    logger.info(`开始冲突检测，模块数量: ${manifests.length}`)

    const report: ConflictReport = {
      hasConflicts: false,
      routeConflicts: [],
      storeConflicts: [],
      policyConflicts: [],
      dependencyConflicts: [],
      performance: {
        totalCheckTime: 0,
        bloomFilterHits: 0,
        exactChecks: 0
      }
    }

    // 第一轮：构建布隆过滤器索引
    await this.buildBloomFilterIndex(manifests)

    // 第二轮：快速冲突检测
    for (const manifest of manifests) {
      await this.checkManifestConflicts(manifest, report)
    }

    // 第三轮：依赖冲突检测
    await this.checkDependencyConflicts(manifests, report)

    // 计算性能指标
    const totalTime = performance.now() - this.performance.startTime
    report.performance = {
      totalCheckTime: totalTime,
      bloomFilterHits: this.performance.bloomFilterHits,
      exactChecks: this.performance.exactChecks
    }

    report.hasConflicts = report.routeConflicts.length > 0 || 
                         report.storeConflicts.length > 0 || 
                         report.policyConflicts.length > 0 ||
                         report.dependencyConflicts.length > 0

    if (report.hasConflicts) {
      logger.error('检测到冲突', { report })
      this.logConflictReport(report)
    } else {
      logger.info('冲突检测完成，无冲突发现', { 
        performance: report.performance 
      })
    }

    return report
  }

  private async buildBloomFilterIndex(manifests: EnterpriseManifest[]): Promise<void> {
    logger.debug('构建布隆过滤器索引')
    
    for (const manifest of manifests) {
      // 索引路由
      for (const route of manifest.routes) {
        this.routeNameFilter.add(route.name)
        this.routePathFilter.add(this.normalizePath(route.path))
      }

      // 索引存储
      for (const store of manifest.stores) {
        this.storeIdFilter.add(store.id)
      }

      // 索引策略
      for (const policy of manifest.policies) {
        this.policyFilter.add(policy)
      }
    }
  }

  private async checkManifestConflicts(
    manifest: EnterpriseManifest, 
    report: ConflictReport
  ): Promise<void> {
    await Promise.all([
      this.checkRouteConflicts(manifest, report),
      this.checkStoreConflicts(manifest, report),
      this.checkPolicyConflicts(manifest, report)
    ])
  }

  private async checkRouteConflicts(
    manifest: EnterpriseManifest,
    report: ConflictReport
  ): Promise<void> {
    for (const route of manifest.routes) {
      // 快速布隆过滤器检查
      if (this.routeNameFilter.has(route.name)) {
        this.performance.bloomFilterHits++
        
        // 精确检查
        if (this.routeNames.has(route.name)) {
          this.performance.exactChecks++
          const conflictingModule = this.routeNames.get(route.name)!
          
          report.routeConflicts.push({
            type: 'route',
            resource: route.name,
            conflictingModules: [conflictingModule, manifest.name],
            severity: 'error',
            suggestion: `考虑重命名路由 "${route.name}" 或使用模块前缀`
          })
        } else {
          this.routeNames.set(route.name, manifest.name)
        }
      } else {
        this.routeNames.set(route.name, manifest.name)
      }

      // 路径冲突检查
      const normalizedPath = this.normalizePath(route.path)
      if (this.routePathFilter.has(normalizedPath)) {
        this.performance.bloomFilterHits++
        
        if (this.routePaths.has(normalizedPath)) {
          this.performance.exactChecks++
          const conflictingModule = this.routePaths.get(normalizedPath)!
          
          // 检查是否是真实冲突（不同框架可能共享路径）
          if (conflictingModule !== manifest.name) {
            report.routeConflicts.push({
              type: 'route',
              resource: route.path,
              conflictingModules: [conflictingModule, manifest.name],
              severity: 'warning',
              suggestion: `路径冲突可能导致路由覆盖，请检查路由优先级`
            })
          }
        } else {
          this.routePaths.set(normalizedPath, manifest.name)
        }
      } else {
        this.routePaths.set(normalizedPath, manifest.name)
      }
    }
  }

  private async checkStoreConflicts(
    manifest: EnterpriseManifest,
    report: ConflictReport
  ): Promise<void> {
    for (const store of manifest.stores) {
      if (this.storeIdFilter.has(store.id)) {
        this.performance.bloomFilterHits++
        
        if (this.storeIds.has(store.id)) {
          this.performance.exactChecks++
          const conflictingModule = this.storeIds.get(store.id)!
          
          report.storeConflicts.push({
            type: 'store',
            resource: store.id,
            conflictingModules: [conflictingModule, manifest.name],
            severity: 'critical',
            suggestion: `Store ID "${store.id}" 冲突，可能导致状态覆盖`
          })
        } else {
          this.storeIds.set(store.id, manifest.name)
        }
      } else {
        this.storeIds.set(store.id, manifest.name)
      }
    }
  }

  private async checkPolicyConflicts(
    manifest: EnterpriseManifest,
    report: ConflictReport
  ): Promise<void> {
    for (const policy of manifest.policies) {
      if (this.policyFilter.has(policy)) {
        this.performance.bloomFilterHits++
        
        if (this.policies.has(policy)) {
          this.performance.exactChecks++
          const conflictingModule = this.policies.get(policy)!
          
          report.policyConflicts.push({
            type: 'policy',
            resource: policy,
            conflictingModules: [conflictingModule, manifest.name],
            severity: 'warning',
            suggestion: `权限策略重复定义，建议统一管理`
          })
        } else {
          this.policies.set(policy, manifest.name)
        }
      } else {
        this.policies.set(policy, manifest.name)
      }
    }
  }

  private async checkDependencyConflicts(
    manifests: EnterpriseManifest[],
    report: ConflictReport
  ): Promise<void> {
    const moduleVersions = new Map<string, string>()
    
    for (const manifest of manifests) {
      if (moduleVersions.has(manifest.name)) {
        const existingVersion = moduleVersions.get(manifest.name)!
        if (existingVersion !== manifest.version) {
          report.dependencyConflicts.push({
            type: 'dependency',
            resource: manifest.name,
            conflictingModules: [manifest.name],
            severity: 'critical',
            suggestion: `模块版本冲突: ${existingVersion} vs ${manifest.version}`
          })
        }
      } else {
        moduleVersions.set(manifest.name, manifest.version)
      }
    }
  }

  private normalizePath(path: string): string {
    return path
      .replace(/:\w+/g, ':param')
      .replace(/\*/g, '*')
      .replace(/\/+$/, '')
      .toLowerCase()
  }

  private logConflictReport(report: ConflictReport): void {
    console.log(chalk.red('\n🚨 冲突检测报告'))
    console.log(chalk.red('=' .repeat(50)))
    
    if (report.routeConflicts.length > 0) {
      console.log(chalk.red('\n📍 路由冲突:'))
      report.routeConflicts.forEach(conflict => {
        console.log(chalk.red(`  ✗ ${conflict.resource}`))
        console.log(chalk.gray(`    模块: ${conflict.conflictingModules.join(' vs ')}`))
        if (conflict.suggestion) {
          console.log(chalk.yellow(`    建议: ${conflict.suggestion}`))
        }
      })
    }

    if (report.storeConflicts.length > 0) {
      console.log(chalk.red('\n🏪 Store冲突:'))
      report.storeConflicts.forEach(conflict => {
        console.log(chalk.red(`  ✗ ${conflict.resource}`))
        console.log(chalk.gray(`    模块: ${conflict.conflictingModules.join(' vs ')}`))
        if (conflict.suggestion) {
          console.log(chalk.yellow(`    建议: ${conflict.suggestion}`))
        }
      })
    }

    console.log(chalk.blue('\n📊 性能统计:'))
    console.log(chalk.blue(`  检测时间: ${report.performance.totalCheckTime.toFixed(2)}ms`))
    console.log(chalk.blue(`  布隆过滤器命中: ${report.performance.bloomFilterHits}`))
    console.log(chalk.blue(`  精确检查次数: ${report.performance.exactChecks}`))
  }

  // 清理资源
  dispose(): void {
    this.routeNames.clear()
    this.routePaths.clear()
    this.storeIds.clear()
    this.policies.clear()
  }
}
```

### 2.3 事务性增量更新生成器

```typescript
// tools/generator/transactional-generator.ts
import { promises as fs } from 'fs'
import path from 'path'
import { createHash } from 'crypto'
import { EnterpriseManifest, generateManifestHash } from './enhanced-schema'
import { OptimizedConflictDetector } from './optimized-conflict-detector'
import { createLogger } from './enterprise-logger'
import chalk from 'chalk'

const logger = createLogger('TransactionalGenerator')

interface GenerationTransaction {
  id: string
  timestamp: Date
  manifests: EnterpriseManifest[]
  changes: FileChange[]
  backupPath: string
  status: 'pending' | 'committed' | 'rolled-back'
}

interface FileChange {
  filePath: string
  operation: 'create' | 'update' | 'delete'
  previousContent?: string
  newContent?: string
  checksum: string
}

interface IncrementalCache {
  manifestHashes: Map<string, string>
  fileChecksums: Map<string, string>
  lastGenerationTime: Date
  generationCount: number
}

export class TransactionalIncrementalGenerator {
  private rootDir: string
  private backupDir: string
  private cacheDir: string
  private cache: IncrementalCache
  private conflictDetector: OptimizedConflictDetector
  private currentTransaction: GenerationTransaction | null = null

  constructor(rootDir: string) {
    this.rootDir = rootDir
    this.backupDir = path.join(rootDir, '.generator-backups')
    this.cacheDir = path.join(rootDir, '.generator-cache')
    this.conflictDetector = new OptimizedConflictDetector()
    
    this.cache = {
      manifestHashes: new Map(),
      fileChecksums: new Map(),
      lastGenerationTime: new Date(0),
      generationCount: 0
    }
  }

  async initialize(): Promise<void> {
    logger.info('初始化事务性增量生成器')
    
    // 创建必要目录
    await fs.mkdir(this.backupDir, { recursive: true })
    await fs.mkdir(this.cacheDir, { recursive: true })
    
    // 加载缓存
    await this.loadCache()
    
    logger.info('生成器初始化完成', {
      cacheEntries: this.cache.manifestHashes.size,
      lastGeneration: this.cache.lastGenerationTime
    })
  }

  async generateWithTransaction(manifests: EnterpriseManifest[]): Promise<void> {
    const transactionId = this.generateTransactionId()
    logger.info(`开始事务 ${transactionId}`)

    try {
      // 1. 创建事务
      this.currentTransaction = await this.createTransaction(transactionId, manifests)

      // 2. 冲突检测
      const conflictReport = await this.conflictDetector.detect(manifests)
      if (conflictReport.hasConflicts) {
        throw new Error('检测到模块冲突，事务中止')
      }

      // 3. 增量分析
      const incrementalPlan = await this.analyzeIncrementalChanges(manifests)
      logger.info('增量分析完成', {
        totalModules: manifests.length,
        changedModules: incrementalPlan.changedModules.length,
        newModules: incrementalPlan.newModules.length,
        deletedModules: incrementalPlan.deletedModules.length
      })

      // 4. 创建备份
      await this.createBackup()

      // 5. 执行增量生成
      await this.executeIncrementalGeneration(incrementalPlan)

      // 6. 验证生成结果
      await this.validateGeneratedFiles()

      // 7. 提交事务
      await this.commitTransaction()

      logger.info(`事务 ${transactionId} 成功提交`)

    } catch (error) {
      logger.error(`事务 ${transactionId} 失败`, error)
      
      if (this.currentTransaction) {
        await this.rollbackTransaction()
      }
      
      throw error
    } finally {
      this.currentTransaction = null
    }
  }

  private async createTransaction(
    id: string, 
    manifests: EnterpriseManifest[]
  ): Promise<GenerationTransaction> {
    const transaction: GenerationTransaction = {
      id,
      timestamp: new Date(),
      manifests: structuredClone(manifests),
      changes: [],
      backupPath: path.join(this.backupDir, `backup-${id}`),
      status: 'pending'
    }

    // 保存事务信息
    const transactionFile = path.join(this.cacheDir, `transaction-${id}.json`)
    await fs.writeFile(transactionFile, JSON.stringify(transaction, null, 2))

    return transaction
  }

  private async analyzeIncrementalChanges(manifests: EnterpriseManifest[]) {
    logger.debug('分析增量变更')
    
    const currentHashes = new Map<string, string>()
    const changedModules: string[] = []
    const newModules: string[] = []
    const deletedModules: string[] = []

    // 分析当前模块状态
    for (const manifest of manifests) {
      const currentHash = generateManifestHash(manifest)
      currentHashes.set(manifest.name, currentHash)

      const previousHash = this.cache.manifestHashes.get(manifest.name)
      
      if (!previousHash) {
        newModules.push(manifest.name)
        logger.debug(`新模块: ${manifest.name}`)
      } else if (previousHash !== currentHash) {
        changedModules.push(manifest.name)
        logger.debug(`变更模块: ${manifest.name}`)
      }
    }

    // 检测删除的模块
    for (const [moduleName] of this.cache.manifestHashes) {
      if (!currentHashes.has(moduleName)) {
        deletedModules.push(moduleName)
        logger.debug(`删除模块: ${moduleName}`)
      }
    }

    return {
      currentHashes,
      changedModules,
      newModules,
      deletedModules,
      requiresFullRegeneration: newModules.length > 0 || deletedModules.length > 0
    }
  }

  private async createBackup(): Promise<void> {
    if (!this.currentTransaction) return

    logger.debug('创建备份')
    
    const backupPath = this.currentTransaction.backupPath
    await fs.mkdir(backupPath, { recursive: true })

    // 备份重要的生成文件
    const criticalFiles = [
      'src/appshell/router/routes.generated.ts',
      'src/appshell/stores/stores.generated.ts',
      'src/appshell/lifecycle.generated.ts',
      'src/appshell/security/policies.generated.ts'
    ]

    for (const filePath of criticalFiles) {
      const fullPath = path.join(this.rootDir, filePath)
      
      if (await this.fileExists(fullPath)) {
        const content = await fs.readFile(fullPath, 'utf-8')
        const backupFilePath = path.join(backupPath, path.basename(filePath))
        await fs.writeFile(backupFilePath, content)
        
        logger.debug(`备份文件: ${filePath}`)
      }
    }

    // 备份缓存状态
    const cacheBackupPath = path.join(backupPath, 'cache.json')
    await fs.writeFile(cacheBackupPath, JSON.stringify({
      manifestHashes: Array.from(this.cache.manifestHashes.entries()),
      fileChecksums: Array.from(this.cache.fileChecksums.entries()),
      lastGenerationTime: this.cache.lastGenerationTime,
      generationCount: this.cache.generationCount
    }, null, 2))
  }

  private async executeIncrementalGeneration(incrementalPlan: any): Promise<void> {
    logger.info('执行增量生成')

    const { changedModules, newModules, requiresFullRegeneration } = incrementalPlan

    if (requiresFullRegeneration) {
      logger.info('执行完整重新生成')
      await this.executeFullGeneration()
    } else if (changedModules.length > 0) {
      logger.info(`增量更新 ${changedModules.length} 个模块`)
      await this.executePartialGeneration(changedModules)
    } else {
      logger.info('无变更，跳过生成')
      return
    }

    // 更新缓存
    this.cache.manifestHashes = incrementalPlan.currentHashes
    this.cache.lastGenerationTime = new Date()
    this.cache.generationCount++
    
    await this.saveCache()
  }

  private async executeFullGeneration(): Promise<void> {
    if (!this.currentTransaction) return

    const manifests = this.currentTransaction.manifests

    // 并行生成所有文件
    await Promise.all([
      this.generateRoutes(manifests),
      this.generateStores(manifests),
      this.generateLifecycles(manifests),
      this.generatePolicies(manifests),
      this.generateModuleRegistry(manifests)
    ])
  }

  private async executePartialGeneration(changedModules: string[]): Promise<void> {
    if (!this.currentTransaction) return

    const manifests = this.currentTransaction.manifests
    const changedManifests = manifests.filter(m => changedModules.includes(m.name))

    logger.info(`部分更新模块: ${changedModules.join(', ')}`)

    // 智能部分更新
    await this.updateSpecificModules(changedManifests)
  }

  private async updateSpecificModules(changedManifests: EnterpriseManifest[]): Promise<void> {
    // 这里实现智能的部分更新逻辑
    // 只更新受影响的代码段
    
    for (const manifest of changedManifests) {
      logger.debug(`更新模块: ${manifest.name}`)
      
      // 更新模块特定的路由、状态等
      await this.updateModuleRoutes(manifest)
      await this.updateModuleStores(manifest)
      await this.updateModulePolicies(manifest)
    }
  }

  private async commitTransaction(): Promise<void> {
    if (!this.currentTransaction) return

    logger.info(`提交事务 ${this.currentTransaction.id}`)
    
    this.currentTransaction.status = 'committed'
    
    // 更新事务状态
    const transactionFile = path.join(this.cacheDir, `transaction-${this.currentTransaction.id}.json`)
    await fs.writeFile(transactionFile, JSON.stringify(this.currentTransaction, null, 2))

    // 清理旧备份（保留最近5个）
    await this.cleanupOldBackups()
  }

  private async rollbackTransaction(): Promise<void> {
    if (!this.currentTransaction) return

    logger.warn(`回滚事务 ${this.currentTransaction.id}`)
    
    const backupPath = this.currentTransaction.backupPath
    
    if (await this.fileExists(backupPath)) {
      // 恢复备份文件
      const backupFiles = await fs.readdir(backupPath)
      
      for (const file of backupFiles) {
        if (file === 'cache.json') continue
        
        const backupFilePath = path.join(backupPath, file)
        const originalFilePath = path.join(this.rootDir, 'src/appshell', file)
        
        const backupContent = await fs.readFile(backupFilePath, 'utf-8')
        await fs.writeFile(originalFilePath, backupContent)
        
        logger.debug(`恢复文件: ${file}`)
      }

      // 恢复缓存状态
      const cacheBackupPath = path.join(backupPath, 'cache.json')
      if (await this.fileExists(cacheBackupPath)) {
        const cacheBackup = JSON.parse(await fs.readFile(cacheBackupPath, 'utf-8'))
        this.cache.manifestHashes = new Map(cacheBackup.manifestHashes)
        this.cache.fileChecksums = new Map(cacheBackup.fileChecksums)
        this.cache.lastGenerationTime = new Date(cacheBackup.lastGenerationTime)
        this.cache.generationCount = cacheBackup.generationCount
      }
    }

    this.currentTransaction.status = 'rolled-back'
    
    // 更新事务状态
    const transactionFile = path.join(this.cacheDir, `transaction-${this.currentTransaction.id}.json`)
    await fs.writeFile(transactionFile, JSON.stringify(this.currentTransaction, null, 2))
  }

  // 生成文件的具体实现方法
  private async generateRoutes(manifests: EnterpriseManifest[]): Promise<void> {
    // 实现路由生成逻辑
    logger.debug('生成路由文件')
    // ... 具体实现
  }

  private async generateStores(manifests: EnterpriseManifest[]): Promise<void> {
    // 实现状态管理生成逻辑
    logger.debug('生成状态管理文件')
    // ... 具体实现
  }

  private async generateLifecycles(manifests: EnterpriseManifest[]): Promise<void> {
    // 实现生命周期生成逻辑
    logger.debug('生成生命周期文件')
    // ... 具体实现
  }

  private async generatePolicies(manifests: EnterpriseManifest[]): Promise<void> {
    // 实现权限策略生成逻辑
    logger.debug('生成权限策略文件')
    // ... 具体实现
  }

  private async generateModuleRegistry(manifests: EnterpriseManifest[]): Promise<void> {
    // 生成模块注册表
    logger.debug('生成模块注册表')
    // ... 具体实现
  }

  // 工具方法
  private generateTransactionId(): string {
    return `tx-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  }

  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath)
      return true
    } catch {
      return false
    }
  }

  private async loadCache(): Promise<void> {
    const cacheFile = path.join(this.cacheDir, 'generation-cache.json')
    
    if (await this.fileExists(cacheFile)) {
      try {
        const cacheData = JSON.parse(await fs.readFile(cacheFile, 'utf-8'))
        this.cache.manifestHashes = new Map(cacheData.manifestHashes || [])
        this.cache.fileChecksums = new Map(cacheData.fileChecksums || [])
        this.cache.lastGenerationTime = new Date(cacheData.lastGenerationTime || 0)
        this.cache.generationCount = cacheData.generationCount || 0
      } catch (error) {
        logger.warn('缓存文件损坏，重置缓存', error)
      }
    }
  }

  private async saveCache(): Promise<void> {
    const cacheFile = path.join(this.cacheDir, 'generation-cache.json')
    
    await fs.writeFile(cacheFile, JSON.stringify({
      manifestHashes: Array.from(this.cache.manifestHashes.entries()),
      fileChecksums: Array.from(this.cache.fileChecksums.entries()),
      lastGenerationTime: this.cache.lastGenerationTime,
      generationCount: this.cache.generationCount
    }, null, 2))
  }

  private async cleanupOldBackups(): Promise<void> {
    const backupDirs = await fs.readdir(this.backupDir)
    const backupDirList = backupDirs
      .filter(dir => dir.startsWith('backup-'))
      .sort()
      .reverse()

    // 保留最近5个备份
    const backupsToDelete = backupDirList.slice(5)
    
    for (const backup of backupsToDelete) {
      const backupPath = path.join(this.backupDir, backup)
      await fs.rm(backupPath, { recursive: true, force: true })
      logger.debug(`清理旧备份: ${backup}`)
    }
  }

  async dispose(): Promise<void> {
    this.conflictDetector.dispose()
    await this.saveCache()
  }
}
```

---

继续阅读更多重构内容...
