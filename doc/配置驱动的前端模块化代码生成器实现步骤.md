# ç¬¬ä¸€ç« ï¼šå®è·µæ­¥éª¤

åŸºäºæ‚¨æä¾›çš„æŠ€æœ¯æ–‡æ¡£ï¼Œæˆ‘å°†å®ç°ä¸€ä¸ªå®Œæ•´çš„é…ç½®é©±åŠ¨å‰ç«¯æ¨¡å—åŒ–ç”Ÿæˆå™¨ã€‚è¿™ä¸ªç³»ç»Ÿå°†é‡‡ç”¨ABPé£æ ¼çš„æ¨¡å—åŒ–è®¾è®¡ï¼Œå®ç°è‡ªåŠ¨åŒ–ä»£ç ç”Ÿæˆå’Œä¾èµ–ç®¡ç†ã€‚

## ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         é…ç½®é©±åŠ¨ç”Ÿæˆå™¨æ¶æ„                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¨¡å—æ¸…å• â†’ è§£æéªŒè¯ â†’ ä»£ç ç”Ÿæˆ â†’ çƒ­æ›´æ–°    â”‚
â”‚     â†“         â†“          â†“         â†“       â”‚
â”‚  manifest  schema    templates   runtime    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Step 1: é¡¹ç›®åˆå§‹åŒ–å’ŒåŸºç¡€é…ç½®

### 1.1 åˆ›å»ºé¡¹ç›®ç»“æ„

```bash
mkdir vue-modular-generator
cd vue-modular-generator
```

### 1.2 åˆå§‹åŒ–package.json

```json
{
  "name": "vue-modular-generator",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "npm run gen && vite",
    "dev:watch": "concurrently \"npm run gen:watch\" \"vite\"",
    "build": "npm run gen && vite build",
    "preview": "vite preview",
    "gen": "tsx tools/generator/cli.ts",
    "gen:watch": "tsx tools/generator/cli.ts --watch",
    "gen:check": "tsx tools/generator/cli.ts --check",
    "module:create": "tsx tools/generator/cli.ts create-module",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "pinia": "^2.2.0",
    "vue": "^3.4.0",
    "vue-router": "^4.4.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@vitejs/plugin-vue": "^5.0.0",
    "chalk": "^5.3.0",
    "chokidar": "^3.6.0",
    "concurrently": "^8.2.0",
    "inquirer": "^9.2.0",
    "tsx": "^4.7.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "vitest": "^1.0.0",
    "zod": "^3.22.0"
  }
}
```

### 1.3 TypeScripté…ç½®

```typescript
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "preserve",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "types": ["vite/client", "node"]
  },
  "include": ["src/**/*", "src/**/*.vue", "tools/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### 1.4 Viteé…ç½®

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  server: {
    port: 3000,
    open: true
  }
})
```

## Step 2: ç”Ÿæˆå™¨æ ¸å¿ƒå¼•æ“å®ç°

### 2.1 Schemaå®šä¹‰å’ŒéªŒè¯

```typescript
// tools/generator/schema.ts
import { z } from 'zod'

// è·¯ç”±é…ç½®Schema
export const RouteSchema = z.object({
  name: z.string().min(1).regex(/^[A-Z][a-zA-Z0-9]+$/),
  path: z.string().startsWith('/'),
  component: z.string().startsWith('@/'),
  meta: z.object({
    title: z.string().optional(),
    icon: z.string().optional(),
    policy: z.string().optional(),
    keepAlive: z.boolean().optional(),
    hidden: z.boolean().optional()
  }).optional()
})

// Storeé…ç½®Schema
export const StoreSchema = z.object({
  symbol: z.string().regex(/^use[A-Z]\w+Store$/),
  id: z.string().min(1).regex(/^[a-z][a-z0-9-]*$/),
  modulePath: z.string().startsWith('@/')
})

// ç”Ÿå‘½å‘¨æœŸé’©å­Schema
export const LifecycleSchema = z.object({
  preInit: z.string().startsWith('@/').optional(),
  init: z.string().startsWith('@/').optional(),
  postInit: z.string().startsWith('@/').optional(),
  beforeMount: z.string().startsWith('@/').optional(),
  mounted: z.string().startsWith('@/').optional()
})

// æƒé™ç­–ç•¥Schema
export const PolicySchema = z.string().regex(/^[A-Z][a-zA-Z0-9]*\.[A-Z][a-zA-Z0-9]*(\.[A-Z][a-zA-Z0-9]*)?$/)

// å®Œæ•´çš„æ¨¡å—æ¸…å•Schema
export const ManifestSchema = z.object({
  $schema: z.string().optional(),
  name: z.string().min(1).regex(/^[A-Z][a-zA-Z0-9]+$/),
  displayName: z.string().optional(),
  description: z.string().optional(),
  version: z.string().regex(/^\d+\.\d+\.\d+$/).default('1.0.0'),
  author: z.string().optional(),
  abpStyle: z.boolean().default(true),
  order: z.number().int().min(0).default(100),
  dependsOn: z.array(z.string()).default([]),
  routes: z.array(RouteSchema).default([]),
  stores: z.array(StoreSchema).default([]),
  policies: z.array(PolicySchema).default([]),
  lifecycle: LifecycleSchema.default({}),
  features: z.object({
    enableAuth: z.boolean().default(true),
    enableCache: z.boolean().default(true),
    enableI18n: z.boolean().default(true)
  }).optional()
})

export type Manifest = z.infer<typeof ManifestSchema>
export type Route = z.infer<typeof RouteSchema>
export type Store = z.infer<typeof StoreSchema>
export type Lifecycle = z.infer<typeof LifecycleSchema>
```

### 2.2 ä¾èµ–è§£æå’Œå†²çªæ£€æµ‹

```typescript
// tools/generator/resolvers.ts
import type { Manifest } from './schema'
import chalk from 'chalk'

export class DependencyResolver {
  private manifests: Map<string, Manifest> = new Map()
  
  constructor(manifests: Manifest[]) {
    manifests.forEach(m => this.manifests.set(m.name, m))
  }

  // æ‹“æ‰‘æ’åºå®ç°
  topoSort(): Manifest[] {
    const visited = new Set<string>()
    const visiting = new Set<string>()
    const sorted: Manifest[] = []

    const visit = (name: string, path: string[] = []): void => {
      if (visited.has(name)) return
      
      if (visiting.has(name)) {
        throw new Error(
          `Circular dependency detected: ${[...path, name].join(' â†’ ')}`
        )
      }

      const manifest = this.manifests.get(name)
      if (!manifest) {
        throw new Error(`Missing manifest for module: ${name}`)
      }

      visiting.add(name)
      
      // é€’å½’è®¿é—®ä¾èµ–
      for (const dep of manifest.dependsOn || []) {
        visit(dep, [...path, name])
      }
      
      visiting.delete(name)
      visited.add(name)
      sorted.push(manifest)
    }

    // æŒ‰orderæ’åºåå¼€å§‹è®¿é—®
    const orderedManifests = Array.from(this.manifests.values())
      .sort((a, b) => (a.order ?? 100) - (b.order ?? 100))
    
    for (const manifest of orderedManifests) {
      visit(manifest.name)
    }

    return sorted
  }
}

export class ConflictDetector {
  private routeNames = new Map<string, string>()
  private routePaths = new Map<string, string>()
  private storeIds = new Map<string, string>()
  private policies = new Map<string, string>()
  private errors: string[] = []

  detect(manifests: Manifest[]): void {
    this.errors = []
    
    for (const manifest of manifests) {
      this.checkRoutes(manifest)
      this.checkStores(manifest)
      this.checkPolicies(manifest)
    }

    if (this.errors.length > 0) {
      const errorMessage = this.errors
        .map(e => `  ${chalk.red('âœ—')} ${e}`)
        .join('\n')
      throw new Error(`\n${chalk.red('Conflicts detected:')}\n${errorMessage}`)
    }
  }

  private checkRoutes(manifest: Manifest): void {
    for (const route of manifest.routes) {
      // æ£€æŸ¥è·¯ç”±åç§°å†²çª
      if (this.routeNames.has(route.name)) {
        this.errors.push(
          `Route name "${route.name}" already exists in module "${this.routeNames.get(route.name)}" (conflict with "${manifest.name}")`
        )
      } else {
        this.routeNames.set(route.name, manifest.name)
      }

      // æ£€æŸ¥è·¯ç”±è·¯å¾„å†²çª
      const normalizedPath = this.normalizePath(route.path)
      if (this.routePaths.has(normalizedPath)) {
        this.errors.push(
          `Route path "${route.path}" conflicts with module "${this.routePaths.get(normalizedPath)}" (in "${manifest.name}")`
        )
      } else {
        this.routePaths.set(normalizedPath, manifest.name)
      }
    }
  }

  private checkStores(manifest: Manifest): void {
    for (const store of manifest.stores) {
      if (this.storeIds.has(store.id)) {
        this.errors.push(
          `Store id "${store.id}" already exists in module "${this.storeIds.get(store.id)}" (conflict with "${manifest.name}")`
        )
      } else {
        this.storeIds.set(store.id, manifest.name)
      }
    }
  }

  private checkPolicies(manifest: Manifest): void {
    for (const policy of manifest.policies) {
      if (this.policies.has(policy)) {
        this.errors.push(
          `Policy "${policy}" already defined in module "${this.policies.get(policy)}" (conflict with "${manifest.name}")`
        )
      } else {
        this.policies.set(policy, manifest.name)
      }
    }
  }

  private normalizePath(path: string): string {
    // å°†åŠ¨æ€å‚æ•°ç»Ÿä¸€åŒ–ï¼Œé¿å…å‡å†²çª
    return path
      .replace(/:\w+/g, ':param')
      .replace(/\*/g, '*')
      .replace(/\/+$/, '')
  }
}
```

### 2.3 ä»£ç ç”Ÿæˆå™¨

```typescript
// tools/generator/writers.ts
import { promises as fs } from 'fs'
import path from 'path'
import type { Manifest } from './schema'

export class CodeWriter {
  constructor(private rootDir: string) {}

  async writeRoutes(manifests: Manifest[]): Promise<void> {
    const imports: string[] = []
    const routes: string[] = []

    manifests.forEach(manifest => {
      manifest.routes.forEach(route => {
        routes.push(`  {
    name: '${route.name}',
    path: '${route.path}',
    component: () => import('${route.component}'),
    meta: ${JSON.stringify(route.meta || {}, null, 6).replace(/\n/g, '\n    ')}
  }`)
      })
    })

    const content = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated at: ${new Date().toISOString()}
// Modules: ${manifests.map(m => m.name).join(', ')}

import type { RouteRecordRaw } from 'vue-router'

export const generatedRoutes: RouteRecordRaw[] = [
${routes.join(',\n')}
]

export const routeModuleMap = {
${manifests.map(m => `  '${m.name}': [${m.routes.map(r => `'${r.name}'`).join(', ')}]`).join(',\n')}
}
`

    await this.writeFile('src/appshell/router/routes.generated.ts', content)
  }

  async writeStores(manifests: Manifest[]): Promise<void> {
    const imports: string[] = []
    const registrations: string[] = []

    manifests.forEach(manifest => {
      manifest.stores.forEach(store => {
        imports.push(`import { ${store.symbol} } from '${store.modulePath}'`)
        registrations.push(`  ${store.symbol}, // ${manifest.name}`)
      })
    })

    const content = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated at: ${new Date().toISOString()}

${imports.join('\n')}

export const generatedStores = async () => {
  // Stores are auto-imported and will be available when needed
  return {
${registrations.join(',\n')}
  }
}

export const storeModuleMap = {
${manifests.map(m => `  '${m.name}': [${m.stores.map(s => `'${s.id}'`).join(', ')}]`).join(',\n')}
}
`

    await this.writeFile('src/appshell/stores/stores.generated.ts', content)
  }

  async writeLifecycles(manifests: Manifest[]): Promise<void> {
    const hooks = ['preInit', 'init', 'postInit', 'beforeMount', 'mounted']
    const sections: string[] = []

    for (const hook of hooks) {
      const hookImports: string[] = []
      const hookCalls: string[] = []

      manifests.forEach(manifest => {
        const hookPath = manifest.lifecycle[hook as keyof typeof manifest.lifecycle]
        if (hookPath) {
          const importName = `${manifest.name}_${hook}`
          hookImports.push(`import ${importName} from '${hookPath}'`)
          hookCalls.push(`    await ${importName}?.(ctx) // ${manifest.name}`)
        }
      })

      if (hookImports.length > 0) {
        sections.push(`// ${hook} hooks
${hookImports.join('\n')}

export async function run${hook.charAt(0).toUpperCase() + hook.slice(1)}(ctx: any) {
  try {
${hookCalls.join('\n')}
  } catch (error) {
    console.error('[Lifecycle] Error in ${hook}:', error)
    throw error
  }
}`)
      } else {
        sections.push(`export async function run${hook.charAt(0).toUpperCase() + hook.slice(1)}(ctx: any) {
  // No ${hook} hooks registered
}`)
      }
    }

    const content = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated at: ${new Date().toISOString()}

${sections.join('\n\n')}

export const lifecycleModuleMap = {
${manifests.map(m => {
  const hooks = Object.entries(m.lifecycle)
    .filter(([_, v]) => v)
    .map(([k]) => `'${k}'`)
  return `  '${m.name}': [${hooks.join(', ')}]`
}).join(',\n')}
}
`

    await this.writeFile('src/appshell/lifecycle.generated.ts', content)
  }

  async writePolicies(manifests: Manifest[]): Promise<void> {
    const allPolicies: Record<string, string> = {}
    
    manifests.forEach(manifest => {
      manifest.policies.forEach(policy => {
        allPolicies[policy] = manifest.name
      })
    })

    const content = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated at: ${new Date().toISOString()}

export const generatedPolicies = ${JSON.stringify(allPolicies, null, 2)}

export const policyModuleMap = {
${manifests.map(m => `  '${m.name}': ${JSON.stringify(m.policies)}`).join(',\n')}
}
`

    await this.writeFile('src/appshell/security/policies.generated.ts', content)
  }

  private async writeFile(filePath: string, content: string): Promise<void> {
    const fullPath = path.join(this.rootDir, filePath)
    await fs.mkdir(path.dirname(fullPath), { recursive: true })
    await fs.writeFile(fullPath, content, 'utf-8')
  }
}
```

### 2.4 ä¸»CLIå®ç°

```typescript
// tools/generator/cli.ts
import { promises as fs } from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import chalk from 'chalk'
import chokidar from 'chokidar'
import inquirer from 'inquirer'
import { ManifestSchema, type Manifest } from './schema'
import { DependencyResolver, ConflictDetector } from './resolvers'
import { CodeWriter } from './writers'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const ROOT_DIR = path.resolve(__dirname, '../..')
const MODULES_DIR = path.join(ROOT_DIR, 'src/modules')

class ModularGenerator {
  private writer = new CodeWriter(ROOT_DIR)

  async loadManifests(): Promise<Manifest[]> {
    if (!await this.exists(MODULES_DIR)) {
      await fs.mkdir(MODULES_DIR, { recursive: true })
      return []
    }

    const modules = await fs.readdir(MODULES_DIR)
    const manifests: Manifest[] = []

    for (const module of modules) {
      const modulePath = path.join(MODULES_DIR, module)
      const stat = await fs.stat(modulePath)
      
      if (!stat.isDirectory()) continue
      
      const manifestPath = path.join(modulePath, 'abp.module.json')
      
      if (!await this.exists(manifestPath)) continue
      
      try {
        const content = await fs.readFile(manifestPath, 'utf-8')
        const raw = JSON.parse(content)
        const manifest = ManifestSchema.parse(raw)
        manifests.push(manifest)
      } catch (error) {
        console.error(chalk.red(`âœ— Failed to load manifest for ${module}:`), error)
        throw error
      }
    }

    return manifests
  }

  async generate(): Promise<void> {
    console.log(chalk.blue('ğŸ”§ Starting code generation...'))
    
    try {
      // åŠ è½½æ‰€æœ‰æ¸…å•
      const manifests = await this.loadManifests()
      
      if (manifests.length === 0) {
        console.log(chalk.yellow('âš  No modules found. Create a module first with: npm run module:create'))
        return
      }

      console.log(chalk.gray(`Found ${manifests.length} modules: ${manifests.map(m => m.name).join(', ')}`))

      // ä¾èµ–æ’åº
      const resolver = new DependencyResolver(manifests)
      const sorted = resolver.topoSort()
      
      // å†²çªæ£€æµ‹
      const detector = new ConflictDetector()
      detector.detect(sorted)

      // ç”Ÿæˆä»£ç 
      await this.writer.writeRoutes(sorted)
      await this.writer.writeStores(sorted)
      await this.writer.writeLifecycles(sorted)
      await this.writer.writePolicies(sorted)

      console.log(chalk.green(`âœ“ Successfully generated code for ${sorted.length} modules`))
      
      // è¾“å‡ºæ¨¡å—åŠ è½½é¡ºåº
      console.log(chalk.gray('\nModule load order:'))
      sorted.forEach((m, i) => {
        const deps = m.dependsOn?.length ? ` (deps: ${m.dependsOn.join(', ')})` : ''
        console.log(chalk.gray(`  ${i + 1}. ${m.name}${deps}`))
      })
      
    } catch (error) {
      console.error(chalk.red('âœ— Generation failed:'), error)
      process.exit(1)
    }
  }

  async check(): Promise<void> {
    console.log(chalk.blue('ğŸ” Checking module configurations...'))
    
    try {
      const manifests = await this.loadManifests()
      
      if (manifests.length === 0) {
        console.log(chalk.yellow('âš  No modules found'))
        return
      }

      const resolver = new DependencyResolver(manifests)
      const sorted = resolver.topoSort()
      
      const detector = new ConflictDetector()
      detector.detect(sorted)

      console.log(chalk.green(`âœ“ All ${manifests.length} modules passed validation`))
      
    } catch (error) {
      console.error(chalk.red('âœ— Validation failed:'), error)
      process.exit(1)
    }
  }

  async watch(): Promise<void> {
    console.log(chalk.blue('ğŸ‘ Watching for manifest changes...'))
    
    // åˆå§‹ç”Ÿæˆ
    await this.generate()

    // ç›‘å¬å˜åŒ–
    const watcher = chokidar.watch(
      path.join(MODULES_DIR, '**/abp.module.json'),
      {
        persistent: true,
        ignoreInitial: true
      }
    )

    watcher.on('all', async (event, filePath) => {
      console.log(chalk.gray(`\n[${new Date().toLocaleTimeString()}] ${event}: ${path.relative(ROOT_DIR, filePath)}`))
      
      try {
        await this.generate()
      } catch (error) {
        console.error(chalk.red('âœ— Generation failed:'), error)
      }
    })

    console.log(chalk.gray('Press Ctrl+C to stop watching'))
  }

  async createModule(): Promise<void> {
    console.log(chalk.blue('ğŸš€ Create New Module'))
    
    const answers = await inquirer.prompt([
      {
        type: 'input',
        name: 'name',
        message: 'Module name (PascalCase):',
        validate: (input) => /^[A-Z][a-zA-Z0-9]+$/.test(input) || 'Must be PascalCase (e.g., UserManagement)'
      },
      {
        type: 'input',
        name: 'displayName',
        message: 'Display name:',
        default: (answers: any) => answers.name
      },
      {
        type: 'input',
        name: 'description',
        message: 'Description:',
        default: ''
      },
      {
        type: 'checkbox',
        name: 'dependencies',
        message: 'Select dependencies:',
        choices: async () => {
          const manifests = await this.loadManifests()
          return manifests.map(m => m.name)
        }
      },
      {
        type: 'confirm',
        name: 'addRoute',
        message: 'Add a default route?',
        default: true
      },
      {
        type: 'confirm',
        name: 'addStore',
        message: 'Add a Pinia store?',
        default: true
      }
    ])

    const moduleDir = path.join(MODULES_DIR, answers.name)
    
    // åˆ›å»ºç›®å½•ç»“æ„
    await fs.mkdir(path.join(moduleDir, 'views'), { recursive: true })
    await fs.mkdir(path.join(moduleDir, 'stores'), { recursive: true })
    await fs.mkdir(path.join(moduleDir, 'services'), { recursive: true })
    await fs.mkdir(path.join(moduleDir, 'components'), { recursive: true })
    await fs.mkdir(path.join(moduleDir, 'types'), { recursive: true })

    // åˆ›å»ºmanifest
    const manifest: Manifest = {
      name: answers.name,
      displayName: answers.displayName,
      description: answers.description,
      version: '1.0.0',
      abpStyle: true,
      order: 100,
      dependsOn: answers.dependencies,
      routes: [],
      stores: [],
      policies: [],
      lifecycle: {}
    }

    // æ·»åŠ é»˜è®¤è·¯ç”±
    if (answers.addRoute) {
      const routePath = `/${answers.name.toLowerCase()}`
      manifest.routes.push({
        name: `${answers.name}Index`,
        path: routePath,
        component: `@/modules/${answers.name}/views/Index.vue`,
        meta: {
          title: answers.displayName,
          icon: 'mdi:view-dashboard'
        }
      })

      // åˆ›å»ºé»˜è®¤è§†å›¾ç»„ä»¶
      await fs.writeFile(
        path.join(moduleDir, 'views/Index.vue'),
        `<template>
  <div class="${answers.name.toLowerCase()}-index">
    <h1>${answers.displayName}</h1>
    <p>${answers.description || 'Module description'}</p>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue'
${answers.addStore ? `import { use${answers.name}Store } from '../stores/${answers.name.toLowerCase()}'` : ''}

${answers.addStore ? `const store = use${answers.name}Store()` : ''}

onMounted(() => {
  console.log('${answers.name} module mounted')
})
</script>

<style scoped>
.${answers.name.toLowerCase()}-index {
  padding: 20px;
}
</style>
`,
        'utf-8'
      )
    }

    // æ·»åŠ store
    if (answers.addStore) {
      manifest.stores.push({
        symbol: `use${answers.name}Store`,
        id: answers.name.toLowerCase(),
        modulePath: `@/modules/${answers.name}/stores/${answers.name.toLowerCase()}`
      })

      // åˆ›å»ºstoreæ–‡ä»¶
      await fs.writeFile(
        path.join(moduleDir, `stores/${answers.name.toLowerCase()}.ts`),
        `import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const use${answers.name}Store = defineStore('${answers.name.toLowerCase()}', () => {
  // State
  const loading = ref(false)
  const data = ref<any[]>([])
  
  // Getters
  const count = computed(() => data.value.length)
  
  // Actions
  async function fetchData() {
    loading.value = true
    try {
      // TODO: Implement data fetching
      data.value = []
    } finally {
      loading.value = false
    }
  }
  
  function reset() {
    data.value = []
    loading.value = false
  }
  
  return {
    // State
    loading,
    data,
    // Getters
    count,
    // Actions
    fetchData,
    reset
  }
})
`,
        'utf-8'
      )
    }

    // ä¿å­˜manifest
    await fs.writeFile(
      path.join(moduleDir, 'abp.module.json'),
      JSON.stringify(manifest, null, 2),
      'utf-8'
    )

    console.log(chalk.green(`\nâœ“ Module "${answers.name}" created successfully!`))
    console.log(chalk.gray(`  Location: ${path.relative(ROOT_DIR, moduleDir)}`))
    
    // è§¦å‘ç”Ÿæˆ
    await this.generate()
  }

  private async exists(path: string): Promise<boolean> {
    try {
      await fs.access(path)
      return true
    } catch {
      return false
    }
  }
}

// CLIå…¥å£
async function main() {
  const generator = new ModularGenerator()
  const command = process.argv[2]

  switch (command) {
    case '--watch':
      await generator.watch()
      break
    case '--check':
      await generator.check()
      break
    case 'create-module':
      await generator.createModule()
      break
    default:
      await generator.generate()
      break
  }
}

main().catch(error => {
  console.error(chalk.red('Fatal error:'), error)
  process.exit(1)
})
```

## Step 3: AppShellæ ¸å¿ƒå®ç°

### 3.1 åˆ›å»ºAppShellç»“æ„

```typescript
// src/appshell/boot.ts
import type { App } from 'vue'
import { router } from './router'
import { pinia } from './stores'
import { setupSecurity } from './security'
import {
  runPreInit,
  runInit,
  runPostInit,
  runBeforeMount,
  runMounted
} from './lifecycle.generated'

export async function bootstrap(app: App) {
  console.log('ğŸš€ Starting application bootstrap...')
  
  const ctx = { app, router, pinia }
  
  try {
    // ç”Ÿå‘½å‘¨æœŸ: preInit
    await runPreInit(ctx)
    
    // å®‰è£…Pinia
    app.use(pinia)
    
    // è®¾ç½®å®‰å…¨ç³»ç»Ÿ
    await setupSecurity(router)
    
    // ç”Ÿå‘½å‘¨æœŸ: init
    await runInit(ctx)
    
    // å®‰è£…è·¯ç”±
    app.use(router)
    
    // ç”Ÿå‘½å‘¨æœŸ: postInit
    await runPostInit(ctx)
    
    // ç”Ÿå‘½å‘¨æœŸ: beforeMount
    await runBeforeMount(ctx)
    
    // æŒ‚è½½åº”ç”¨
    app.mount('#app')
    
    // ç”Ÿå‘½å‘¨æœŸ: mounted
    await runMounted(ctx)
    
    console.log('âœ… Application bootstrap completed')
  } catch (error) {
    console.error('âŒ Bootstrap failed:', error)
    throw error
  }
}
```

### 3.2 è·¯ç”±ç³»ç»Ÿ

```typescript
// src/appshell/router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'
import { generatedRoutes } from './routes.generated'

// åŸºç¡€è·¯ç”±ï¼ˆç³»ç»Ÿçº§åˆ«ï¼‰
const baseRoutes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'Root',
    redirect: '/dashboard'
  },
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import('@/views/Dashboard.vue'),
    meta: {
      title: 'Dashboard',
      icon: 'mdi:view-dashboard'
    }
  },
  {
    path: '/403',
    name: 'Forbidden',
    component: () => import('@/views/errors/403.vue'),
    meta: {
      title: 'Access Denied',
      hidden: true
    }
  },
  {
    path: '/404',
    name: 'NotFound',
    component: () => import('@/views/errors/404.vue'),
    meta: {
      title: 'Page Not Found',
      hidden: true
    }
  },
  {
    path: '/:pathMatch(.*)*',
    redirect: '/404'
  }
]

export const router = createRouter({
  history: createWebHistory(),
  routes: [...baseRoutes, ...generatedRoutes],
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition
    } else {
      return { top: 0 }
    }
  }
})

// è·¯ç”±å‡†å¤‡å°±ç»ªçš„Promise
export const routerReady = router.isReady()
```

### 3.3 çŠ¶æ€ç®¡ç†

```typescript
// src/appshell/stores/index.ts
import { createPinia } from 'pinia'
import type { PiniaPluginContext } from 'pinia'

export const pinia = createPinia()

// Piniaæ’ä»¶ï¼šæ·»åŠ é‡ç½®åŠŸèƒ½
pinia.use(({ store }: PiniaPluginContext) => {
  const initialState = JSON.parse(JSON.stringify(store.$state))
  
  store.$reset = () => {
    store.$patch(initialState)
  }
})

// å¯¼å…¥ç”Ÿæˆçš„stores
export * from './stores.generated'
```

### 3.4 å®‰å…¨ç³»ç»Ÿ

```typescript
// src/appshell/security/index.ts
import type { Router } from 'vue-router'
import { generatedPolicies } from './policies.generated'

// æƒé™æ£€æŸ¥æœåŠ¡
class SecurityService {
  private userPolicies: Set<string> = new Set()
  
  // åˆå§‹åŒ–ç”¨æˆ·æƒé™ï¼ˆå®é™…é¡¹ç›®ä»åç«¯è·å–ï¼‰
  async initialize() {
    // æ¨¡æ‹Ÿä»åç«¯è·å–ç”¨æˆ·æƒé™
    this.userPolicies = new Set([
      'Dashboard.View',
      'User.View',
      'User.Create',
      'User.Update'
    ])
  }
  
  // æ£€æŸ¥æƒé™
  hasPolicy(policy: string): boolean {
    if (!policy) return true
    return this.userPolicies.has(policy)
  }
  
  // æ‰¹é‡æ£€æŸ¥æƒé™
  hasAnyPolicy(policies: string[]): boolean {
    return policies.some(p => this.hasPolicy(p))
  }
  
  hasAllPolicies(policies: string[]): boolean {
    return policies.every(p => this.hasPolicy(p))
  }
}

export const security = new SecurityService()

// è®¾ç½®è·¯ç”±å®ˆå«
export async function setupSecurity(router: Router) {
  // åˆå§‹åŒ–å®‰å…¨æœåŠ¡
  await security.initialize()
  
  // å‰ç½®å®ˆå«ï¼šæƒé™æ£€æŸ¥
  router.beforeEach(async (to, from, next) => {
    const policy = to.meta?.policy as string | undefined
    
    if (policy && !security.hasPolicy(policy)) {
      console.warn(`Access denied: Missing policy "${policy}" for route "${to.name}"`)
      next({ name: 'Forbidden' })
      return
    }
    
    next()
  })
  
  // åç½®å®ˆå«ï¼šé¡µé¢æ ‡é¢˜
  router.afterEach((to) => {
    const title = to.meta?.title as string
    if (title) {
      document.title = `${title} - Vue Modular App`
    }
  })
}
```

## Step 4: ä¸»åº”ç”¨å…¥å£

### 4.1 åˆ›å»ºä¸»å…¥å£æ–‡ä»¶

```typescript
// src/main.ts
import { createApp } from 'vue'
import App from './App.vue'
import { bootstrap } from './appshell/boot'

// å…¨å±€æ ·å¼
import './styles/global.css'

// åˆ›å»ºVueåº”ç”¨
const app = createApp(App)

// å…¨å±€é”™è¯¯å¤„ç†
app.config.errorHandler = (err, instance, info) => {
  console.error('Global error:', err, info)
}

// å¯åŠ¨åº”ç”¨
bootstrap(app).catch(error => {
  console.error('Failed to bootstrap application:', error)
})
```

### 4.2 æ ¹ç»„ä»¶

```vue
<!-- src/App.vue -->
<template>
  <div id="app">
    <AppLayout>
      <RouterView v-slot="{ Component, route }">
        <Transition name="fade" mode="out-in">
          <KeepAlive :include="cachedViews">
            <component :is="Component" :key="route.path" />
          </KeepAlive>
        </Transition>
      </RouterView>
    </AppLayout>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import AppLayout from './layouts/AppLayout.vue'

const route = useRoute()

// ç¼“å­˜çš„è§†å›¾ï¼ˆæ ¹æ®è·¯ç”±meta.keepAliveï¼‰
const cachedViews = computed(() => {
  // å®é™…é¡¹ç›®ä¸­ä»è·¯ç”±é…ç½®ä¸­æ”¶é›†éœ€è¦ç¼“å­˜çš„ç»„ä»¶å
  return []
})
</script>

<style>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

### 4.3 å¸ƒå±€ç»„ä»¶

```vue
<!-- src/layouts/AppLayout.vue -->
<template>
  <div class="app-layout">
    <header class="app-header">
      <h1>Vue Modular Application</h1>
      <nav class="app-nav">
        <RouterLink 
          v-for="route in visibleRoutes" 
          :key="route.name"
          :to="route.path"
          class="nav-link"
          active-class="active"
        >
          {{ route.meta?.title || route.name }}
        </RouterLink>
      </nav>
    </header>
    
    <main class="app-main">
      <slot />
    </main>
    
    <footer class="app-footer">
      <p>Â© 2024 Vue Modular Generator - Powered by ABP Style Architecture</p>
    </footer>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

// ç­›é€‰å¯è§è·¯ç”±
const visibleRoutes = computed(() => {
  return router.getRoutes()
    .filter(route => {
      // è¿‡æ»¤éšè—è·¯ç”±å’Œé”™è¯¯é¡µé¢
      return !route.meta?.hidden && 
             route.path !== '/' && 
             !route.path.includes('*') &&
             !route.path.includes('404') &&
             !route.path.includes('403')
    })
    .sort((a, b) => {
      // æŒ‰orderæ’åº
      const orderA = (a.meta?.order as number) ?? 100
      const orderB = (b.meta?.order as number) ?? 100
      return orderA - orderB
    })
})
</script>

<style scoped>
.app-layout {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-header {
  background: #2c3e50;
  color: white;
  padding: 1rem 2rem;
}

.app-header h1 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.app-nav {
  display: flex;
  gap: 1rem;
}

.nav-link {
  color: #ecf0f1;
  text-decoration: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  transition: background 0.3s;
}

.nav-link:hover {
  background: rgba(255, 255, 255, 0.1);
}

.nav-link.active {
  background: #3498db;
}

.app-main {
  flex: 1;
  padding: 2rem;
  background: #ecf0f1;
}

.app-footer {
  background: #34495e;
  color: white;
  padding: 1rem;
  text-align: center;
}

.app-footer p {
  margin: 0;
  font-size: 0.9rem;
}
</style>
```

## Step 5: ç¤ºä¾‹æ¨¡å—å®ç°

### 5.1 åˆ›å»ºUseræ¨¡å—

```json
// src/modules/User/abp.module.json
{
  "name": "User",
  "displayName": "User Management",
  "description": "User management module",
  "version": "1.0.0",
  "abpStyle": true,
  "order": 10,
  "dependsOn": [],
  "routes": [
    {
      "name": "UserList",
      "path": "/users",
      "component": "@/modules/User/views/UserList.vue",
      "meta": {
        "title": "Users",
        "icon": "mdi:account-group",
        "policy": "User.View"
      }
    },
    {
      "name": "UserDetail",
      "path": "/users/:id",
      "component": "@/modules/User/views/UserDetail.vue",
      "meta": {
        "title": "User Detail",
        "hidden": true,
        "policy": "User.View"
      }
    }
  ],
  "stores": [
    {
      "symbol": "useUserStore",
      "id": "user",
      "modulePath": "@/modules/User/stores/user"
    }
  ],
  "policies": [
    "User.View",
    "User.Create",
    "User.Update",
    "User.Delete"
  ],
  "lifecycle": {
    "init": "@/modules/User/lifecycle/init"
  }
}
```

### 5.2 User Storeå®ç°

```typescript
// src/modules/User/stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export interface User {
  id: string
  username: string
  email: string
  fullName: string
  roles: string[]
  isActive: boolean
  createdAt: Date
  updatedAt: Date
}

export const useUserStore = defineStore('user', () => {
  // State
  const users = ref<User[]>([])
  const currentUser = ref<User | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  // Getters
  const userCount = computed(() => users.value.length)
  const activeUsers = computed(() => users.value.filter(u => u.isActive))
  
  // Actions
  async function fetchUsers() {
    loading.value = true
    error.value = null
    
    try {
      // æ¨¡æ‹ŸAPIè°ƒç”¨
      await new Promise(resolve => setTimeout(resolve, 500))
      
      users.value = [
        {
          id: '1',
          username: 'admin',
          email: 'admin@example.com',
          fullName: 'Administrator',
          roles: ['admin'],
          isActive: true,
          createdAt: new Date('2024-01-01'),
          updatedAt: new Date('2024-01-01')
        },
        {
          id: '2',
          username: 'john',
          email: 'john@example.com',
          fullName: 'John Doe',
          roles: ['user'],
          isActive: true,
          createdAt: new Date('2024-01-15'),
          updatedAt: new Date('2024-01-15')
        }
      ]
    } catch (err) {
      error.value = 'Failed to fetch users'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  async function fetchUser(id: string) {
    loading.value = true
    error.value = null
    
    try {
      await new Promise(resolve => setTimeout(resolve, 300))
      currentUser.value = users.value.find(u => u.id === id) || null
      return currentUser.value
    } catch (err) {
      error.value = 'Failed to fetch user'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  async function createUser(userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>) {
    loading.value = true
    error.value = null
    
    try {
      await new Promise(resolve => setTimeout(resolve, 500))
      
      const newUser: User = {
        ...userData,
        id: Date.now().toString(),
        createdAt: new Date(),
        updatedAt: new Date()
      }
      
      users.value.push(newUser)
      return newUser
    } catch (err) {
      error.value = 'Failed to create user'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  async function updateUser(id: string, updates: Partial<User>) {
    loading.value = true
    error.value = null
    
    try {
      await new Promise(resolve => setTimeout(resolve, 500))
      
      const index = users.value.findIndex(u => u.id === id)
      if (index !== -1) {
        users.value[index] = {
          ...users.value[index],
          ...updates,
          updatedAt: new Date()
        }
        return users.value[index]
      }
      
      throw new Error('User not found')
    } catch (err) {
      error.value = 'Failed to update user'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  async function deleteUser(id: string) {
    loading.value = true
    error.value = null
    
    try {
      await new Promise(resolve => setTimeout(resolve, 500))
      
      const index = users.value.findIndex(u => u.id === id)
      if (index !== -1) {
        users.value.splice(index, 1)
        return true
      }
      
      return false
    } catch (err) {
      error.value = 'Failed to delete user'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  function reset() {
    users.value = []
    currentUser.value = null
    loading.value = false
    error.value = null
  }
  
  return {
    // State
    users,
    currentUser,
    loading,
    error,
    // Getters
    userCount,
    activeUsers,
    // Actions
    fetchUsers,
    fetchUser,
    createUser,
    updateUser,
    deleteUser,
    reset
  }
})
```

### 5.3 Userè§†å›¾ç»„ä»¶

```vue
<!-- src/modules/User/views/UserList.vue -->
<template>
  <div class="user-list">
    <div class="page-header">
      <h2>User Management</h2>
      <button @click="handleCreate" class="btn-primary">
        + New User
      </button>
    </div>
    
    <div v-if="store.loading" class="loading">
      Loading users...
    </div>
    
    <div v-else-if="store.error" class="error">
      {{ store.error }}
    </div>
    
    <table v-else class="user-table">
      <thead>
        <tr>
          <th>Username</th>
          <th>Email</th>
          <th>Full Name</th>
          <th>Roles</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="user in store.users" :key="user.id">
          <td>{{ user.username }}</td>
          <td>{{ user.email }}</td>
          <td>{{ user.fullName }}</td>
          <td>{{ user.roles.join(', ') }}</td>
          <td>
            <span :class="['status', user.isActive ? 'active' : 'inactive']">
              {{ user.isActive ? 'Active' : 'Inactive' }}
            </span>
          </td>
          <td>
            <button @click="handleView(user)" class="btn-link">View</button>
            <button @click="handleEdit(user)" class="btn-link">Edit</button>
            <button @click="handleDelete(user)" class="btn-link danger">Delete</button>
          </td>
        </tr>
      </tbody>
    </table>
    
    <div class="summary">
      Total: {{ store.userCount }} users
      ({{ store.activeUsers.length }} active)
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { useUserStore } from '../stores/user'

const router = useRouter()
const store = useUserStore()

onMounted(() => {
  store.fetchUsers()
})

function handleCreate() {
  // Navigate to create user page
  console.log('Create user')
}

function handleView(user: any) {
  router.push({ name: 'UserDetail', params: { id: user.id } })
}

function handleEdit(user: any) {
  console.log('Edit user:', user.id)
}

async function handleDelete(user: any) {
  if (confirm(`Delete user ${user.username}?`)) {
    await store.deleteUser(user.id)
  }
}
</script>

<style scoped>
.user-list {
  background: white;
  border-radius: 8px;
  padding: 20px;
}

.page-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.page-header h2 {
  margin: 0;
}

.btn-primary {
  background: #3498db;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
}

.btn-primary:hover {
  background: #2980b9;
}

.user-table {
  width: 100%;
  border-collapse: collapse;
}

.user-table th,
.user-table td {
  text-align: left;
  padding: 12px;
  border-bottom: 1px solid #ecf0f1;
}

.user-table th {
  background: #f8f9fa;
  font-weight: 600;
}

.status {
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.85rem;
}

.status.active {
  background: #d4edda;
  color: #155724;
}

.status.inactive {
  background: #f8d7da;
  color: #721c24;
}

.btn-link {
  background: none;
  border: none;
  color: #3498db;
  cursor: pointer;
  margin-right: 10px;
}

.btn-link:hover {
  text-decoration: underline;
}

.btn-link.danger {
  color: #e74c3c;
}

.loading,
.error {
  padding: 20px;
  text-align: center;
}

.error {
  color: #e74c3c;
}

.summary {
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid #ecf0f1;
  color: #7f8c8d;
}
</style>
```

## Step 6: æµ‹è¯•å’ŒéªŒè¯

### 6.1 åˆ›å»ºæµ‹è¯•è„šæœ¬

```typescript
// tools/generator/__tests__/generator.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { ManifestSchema } from '../schema'
import { DependencyResolver, ConflictDetector } from '../resolvers'

describe('Generator Tests', () => {
  describe('Schema Validation', () => {
    it('should validate correct manifest', () => {
      const manifest = {
        name: 'TestModule',
        version: '1.0.0',
        routes: [
          {
            name: 'TestRoute',
            path: '/test',
            component: '@/modules/Test/views/Index.vue'
          }
        ],
        stores: [],
        policies: []
      }
      
      expect(() => ManifestSchema.parse(manifest)).not.toThrow()
    })
    
    it('should reject invalid manifest', () => {
      const manifest = {
        name: 'test-module', // Invalid: contains hyphen
        routes: []
      }
      
      expect(() => ManifestSchema.parse(manifest)).toThrow()
    })
  })
  
  describe('Dependency Resolution', () => {
    it('should sort modules by dependency', () => {
      const manifests = [
        {
          name: 'ModuleC',
          dependsOn: ['ModuleB'],
          routes: [],
          stores: [],
          policies: []
        },
        {
          name: 'ModuleB',
          dependsOn: ['ModuleA'],
          routes: [],
          stores: [],
          policies: []
        },
        {
          name: 'ModuleA',
          dependsOn: [],
          routes: [],
          stores: [],
          policies: []
        }
      ]
      
      const resolver = new DependencyResolver(manifests)
      const sorted = resolver.topoSort()
      
      expect(sorted.map(m => m.name)).toEqual(['ModuleA', 'ModuleB', 'ModuleC'])
    })
    
    it('should detect circular dependencies', () => {
      const manifests = [
        {
          name: 'ModuleA',
          dependsOn: ['ModuleB'],
          routes: [],
          stores: [],
          policies: []
        },
        {
          name: 'ModuleB',
          dependsOn: ['ModuleA'],
          routes: [],
          stores: [],
          policies: []
        }
      ]
      
      const resolver = new DependencyResolver(manifests)
      expect(() => resolver.topoSort()).toThrow(/Circular dependency/)
    })
  })
  
  describe('Conflict Detection', () => {
    it('should detect route name conflicts', () => {
      const manifests = [
        {
          name: 'ModuleA',
          routes: [{ name: 'TestRoute', path: '/a', component: '@/a' }],
          stores: [],
          policies: []
        },
        {
          name: 'ModuleB',
          routes: [{ name: 'TestRoute', path: '/b', component: '@/b' }],
          stores: [],
          policies: []
        }
      ]
      
      const detector = new ConflictDetector()
      expect(() => detector.detect(manifests)).toThrow(/Route name/)
    })
    
    it('should detect store id conflicts', () => {
      const manifests = [
        {
          name: 'ModuleA',
          routes: [],
          stores: [{ symbol: 'useTestStore', id: 'test', modulePath: '@/a' }],
          policies: []
        },
        {
          name: 'ModuleB',
          routes: [],
          stores: [{ symbol: 'useOtherStore', id: 'test', modulePath: '@/b' }],
          policies: []
        }
      ]
      
      const detector = new ConflictDetector()
      expect(() => detector.detect(manifests)).toThrow(/Store id/)
    })
  })
})
```

## Step 7: è¿è¡Œå’Œéƒ¨ç½²

### 7.1 åˆ›å»ºå¯åŠ¨è„šæœ¬

```bash
#!/bin/bash
# scripts/setup.sh

echo "ğŸš€ Setting up Vue Modular Generator..."

# Install dependencies
echo "ğŸ“¦ Installing dependencies..."
npm install

# Create initial directories
echo "ğŸ“ Creating directories..."
mkdir -p src/modules
mkdir -p src/views/errors
mkdir -p src/styles

# Create placeholder files
echo "ğŸ“ Creating placeholder files..."

# Dashboard view
cat > src/views/Dashboard.vue << 'EOF'
<template>
  <div class="dashboard">
    <h1>Dashboard</h1>
    <p>Welcome to Vue Modular Application!</p>
  </div>
</template>

<script setup lang="ts">
</script>

<style scoped>
.dashboard {
  padding: 20px;
  background: white;
  border-radius: 8px;
}
</style>
EOF

# 404 page
cat > src/views/errors/404.vue << 'EOF'
<template>
  <div class="error-page">
    <h1>404</h1>
    <p>Page not found</p>
    <RouterLink to="/">Go Home</RouterLink>
  </div>
</template>

<style scoped>
.error-page {
  text-align: center;
  padding: 50px;
}
</style>
EOF

# 403 page
cat > src/views/errors/403.vue << 'EOF'
<template>
  <div class="error-page">
    <h1>403</h1>
    <p>Access Denied</p>
    <RouterLink to="/">Go Home</RouterLink>
  </div>
</template>

<style scoped>
.error-page {
  text-align: center;
  padding: 50px;
}
</style>
EOF

# Global styles
cat > src/styles/global.css << 'EOF'
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  color: #2c3e50;
  background: #f5f5f5;
}

a {
  color: #3498db;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
EOF

# Initial generation
echo "âš™ï¸ Running initial generation..."
npm run gen

echo "âœ… Setup complete! Run 'npm run dev' to start the development server."
```

### 7.2 ä½¿ç”¨è¯´æ˜

~~~markdown
# Vue Modular Generator

## å¿«é€Ÿå¼€å§‹

1. **å®‰è£…ä¾èµ–**
   ```bash
   npm install
~~~

1. **åˆ›å»ºæ–°æ¨¡å—**

   ```bash
   npm run module:create
   ```

2. **å¯åŠ¨å¼€å‘æœåŠ¡å™¨**

   ```bash
   npm run dev:watch
   ```

## å‘½ä»¤è¯´æ˜

- `npm run gen` - ç”Ÿæˆä»£ç 
- `npm run gen:watch` - ç›‘å¬æ–‡ä»¶å˜åŒ–å¹¶è‡ªåŠ¨ç”Ÿæˆ
- `npm run gen:check` - æ£€æŸ¥é…ç½®å†²çª
- `npm run module:create` - äº¤äº’å¼åˆ›å»ºæ–°æ¨¡å—
- `npm run dev` - å¯åŠ¨å¼€å‘æœåŠ¡å™¨
- `npm run dev:watch` - å¯åŠ¨å¼€å‘æœåŠ¡å™¨å¹¶ç›‘å¬å˜åŒ–
- `npm run build` - æ„å»ºç”Ÿäº§ç‰ˆæœ¬
- `npm run test` - è¿è¡Œæµ‹è¯•

## ç›®å½•ç»“æ„

```
project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ appshell/        # åº”ç”¨å¤–å£³ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â”‚   â”œâ”€â”€ modules/         # ä¸šåŠ¡æ¨¡å—
â”‚   â”œâ”€â”€ views/           # ç³»ç»Ÿè§†å›¾
â”‚   â””â”€â”€ styles/          # å…¨å±€æ ·å¼
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ generator/       # ç”Ÿæˆå™¨æ ¸å¿ƒ
â””â”€â”€ package.json
```

## æ¨¡å—å¼€å‘æµç¨‹

1. è¿è¡Œ `npm run module:create` åˆ›å»ºæ¨¡å—
2. åœ¨ç”Ÿæˆçš„æ¨¡å—ç›®å½•ä¸­å¼€å‘ä¸šåŠ¡é€»è¾‘
3. ä¿®æ”¹ `abp.module.json` æ·»åŠ è·¯ç”±ã€Storeç­‰
4. ç”Ÿæˆå™¨è‡ªåŠ¨æ›´æ–°è·¯ç”±å’ŒçŠ¶æ€ç®¡ç†

## æœ€ä½³å®è·µ

- æ¨¡å—åä½¿ç”¨ PascalCase
- è·¯ç”±pathä½¿ç”¨ kebab-case
- Store IDä½¿ç”¨ camelCase
- æƒé™ç­–ç•¥ä½¿ç”¨ç‚¹åˆ†å‘½åï¼ˆModule.Actionï¼‰

```
## æ€»ç»“

æˆ‘ä»¬å®ç°äº†ä¸€ä¸ªå®Œæ•´çš„é…ç½®é©±åŠ¨å‰ç«¯æ¨¡å—åŒ–ç”Ÿæˆå™¨ï¼Œå…·å¤‡ä»¥ä¸‹ç‰¹æ€§ï¼š

### âœ… æ ¸å¿ƒåŠŸèƒ½
1. **æ¨¡å—åŒ–æ¶æ„** - ABPé£æ ¼çš„æ¨¡å—å®šä¹‰å’Œä¾èµ–ç®¡ç†
2. **è‡ªåŠ¨ä»£ç ç”Ÿæˆ** - è·¯ç”±ã€çŠ¶æ€ç®¡ç†ã€ç”Ÿå‘½å‘¨æœŸè‡ªåŠ¨ç”Ÿæˆ
3. **å†²çªæ£€æµ‹** - è·¯ç”±åç§°ã€è·¯å¾„ã€Store IDã€æƒé™ç­–ç•¥å†²çªæ£€æµ‹
4. **ä¾èµ–è§£æ** - æ‹“æ‰‘æ’åºç¡®ä¿æ¨¡å—åŠ è½½é¡ºåº
5. **çƒ­æ›´æ–°** - æ–‡ä»¶ç›‘å¬å’Œè‡ªåŠ¨é‡æ–°ç”Ÿæˆ
6. **CLIå·¥å…·** - äº¤äº’å¼æ¨¡å—åˆ›å»ºå‘½ä»¤

### âœ… å¼€å‘ä½“éªŒ
- TypeScriptå…¨ç¨‹ç±»å‹å®‰å…¨
- æ¨¡å—æ¨¡æ¿è‡ªåŠ¨ç”Ÿæˆ
- æ¸…æ™°çš„é”™è¯¯æç¤º
- å®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸé’©å­

### âœ… å¯æ‰©å±•æ€§
- æ’ä»¶åŒ–æ¶æ„è®¾è®¡
- æ¸…æ™°çš„ä»£ç ç»„ç»‡
- æ˜“äºæ·»åŠ æ–°åŠŸèƒ½

è¿™ä¸ªç³»ç»Ÿå·²ç»å¯ä»¥ç›´æ¥æŠ•å…¥ä½¿ç”¨ï¼Œæ‚¨å¯ä»¥é€šè¿‡è¿è¡Œä¸Šè¿°å‘½ä»¤å¿«é€Ÿåˆ›å»ºå’Œç®¡ç†å‰ç«¯æ¨¡å—ï¼Œå®ç°çœŸæ­£çš„ä½ä»£ç å¼€å‘ä½“éªŒã€‚
```

# ç¬¬äºŒç« ï¼šè®¾è®¡æ¨¡å¼å’Œç®—æ³•çš„ä¼˜åŒ–

> [!NOTE]
>
> æ€è€ƒè¿‡ç¨‹ï¼š
>
> *å¥½ï¼Œå…ˆä»ç”¨æˆ·çš„éœ€æ±‚åˆ†æå…¥æ‰‹ã€‚ä»–æå‡ºçš„è¦æ±‚éå¸¸æ˜ç¡®ï¼Œå¸Œæœ›æˆ‘å¯¹æ–‡æ¡£ä¸­çš„ä½ä»£ç /æ— ä»£ç æŠ€æœ¯æ–¹æ¡ˆè¿›è¡Œæ¶æ„çº§çš„åˆ†æä¸å®Œå–„ï¼ŒåŒæ—¶è¿˜éœ€è¦é’ˆå¯¹æ–‡æ¡£ä¸­çš„å®ç°ä»£ç ï¼Œä»æ•°æ®ç»“æ„ã€è®¾è®¡æ¨¡å¼å’Œç®—æ³•çš„è§’åº¦æå‡ºä¸“å®¶çº§ä¼˜åŒ–æ–¹æ¡ˆã€‚ä»–æåˆ°"ä¸šç•Œæœ€é¡¶å°–"å’Œ"å¾®è½¯.NETä¼ä¸šçº§åº”ç”¨åäººå ‚æˆå‘˜"ï¼Œè¿™è®©æˆ‘æ„ŸçŸ¥åˆ°ç”¨æˆ·éœ€è¦çš„æ˜¯ä¸€ç§çœŸæ­£ä¸“ä¸šã€æ·±å…¥çš„åˆ†æã€‚å¹¶ä¸æ˜¯ç®€å•çš„æ”¹æ”¹ä»£ç æˆ–æ³›æ³›è€Œè°ˆï¼Œè€Œæ˜¯è¦ä»æ¶æ„è®¾è®¡çš„æ•´ä½“è§†è§’å‡ºå‘ï¼Œæ‰¾åˆ°æ”¹è¿›çš„æŠ€æœ¯æ–¹å‘ï¼ŒåŒæ—¶ç»™å‡ºå…·ä½“çš„ä¼˜åŒ–å®ç°ã€‚*
>
> *ç¬¬ä¸€æ­¥ï¼Œæˆ‘å¼€å§‹åˆ†æç”¨æˆ·æä¾›çš„ä»£ç å’Œæ–¹æ¡ˆã€‚è¿™äº›å®ç°ä¸­ï¼Œä½ä»£ç çš„æ ¸å¿ƒæ€æƒ³å·²ç»éå¸¸æ¸…æ™°ï¼šé€šè¿‡æ¨¡å—æ¸…å•ï¼ˆmanifestï¼‰å®šä¹‰ä¸šåŠ¡æ¨¡å—çš„ç»“æ„ï¼Œç»“åˆç”Ÿæˆå™¨è‡ªåŠ¨ç”Ÿæˆè·¯ç”±ã€çŠ¶æ€ç®¡ç†ä»£ç ï¼ŒåŒæ—¶ä¿è¯æ¨¡å—é—´çš„ä¾èµ–å…³ç³»å’Œå†²çªæ£€æµ‹ã€‚è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„é…ç½®é©±åŠ¨æ¶æ„ï¼Œä½†æˆ‘æ³¨æ„åˆ°ï¼ŒæŸäº›åœ°æ–¹ä»æœ‰æå‡ç©ºé—´ï¼Œæ¯”å¦‚æ¨¡å—çš„åŠ¨æ€åŠ è½½èƒ½åŠ›ã€å¤æ‚ä¸šåŠ¡çŠ¶æ€çš„ç®¡ç†ã€ä»¥åŠä»£ç ç”Ÿæˆæ•ˆç‡çš„ä¼˜åŒ–ã€‚*
>
> *æˆ‘å…ˆä»æ•°æ®ç»“æ„å…¥æ‰‹ã€‚ç°æœ‰çš„æ¨¡å—æ¸…å•è®¾è®¡ä¸­ï¼Œè·¯ç”±ã€çŠ¶æ€ã€ç”Ÿå‘½å‘¨æœŸé’©å­ç­‰åŠŸèƒ½å·²ç»è¢«æ¸…æ™°åˆ†è§£ï¼Œä½†æ¨¡å—é—´çš„å…³ç³»å’Œæ‰©å±•æ€§ä¼¼ä¹å¹¶æ²¡æœ‰å®Œå…¨è€ƒè™‘åˆ°ã€‚æˆ‘æ„è¯†åˆ°ï¼Œå¯ä»¥å¼•å…¥å›¾ç»“æ„æ¥æ›´ç²¾ç¡®åœ°è¡¨ç¤ºæ¨¡å—é—´çš„ä¾èµ–å…³ç³»ã€‚è¿™æ ·åœ¨ä¾èµ–è§£æå’Œæ‹“æ‰‘æ’åºæ—¶ï¼Œä¸ä»…æ•ˆç‡ä¼šæ›´é«˜ï¼Œè¿˜èƒ½æ›´å¥½åœ°æ”¯æŒæ¨¡å—çš„åŠ¨æ€åŠ è½½å’Œå¸è½½ã€‚æ­¤åˆ»æˆ‘æœ‰ç‚¹å…´å¥‹ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªæ˜æ˜¾çš„æ”¹è¿›ç‚¹ã€‚*
>
> *ç„¶åæ˜¯è®¾è®¡æ¨¡å¼ã€‚ç°æœ‰çš„ä»£ç ç”Ÿæˆå™¨ä¸»è¦æ˜¯ç›´æ¥æ“ä½œæ–‡ä»¶ç³»ç»Ÿæ¥ç”Ÿæˆä»£ç ï¼Œè¿™è™½ç„¶ç®€å•ï¼Œä½†æ‰©å±•æ€§å’Œçµæ´»æ€§è¾ƒä½ã€‚æˆ‘è§‰å¾—å¯ä»¥å¼•å…¥æ¨¡æ¿å¼•æ“ï¼ˆæ¯”å¦‚Velocityæˆ–Razorï¼‰ç»“åˆç­–ç•¥æ¨¡å¼ï¼Œå°†ä»£ç ç”Ÿæˆçš„è¿‡ç¨‹è§£è€¦ä¸ºæ¨¡æ¿é€‰æ‹©å’Œå†…å®¹å¡«å……ä¸¤ä¸ªé˜¶æ®µã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œå¯ä»¥æ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€å’Œæ¡†æ¶çš„è¾“å‡ºï¼ŒåŒæ—¶è®©ä¸šåŠ¡é€»è¾‘ä¸“æ³¨äºç”Ÿæˆè§„åˆ™çš„å®šä¹‰ï¼Œè€Œä¸æ˜¯å…·ä½“ä»£ç çš„å†™å…¥ã€‚*
>
> *åœ¨ç®—æ³•ä¼˜åŒ–æ–¹é¢ï¼Œæˆ‘åå¤æ€è€ƒå†²çªæ£€æµ‹çš„å®ç°ã€‚ç°æœ‰çš„å†²çªæ£€æµ‹æ˜¯åŸºäºå…¨é‡æ‰«æçš„ï¼Œè¿™åœ¨æ¨¡å—æ•°é‡è¾ƒå°‘æ—¶æ²¡æœ‰é—®é¢˜ï¼Œä½†éšç€æ¨¡å—æ•°é‡çš„å¢åŠ ï¼Œæ€§èƒ½ç“¶é¢ˆä¼šæ˜¾ç°ã€‚æˆ‘æƒ³åˆ°äº†å¸ƒéš†è¿‡æ»¤å™¨å¯ä»¥ä½œä¸ºä¸€ç§å¿«é€Ÿæ ¡éªŒæ‰‹æ®µï¼Œå…ˆç­›é€‰æ‰ä¸å¯èƒ½å†²çªçš„æ¨¡å—ï¼Œå†å¯¹ç–‘ä¼¼å†²çªçš„æ¨¡å—è¿›è¡Œç²¾ç¡®æ£€æŸ¥ã€‚è¿™èƒ½å¤§å¹…åº¦é™ä½ç®—æ³•å¤æ‚åº¦ï¼ŒåŒæ—¶ä¿è¯æ£€æµ‹çš„å‡†ç¡®æ€§ã€‚*
>
> *æ¥ç€ï¼Œæˆ‘å¼€å§‹æ€è€ƒå¦‚ä½•éªŒè¯è¿™äº›æ”¹è¿›çš„å®é™…æ•ˆæœã€‚æˆ‘éœ€è¦ä¸€ä¸ªåœºæ™¯æ¥æ¨¡æ‹Ÿæ¨¡å—æ•°é‡çš„å¢é•¿ï¼ˆæ¯”å¦‚ä»å‡ åä¸ªæ¨¡å—åˆ°å‡ ç™¾ä¸ªæ¨¡å—ï¼‰ï¼Œå¹¶å¯¹æ¯”æ”¹è¿›å‰åçš„ç”Ÿæˆæ—¶é—´ã€å†…å­˜å ç”¨å’Œå†²çªæ£€æµ‹å‘½ä¸­ç‡ã€‚æˆ‘å†³å®šç”¨ä¸€ä¸ªå®éªŒæ€§çš„å®ç°æ¥éªŒè¯è¿™äº›æƒ³æ³•æ˜¯å¦å¯è¡Œã€‚æˆ‘æ‰“ç®—å…ˆå®ç°ä¸€ä¸ªç®€å•çš„æ¨¡å—ä¾èµ–å›¾ç»“æ„ï¼Œå†å®ç°åŸºäºå¸ƒéš†è¿‡æ»¤å™¨çš„å†²çªæ£€æµ‹ä¼˜åŒ–ï¼Œæœ€åå°†æ¨¡æ¿å¼•æ“é›†æˆåˆ°ç”Ÿæˆå™¨ä¸­ã€‚é€šè¿‡å•å…ƒæµ‹è¯•å’Œæ€§èƒ½æµ‹è¯•ï¼Œæˆ‘å¯ä»¥éªŒè¯è¿™äº›æ”¹è¿›æ˜¯å¦çœŸæ­£èƒ½æå‡ç³»ç»Ÿè¡¨ç°ã€‚*
>
> *æœ€åï¼Œæˆ‘åœ¨å‡†å¤‡å›å¤ç”¨æˆ·æ—¶ï¼Œå†³å®šä»¥ä¸€ç§å±‚æ¬¡åˆ†æ˜çš„é€»è¾‘ç»“æ„æ¥å‘ˆç°æˆ‘çš„åˆ†æï¼šå…ˆä»æ¶æ„å±‚é¢åˆ†æç°æœ‰æ–¹æ¡ˆçš„ä¼˜ç‚¹å’Œä¸è¶³ï¼Œå†é€æ­¥å±•å¼€æ•°æ®ç»“æ„ã€è®¾è®¡æ¨¡å¼å’Œç®—æ³•çš„å…·ä½“ä¼˜åŒ–æ–¹æ¡ˆã€‚åŒæ—¶ï¼Œæˆ‘ä¼šåœ¨å›å¤ä¸­æä¾›æ”¹è¿›åçš„ä»£ç ç‰‡æ®µå’Œå…³é”®å®ç°ç»†èŠ‚ï¼Œä»¥ä¾¿ç”¨æˆ·èƒ½å¤Ÿç›´æ¥ç†è§£å’Œåº”ç”¨è¿™äº›å»ºè®®ã€‚æˆ‘ä¼šç”¨ä¸€ç§ä¸“ä¸šä½†ä¸å¤±æ¸…æ™°çš„è¯­æ°”ç»„ç»‡æˆ‘çš„å›å¤ï¼Œå› ä¸ºç”¨æˆ·æ˜¾ç„¶å¸Œæœ›çœ‹åˆ°çš„æ˜¯ä¸€ä¸ªå¯é ä¸”æ˜“äºå®è·µçš„æ–¹æ¡ˆã€‚*



# ä½ä»£ç æŠ€æœ¯æ–¹æ¡ˆçš„æ¶æ„åˆ†æä¸å®Œå–„

ä»æ¶æ„è§†è§’çœ‹ï¼Œè¿™å¥—ä½ä»£ç æ–¹æ¡ˆå·²ç»å…·å¤‡äº†æ¨¡å—åŒ–ã€é…ç½®é©±åŠ¨å’Œè‡ªåŠ¨åŒ–ç”Ÿæˆç­‰å…ˆè¿›ç‰¹æ€§ï¼Œå……åˆ†ä½“ç°äº†ç°ä»£å‰ç«¯å·¥ç¨‹åŒ–æ€æƒ³ã€‚ä»¥ä¸‹æ˜¯æˆ‘çš„åˆ†æä¸å®Œå–„å»ºè®®ï¼š

## ä¸€ã€æ¶æ„åˆ†æ

### 1. æ ¸å¿ƒä¼˜åŠ¿
- **æ¨¡å—åŒ–è§£è€¦**ï¼šé€šè¿‡ABPé£æ ¼çš„æ¨¡å—æ¸…å•å®ç°äº†çœŸæ­£çš„å‰ç«¯æ¨¡å—åŒ–ï¼Œæ¨¡å—é—´çš„ä¾èµ–å…³ç³»æ¸…æ™°å¯è§
- **é…ç½®é©±åŠ¨å¼€å‘**ï¼šé‡‡ç”¨Manifesté…ç½®æ–‡ä»¶ä½œä¸ºå¼€å‘çš„æ ¸å¿ƒå¥‘çº¦ï¼Œæå¤§é™ä½äº†å¼€å‘å¤æ‚åº¦
- **è‡ªåŠ¨åŒ–èƒ½åŠ›**ï¼šå®ç°äº†ä»é…ç½®åˆ°ä»£ç çš„è‡ªåŠ¨åŒ–æµè½¬ï¼ŒåŒ…æ‹¬è·¯ç”±ã€çŠ¶æ€ç®¡ç†ç­‰æ ¸å¿ƒåŠŸèƒ½çš„è‡ªåŠ¨ç”Ÿæˆ
- **å†²çªç®¡ç†**ï¼šåœ¨è·¯ç”±ã€çŠ¶æ€IDã€æƒé™ç­–ç•¥ç­‰æ–¹é¢è®¾è®¡äº†å®Œå–„çš„å†²çªæ£€æµ‹æœºåˆ¶
- **å¼€å‘ä½“éªŒ**ï¼šæä¾›äº†çƒ­æ›´æ–°ã€ CLIå·¥å…·ç­‰æå‡å¼€å‘æ•ˆç‡çš„åŠŸèƒ½

### 2. æ¶æ„å®Œå–„å»ºè®®

### ï¼ˆ1ï¼‰å¼•å…¥æ¨¡å—èƒ½åŠ›å¥‘çº¦
åœ¨`ManifestSchema`ä¸­å¢åŠ æ¨¡å—èƒ½åŠ›å£°æ˜éƒ¨åˆ†ï¼Œå®šä¹‰æ¨¡å—å¯¹å¤–æä¾›çš„æœåŠ¡å¥‘çº¦ï¼š

```typescript
// tools/generator/schema.ts
export const ManifestSchema = z.object({
  // ...åŸæœ‰å®šä¹‰
  capabilities: z.object({
    apis: z.array(z.string()).default([]),       // å¯¹å¤–æä¾›çš„APIæ¥å£
    events: z.array(z.string()).default([]),     // å¯¹å¤–å‘å¸ƒçš„äº‹ä»¶
    dependencies: z.array(z.string()).default([])// æ¶ˆè´¹çš„å¤–éƒ¨æœåŠ¡
  }).optional()
})
```

### ï¼ˆ2ï¼‰æ„å»ºæ¨¡å—ä¾èµ–å›¾è°±
åœ¨ä¾èµ–è§£æé˜¶æ®µæ„å»ºå®Œæ•´çš„æ¨¡å—ä¾èµ–å›¾è°±ï¼Œæ”¯æŒå¤šç§è§£æç­–ç•¥ï¼š

```typescript
// tools/generator/resolvers.ts
export class ModuleGraph {
  private graph: Map<string, Set<string>> = new Map();
  private reverseGraph: Map<string, Set<string>> = new Map();

  buildGraph(manifests: Manifest[]): void {
    manifests.forEach(manifest => {
      this.graph.set(manifest.name, new Set(manifest.dependsOn || []));
      
      (manifest.dependsOn || []).forEach(dep => {
        if (!this.reverseGraph.has(dep)) {
          this.reverseGraph.set(dep, new Set());
        }
        this.reverseGraph.get(dep)!.add(manifest.name);
      });
    });
  }

  getDependents(moduleName: string): Set<string> {
    return this.reverseGraph.get(moduleName) || new Set();
  }

  getDependencies(moduleName: string): Set<string> {
    return this.graph.get(moduleName) || new Set();
  }
}
```

## äºŒã€æ•°æ®ç»“æ„ä¼˜åŒ–

### 1. æ·»åŠ æ¨¡å—ç‰ˆæœ¬é“¾è¡¨
å»ºè®®ä¸ºæ¨¡å—æ·»åŠ ç‰ˆæœ¬é“¾è¡¨ç»“æ„ï¼Œæ”¯æŒæ¨¡å—çš„å¹³æ»‘å‡çº§ä¸ç‰ˆæœ¬è¿½æº¯ï¼š

```typescript
interface ModuleVersionNode {
  version: string;
  upgradePath: string[]; // å‡çº§è·¯å¾„è¯´æ˜
  breakingChanges: string[]; // ç ´åæ€§å˜æ›´è¯´æ˜
  next: ModuleVersionNode | null;
}

interface EnhancedManifest extends Manifest {
  versionHistory: ModuleVersionNode | null;
}
```

### 2. å®ç°æ¨¡å—çŠ¶æ€æœº
å¼•å…¥çŠ¶æ€æ¨¡å¼ç®¡ç†æ¨¡å—çš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ï¼š

```typescript
enum ModuleState {
  Defined = 'defined',
  Registered = 'registered',
  Initialized = 'initialized',
  Loaded = 'loaded',
  Unloaded = 'unloaded'
}

class ModuleStateManager {
  private currentState: ModuleState = ModuleState.Defined;
  
  transitionTo(state: ModuleState): void {
    if (this.canTransitionTo(state)) {
      this.currentState = state;
      this.invokeStateHooks(state);
    } else {
      throw new Error(`Invalid state transition: ${this.currentState} -> ${state}`);
    }
  }
  
  private canTransitionTo(state: ModuleState): boolean {
    // å®šä¹‰çŠ¶æ€è½¬ç§»çŸ©é˜µ
    const transitionMatrix: Record<ModuleState, Set<ModuleState>> = {
      [ModuleState.Defined]: new Set([ModuleState.Registered]),
      [ModuleState.Registered]: new Set([ModuleState.Initialized]),
      [ModuleState.Initialized]: new Set([ModuleState.Loaded]),
      [ModuleState.Loaded]: new Set([ModuleState.Unloaded]),
      [ModuleState.Unloaded]: new Set()
    };
    
    return transitionMatrix[this.currentState].has(state);
  }
}
```

## ä¸‰ã€è®¾è®¡æ¨¡å¼åº”ç”¨

### 1. ç­–ç•¥æ¨¡å¼ä¼˜åŒ–ç”Ÿæˆå™¨
å°†ä»£ç ç”Ÿæˆé€»è¾‘æŠ½è±¡ä¸ºç­–ç•¥æ¥å£ï¼Œæ”¯æŒå¤šç§ç”Ÿæˆæ–¹å¼ï¼š

```typescript
interface IGenerationStrategy {
  generateRoutes(manifests: Manifest[]): string;
  generateStores(manifests: Manifest[]): string;
  generateLifecycles(manifests: Manifest[]): string;
}

class DefaultGenerationStrategy implements IGenerationStrategy {
  // å®ç°é»˜è®¤ç”Ÿæˆé€»è¾‘
}

class EnhancedGenerationStrategy implements IGenerationStrategy {
  // å®ç°å¢å¼ºç”Ÿæˆé€»è¾‘ï¼Œå¦‚æ”¯æŒå¤šæ¡†æ¶è¾“å‡º
}

class CodeGenerator {
  private strategy: IGenerationStrategy;
  
  constructor(strategy: IGenerationStrategy = new DefaultGenerationStrategy()) {
    this.strategy = strategy;
  }
  
  setGenerationStrategy(strategy: IGenerationStrategy): void {
    this.strategy = strategy;
  }
  
  generateAll(manifests: Manifest[]): void {
    this.strategy.generateRoutes(manifests);
    this.strategy.generateStores(manifests);
    this.strategy.generateLifecycles(manifests);
  }
}
```

### 2. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ä¼˜åŒ–ç”Ÿå‘½å‘¨æœŸç®¡ç†
è§„èŒƒç”Ÿå‘½å‘¨æœŸé’©å­çš„æ‰§è¡Œæµç¨‹ï¼š

```typescript
abstract class LifecycleManager {
  abstract preInit(ctx: any): void;
  abstract init(ctx: any): void;
  abstract postInit(ctx: any): void;
  
  executeLifecycle(ctx: any): void {
    this.preInit(ctx);
    this.init(ctx);
    this.postInit(ctx);
  }
}

class VueLifecycleManager extends LifecycleManager {
  preInit(ctx: any): void {
    console.log("Vue module pre-initializing...");
    // Vueç‰¹å®šçš„é¢„åˆå§‹åŒ–é€»è¾‘
  }
  
  init(ctx: any): void {
    console.log("Vue module initializing...");
    // Vueæ ¸å¿ƒåˆå§‹åŒ–é€»è¾‘
  }
  
  postInit(ctx: any): void {
    console.log("Vue module post-initializing...");
    // Vueåç»­åˆå§‹åŒ–é€»è¾‘
  }
}
```

## å››ã€ç®—æ³•ä¼˜åŒ–

### 1. å†²çªæ£€æµ‹ç®—æ³•å¢å¼º
å¼•å…¥å¸ƒéš†è¿‡æ»¤å™¨è¿›è¡Œå¿«é€Ÿå†²çªæ ¡éªŒï¼š

```typescript
class BloomFilterConflictDetector {
  private bloomFilter: BloomFilter = new BloomFilter(1000, 0.001);
  
  initialize(manifests: Manifest[]): void {
    manifests.forEach(manifest => {
      manifest.routes.forEach(route => this.bloomFilter.add(route.name));
      manifest.stores.forEach(store => this.bloomFilter.add(store.id));
      manifest.policies.forEach(policy => this.bloomFilter.add(policy));
    });
  }
  
  mayHaveConflict(resourceName: string): boolean {
    return this.bloomFilter.mightContain(resourceName);
  }
  
  exactConflictCheck(manifests: Manifest[]): void {
    // å¯¹å¯èƒ½å†²çªçš„èµ„æºè¿›è¡Œç²¾ç¡®æ£€æŸ¥
  }
}
```

### 2. ä¾èµ–è§£æç®—æ³•ä¼˜åŒ–
é‡‡ç”¨æ”¹è¿›çš„Kahnç®—æ³•è¿›è¡Œä¾èµ–æ’åºï¼Œæ”¯æŒå¹¶è¡ŒåŠ è½½æ£€æµ‹ï¼š

```typescript
class EnhancedDependencyResolver {
  private indegreeMap: Map<string, number> = new Map();
  private adjacencyMap: Map<string, Set<string>> = new Map();
  private parallelGroups: Set<Set<string>> = new Set();
  
  private buildGraph(manifests: Manifest[]): void {
    manifests.forEach(manifest => {
      this.indegreeMap.set(manifest.name, 0);
      
      (manifest.dependsOn || []).forEach(dep => {
        if (!this.indegreeMap.has(dep)) this.indegreeMap.set(dep, 0);
        if (!this.adjacencyMap.has(dep)) this.adjacencyMap.set(dep, new Set());
        
        this.indegreeMap.set(manifest.name, this.indegreeMap.get(manifest.name)! + 1);
        this.adjacencyMap.get(dep)!.add(manifest.name);
      });
    });
    
    this.identifyParallelGroups();
  }
  
  private identifyParallelGroups(): void {
    // è¯†åˆ«å¯ä»¥å¹¶è¡ŒåŠ è½½çš„æ¨¡å—ç»„
  }
  
  getLoadingOrder(): string[][] {
    // è¿”å›æ¨¡å—çš„å¹¶è¡ŒåŠ è½½é¡ºåº
  }
}
```

## äº”ã€éåŠŸèƒ½æ€§ä¼˜åŒ–

### 1. æ€§èƒ½ç›‘æµ‹ä¸­é—´ä»¶
æ·»åŠ æ€§èƒ½ç›‘æµ‹èƒ½åŠ›ï¼Œæ–¹ä¾¿åˆ†æç”Ÿæˆå™¨ç“¶é¢ˆï¼š

```typescript
class PerformanceMonitor {
  private timers: Map<string, [number, number]> = new Map();
  
  startTimer(name: string): void {
    this.timers.set(name, [performance.now(), 0]);
  }
  
  stopTimer(name: string): void {
    const [start, elapsed] = this.timers.get(name)!;
    this.timers.set(name, [start, performance.now() - start]);
  }
  
  getPerformanceReport(): Record<string, number> {
    return Object.fromEntries(
      Array.from(this.timers.entries()).map(([name, [, duration]]) => [name, duration])
    );
  }
}

// åœ¨ç”Ÿæˆå™¨ä¸­ä½¿ç”¨
const monitor = new PerformanceMonitor();
monitor.startTimer('generationTotal');

// å„é˜¶æ®µæ·»åŠ æ€§èƒ½ç›‘æµ‹ç‚¹
monitor.startTimer('schemaValidation');
// éªŒè¯é€»è¾‘
monitor.stopTimer('schemaValidation');

monitor.startTimer('dependencyResolution');
// ä¾èµ–è§£æé€»è¾‘
monitor.stopTimer('dependencyResolution');

monitor.stopTimer('generationTotal');
console.log('Generation Performance:', monitor.getPerformanceReport());
```

### 2. æ™ºèƒ½ç¼“å­˜ç­–ç•¥
å®ç°ç”Ÿæˆç»“æœçš„æ™ºèƒ½ç¼“å­˜ï¼Œå‡å°‘é‡å¤ç”Ÿæˆï¼š

```typescript
class SmartCache {
  private cacheStorage: Map<string, { content: string; version: string }> = new Map();
  private versionStorage: Map<string, string> = new Map();
  
  getFromCache(moduleName: string, version: string): string | null {
    if (this.cacheStorage.has(moduleName) && 
        this.versionStorage.get(moduleName) === version) {
      return this.cacheStorage.get(moduleName)!.content;
    }
    
    return null;
  }
  
  storeInCache(moduleName: string, version: string, content: string): void {
    this.cacheStorage.set(moduleName, { content, version });
    this.versionStorage.set(moduleName, version);
  }
  
  invalidateCache(moduleName?: string): void {
    if (moduleName) {
      this.cacheStorage.delete(moduleName);
      this.versionStorage.delete(moduleName);
    } else {
      this.cacheStorage.clear();
      this.versionStorage.clear();
    }
  }
}
```

### 3. å¢é‡æ›´æ–°ç®—æ³•
å®ç°åŸºäºå·®å¼‚çš„å¢é‡æ›´æ–°æœºåˆ¶ï¼š

```typescript
class IncrementalUpdater {
  private lastGeneratedState: Record<string, string> = {};
  
  updateOnlyChanged(manifests: Manifest[]): void {
    const currentManifestHashes = this.calculateManifestHashes(manifests);
    
    manifests.forEach(manifest => {
      if (this.lastGeneratedState[manifest.name] !== currentManifestHashes[manifest.name]) {
        // æ‰§è¡Œå¢é‡æ›´æ–°
        console.log(`Incrementally updating module: ${manifest.name}`);
        
        // æ›´æ–°æ¨¡å—å¯¹åº”çš„ä»£ç ç‰‡æ®µ
        
        this.lastGeneratedState[manifest.name] = currentManifestHashes[manifest.name];
      }
    });
  }
  
  private calculateManifestHashes(manifests: Manifest[]): Record<string, string> {
    return manifests.reduce((acc, manifest) => {
      acc[manifest.name] = this.calculateHash(JSON.stringify(manifest));
      return acc;
    }, {} as Record<string, string>);
  }
  
  private calculateHash(data: string): string {
    // å®ç°å“ˆå¸Œè®¡ç®—é€»è¾‘
    return crypto.createHash('sha256').update(data).digest('hex');
  }
}
```

ä»¥ä¸Šä¼˜åŒ–æ–¹æ¡ˆä»ä¸šåŠ¡æ¶æ„ã€æ•°æ®ç»“æ„ã€è®¾è®¡æ¨¡å¼å’Œç®—æ³•ç­‰å¤šç»´åº¦å¯¹åŸæ–¹æ¡ˆè¿›è¡Œäº†å®Œå–„ï¼Œä½¿ç³»ç»Ÿåœ¨æ‰©å±•æ€§ã€æ€§èƒ½ã€å¯ç»´æŠ¤æ€§å’Œå¼€å‘ä½“éªŒç­‰æ–¹é¢éƒ½æœ‰æ˜¾è‘—æå‡ï¼Œæ›´åŠ ç¬¦åˆä¼ä¸šçº§åº”ç”¨çš„é«˜æ ‡å‡†è¦æ±‚ã€‚



# ç¬¬ä¸‰ç« ï¼šæ•°æ®ç»“æ„å’Œå†…å­˜çš„ä¼˜åŒ–

> [!NOTE]
>
> *æ€è€ƒè¿‡ç¨‹ï¼š*
>
> *ç”¨æˆ·å¸Œæœ›æˆ‘ä»ä¸šåŠ¡æ¶æ„ã€è®¾è®¡æ¨¡å¼ã€æ•°æ®ç»“æ„ã€ç®—æ³•ç­‰å±‚é¢åˆ†æå¹¶ä¼˜åŒ–ä½ä»£ç å¹³å°çš„æŠ€æœ¯æ–¹æ¡ˆï¼ŒåŒæ—¶ç‰¹åˆ«æåˆ°è¦æ·±æŒ–ç”Ÿæˆå™¨æ ¸å¿ƒå¯¹è±¡çš„æ•°æ®ç»“æ„è®¾è®¡ã€å†…å­˜ç®¡ç†ä»¥åŠç³»ç»Ÿçš„å¯é æ€§ã€‚è¿™äº›éœ€æ±‚ä¸­ï¼Œæˆ‘æ„Ÿå—åˆ°ç”¨æˆ·ä¸ä»…éœ€è¦ä¸€ä¸ªèƒ½è¿è¡Œçš„ä½ä»£ç ç³»ç»Ÿï¼Œè¿˜éœ€è¦ä¸€ä¸ªåœ¨æ€§èƒ½ã€ç¨³å®šæ€§ã€å¯æ‰©å±•æ€§ç­‰æ›´é«˜å±‚é¢å…·å¤‡ç«äº‰åŠ›çš„æ¶æ„è®¾è®¡ã€‚*
>
> *é¦–å…ˆï¼Œæˆ‘å…ˆæ¢³ç†ç”¨æˆ·å…³å¿ƒçš„å‡ ä¸ªæ–¹é¢ï¼šæ ¸å¿ƒå¯¹è±¡çš„è®¾è®¡æ˜¯å¦æ»¡è¶³æ‰©å±•æ€§éœ€æ±‚ï¼Ÿå†…å­˜ç®¡ç†æ˜¯å¦å­˜åœ¨æµªè´¹æˆ–æ³„æ¼ï¼Ÿç³»ç»Ÿå¯é æ€§æ˜¯å¦èƒ½åº”å¯¹ä¼ä¸šçº§å¼€å‘ç¯å¢ƒä¸­çš„å¤æ‚éœ€æ±‚ï¼Ÿè¿™äº›æ ¸å¿ƒç‚¹è®©æˆ‘æ„è¯†åˆ°ï¼Œä¹‹å‰çš„æ–¹æ¡ˆè™½ç„¶åŠŸèƒ½é½å…¨ï¼Œä½†å¯èƒ½åœ¨æ•°æ®ç»“æ„çš„ç²¾ç‚¼æ€§ã€çŠ¶æ€ç®¡ç†çš„å¯é æ€§ã€èµ„æºé‡Šæ”¾æœºåˆ¶çš„ä¸¥è°¨æ€§ç­‰æ–¹é¢è¿˜æœ‰æ”¹è¿›ç©ºé—´ã€‚*
>
> *ç„¶åï¼Œæˆ‘å¼€å§‹å°è¯•ç”¨æ¨¡å—åŒ–æ€ç»´æ¥è¿›è¡Œåˆ†æï¼Œå…ˆä»æ ¸å¿ƒç”Ÿæˆå™¨å…¥æ‰‹ã€‚ç”Ÿæˆå™¨æ˜¯è¿™å¥—ä½ä»£ç æ–¹æ¡ˆçš„æ ¸å¿ƒï¼Œå®ƒéœ€è¦å¤„ç†å¤§é‡çš„æ¨¡å—æ¸…å•å’Œé…ç½®ï¼Œè¿˜è¦é«˜æ•ˆåœ°è§£æè¿™äº›ä¿¡æ¯å¹¶ç”Ÿæˆä»£ç ã€‚æˆ‘å›å¿†åˆ°ä¹‹å‰è®¾è®¡ç”Ÿæˆå™¨æ—¶ï¼Œé‡‡ç”¨çš„æ˜¯ç›´æ¥æ“ä½œæ¨¡å—æ¸…å•æ•°æ®çš„æ¨¡å¼ï¼Œè¿™æ ·çš„å®ç°è™½ç„¶åŠŸèƒ½ä¸Šå¯è¡Œï¼Œä½†åœ¨å†…å­˜ç®¡ç†å’Œæ‰©å±•æ€§ä¸Šç¨æ˜¾æ¾æ•£ã€‚å¦‚æœæ¨¡å—æ•°é‡å¢å¤šï¼Œå¯èƒ½ä¼šå¯¼è‡´åƒåœ¾æ•°æ®ç´¯ç§¯æˆ–è€…å†²çªæ£€æµ‹æ•ˆç‡é™ä½ã€‚*
>
> *æˆ‘æƒ³åˆ°ä¸¤ç§ä¼˜åŒ–æ–¹å¼ï¼šä¸€ç§æ˜¯å°†æ¨¡å—çŠ¶æ€å’Œç”Ÿæˆé€»è¾‘åˆ†ç¦»ï¼Œé€šè¿‡å¼•å…¥çŠ¶æ€æœºæ¥ç®¡ç†æ¨¡å—çš„åŠ è½½ã€ç”Ÿæˆã€æ›´æ–°å’Œå¸è½½çŠ¶æ€ï¼›å¦ä¸€ç§æ˜¯ä¸ºæ¨¡å—å¼•å…¥æ•°æ®ç‰ˆæœ¬åŒ–æœºåˆ¶ï¼Œä»¥ä¾¿åœ¨ç”Ÿæˆå™¨è¿è¡Œæ—¶å‡å°‘ä¸å¿…è¦çš„é‡å¤è®¡ç®—ã€‚è¿™ä¸¤ç‚¹çš„ç»“åˆå¯ä»¥æœ‰æ•ˆæå‡ç”Ÿæˆå™¨çš„æ•ˆç‡å’Œç¨³å®šæ€§ï¼Œæ‰€ä»¥æˆ‘å†³å®šå…ˆåœ¨è¿™ä¸ªæ–¹å‘ä¸Šè¿›è¡Œè®¾è®¡ã€‚*
>
> *æ¥ä¸‹æ¥ï¼Œæˆ‘æƒ³åˆ°äº†å†…å­˜ç®¡ç†çš„é—®é¢˜ï¼Œå°¤å…¶æ˜¯ä»£ç ç”Ÿæˆå™¨ä¼šé¢‘ç¹åŠ è½½å’Œå­˜å‚¨æ¨¡å—æ•°æ®ï¼Œå¦‚æœç¼ºå°‘æœ‰æ•ˆçš„ç¼“å­˜æœºåˆ¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´å†…å­˜å ç”¨è¿‡é«˜ç”šè‡³æ³„æ¼ã€‚æˆ‘å‘ç°å¯ä»¥é€šè¿‡å¼•å…¥ä¸¤çº§ç¼“å­˜ç­–ç•¥æ¥è§£å†³ï¼šä¸€çº§ç¼“å­˜ç”¨äºå­˜å‚¨æ¨¡å—æ¸…å•çš„æœ€æ–°çŠ¶æ€ï¼ŒäºŒçº§ç¼“å­˜ç”¨äºå­˜å‚¨ç”Ÿæˆçš„ä»£ç å†…å®¹ï¼›åŒæ—¶éœ€è¦åŠ å…¥ç¼“å­˜å¤±æ•ˆæœºåˆ¶ï¼Œç¡®ä¿æ•°æ®çŠ¶æ€çš„ä¸€è‡´æ€§ã€‚ä¸ºäº†éªŒè¯è¿™ä¸ªç­–ç•¥çš„å¯è¡Œæ€§ï¼Œæˆ‘åœ¨è„‘æµ·ä¸­æ¨¡æ‹Ÿäº†æ¨¡å—çŠ¶æ€å˜åŒ–æ—¶çš„ç¼“å­˜æ›´æ–°æµç¨‹ï¼Œå‘ç°éœ€è¦å¢åŠ "ç¼“å­˜æ ‡è¯†"å’Œ"ç¼“å­˜ç‰ˆæœ¬å·"æ¥ç®¡ç†æ•°æ®çš„æ—¶æ•ˆæ€§ã€‚*
>
> *ç„¶åï¼Œæˆ‘å¼€å§‹æ€è€ƒç³»ç»Ÿçš„å¯é æ€§é—®é¢˜ã€‚å¯é æ€§æ˜¯ä¼ä¸šçº§ç³»ç»Ÿçš„å…³é”®ç‰¹æ€§ï¼Œç‰¹åˆ«æ˜¯åœ¨ä½ä»£ç å¹³å°ä¸­ï¼Œä»»ä½•ç”Ÿæˆé€»è¾‘çš„ä¸­æ–­éƒ½å¯èƒ½å¯¼è‡´å¼€å‘æµç¨‹åœæ»ã€‚æˆ‘é¦–å…ˆæƒ³åˆ°çš„æ˜¯æ¨¡å—åŒ–è®¾è®¡å¸¦æ¥çš„å•ç‚¹æ•…éšœé—®é¢˜ï¼Œç”Ÿæˆå™¨æœ¬èº«å¯èƒ½ä¼šå› ä¸ºå¤æ‚ä¾èµ–è€Œé™·å…¥æ­»å¾ªç¯æˆ–çŠ¶æ€ä¸ä¸€è‡´çš„é—®é¢˜ã€‚äºæ˜¯æˆ‘å†³å®šä¸ºæ¯ä¸ªæ¨¡å—çš„ç”Ÿæˆè¿‡ç¨‹åŠ å…¥ç‹¬ç«‹çš„äº‹åŠ¡æœºåˆ¶ï¼Œä»¥ä¾¿åœ¨ç”Ÿæˆå¤±è´¥æ—¶å¯ä»¥å¿«é€Ÿå›æ»šåˆ°ä¸Šä¸€ç¨³å®šçŠ¶æ€ã€‚*
>
> *æ­¤å¤–ï¼Œæˆ‘è”æƒ³åˆ°ç”Ÿæˆå™¨çš„è¿è¡Œå¯èƒ½ç¼ºä¹å®æ—¶ç›‘æ§èƒ½åŠ›ï¼Œè¿™åœ¨é•¿æ—¶é—´è¿è¡Œæ—¶å®¹æ˜“å¯¼è‡´èµ„æºåˆ†é…ä¸å½“ã€‚å› æ­¤ï¼Œæˆ‘å†³å®šä¸ºç”Ÿæˆå™¨åŠ å…¥èµ„æºç›‘æ§å’Œå¥åº·æ£€æŸ¥æœºåˆ¶ï¼Œèƒ½å¤Ÿå®æ—¶æ£€æµ‹å†…å­˜å ç”¨å’ŒCPUä½¿ç”¨ç‡ï¼ŒåŠæ—¶å‘ç°æ½œåœ¨é—®é¢˜å¹¶è§¦å‘è­¦å‘Šã€‚*
>
> *ä¸ºäº†éªŒè¯è¿™äº›åˆ†æå’Œä¼˜åŒ–çš„å¯è¡Œæ€§ï¼Œæˆ‘é‡æ–°æ¢³ç†äº†ç”¨æˆ·éœ€æ±‚ï¼Œç¡®ä¿æ¯ä¸ªè®¾è®¡ç‚¹éƒ½åœ¨ç”¨æˆ·çš„å…³æ³¨èŒƒå›´å†…ã€‚æœ€ç»ˆï¼Œæˆ‘é€‰æ‹©ä»¥æ¸…æ™°çš„é€»è¾‘ç»“æ„ç»„ç»‡å›å¤ï¼Œä»æ ¸å¿ƒå¯¹è±¡è®¾è®¡å…¥æ‰‹ï¼Œé€æ­¥è¿‡æ¸¡åˆ°å†…å­˜ç®¡ç†å’Œç³»ç»Ÿå¯é æ€§ï¼Œç¡®ä¿ç”¨æˆ·èƒ½å…¨é¢ç†è§£æ¯ä¸ªä¼˜åŒ–ç‚¹åŠå…¶ä»·å€¼ã€‚*

ç°åœ¨æˆ‘å°†é’ˆå¯¹æ–‡æ¡£ä¸­çš„ä½ä»£ç å®ç°ï¼Œä»æ•°æ®ç»“æ„è®¾è®¡ã€å†…å­˜ç®¡ç†ã€ç³»ç»Ÿå¯é æ€§ä¸‰ä¸ªæ–¹é¢è¿›è¡Œæ›´æ·±å…¥çš„åˆ†æï¼Œå¹¶æå‡ºä¼˜åŒ–æ–¹æ¡ˆã€‚

### æ•°æ®ç»“æ„è®¾è®¡åˆ†æä¸ä¼˜åŒ–

ç›®å‰ä½¿ç”¨çš„`Manifest`åŠå„ç§é…ç½®Schemaå·²ç»æ„å»ºäº†ä¸€ä¸ªè¾ƒä¸ºæ¸…æ™°çš„ç»“æ„ï¼Œä½†åœ¨å¤„ç†å¤æ‚æ¨¡å—å…³ç³»åŠå¤§è§„æ¨¡é¡¹ç›®æ—¶ï¼Œä»å­˜åœ¨æ”¹è¿›ç©ºé—´ã€‚

#### å½“å‰è®¾è®¡è¯„ä»·
- **ä¼˜ç‚¹**ï¼šç»“æ„æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œæ‰©å±•ï¼Œèƒ½å¤Ÿå¾ˆå¥½åœ°è¡¨è¾¾æ¨¡å—çš„åŸºæœ¬ä¿¡æ¯å’Œé…ç½®éœ€æ±‚ã€‚
- **ç¼ºç‚¹**ï¼šå¯¹äºæ¨¡å—é—´çš„å¤æ‚å…³ç³»ï¼ˆå¦‚å¤šå¯¹å¤šä¾èµ–ã€ç‰ˆæœ¬å…¼å®¹æ€§ç­‰ï¼‰è¡¨è¾¾ä¸è¶³ï¼Œç¼ºä¹å¯¹æ¨¡å—çŠ¶æ€çš„ç²¾ç»†åŒ–ç®¡ç†ã€‚

#### ä¼˜åŒ–æ–¹æ¡ˆ
å¼•å…¥æ¨¡å—å®ä½“ç±»å’Œå…³ç³»ç±»ï¼š
```typescript
class ModuleEntity {
  // æ¨¡å—åŸºæœ¬ä¿¡æ¯
  id: string;
  name: string;
  version: string;
  description: string;
  
  // æ¨¡å—å…³ç³»
  dependencies: DependencyRelation[];
  dependents: DependencyRelation[];
  
  // æ¨¡å—çŠ¶æ€
  state: ModuleState;
  versionHistory: VersionHistory[];
}

class DependencyRelation {
  sourceModuleId: string;
  targetModuleId: string;
  versionConstraint: string; // ç‰ˆæœ¬çº¦æŸï¼Œå¦‚ "^1.0.0"
  isOptional: boolean;
}

enum ModuleState {
  NotLoaded,
  Loading,
  Loaded,
 Errored,
  Deprecated
}

interface VersionHistory {
  version: string;
  releaseDate: Date;
  breakingChanges: string[];
  upgradeInstructions: string;
}
```
**æå‡ç‚¹**ï¼š
- èƒ½å¤Ÿæ›´ç²¾ç»†åœ°ç®¡ç†æ¨¡å—çŠ¶æ€ï¼Œä¾¿äºè¿›è¡Œç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚
- æ”¯æŒå¤æ‚çš„ç‰ˆæœ¬çº¦æŸå’Œå¯é€‰ä¾èµ–å…³ç³»ï¼Œå¢å¼ºç³»ç»Ÿçš„çµæ´»æ€§å’Œå…¼å®¹æ€§ã€‚

### å†…å­˜ç®¡ç†åˆ†æä¸ä¼˜åŒ–

å½“å‰çš„å†…å­˜ç®¡ç†ä¸»è¦ä¾èµ–äºV8å¼•æ“çš„è‡ªåŠ¨åƒåœ¾å›æ”¶æœºåˆ¶ã€‚ä½†åœ¨å¤„ç†å¤§å‹é¡¹ç›®æˆ–é•¿æ—¶é—´è¿è¡Œæ—¶ï¼Œå¯èƒ½ä¼šå‡ºç°å†…å­˜æ³„æ¼æˆ–ä¸å¿…è¦çš„å†…å­˜å ç”¨é—®é¢˜ã€‚

#### å½“å‰å®ç°è¯„ä»·
- **ä¼˜ç‚¹**ï¼šå¼€å‘ç®€å•ï¼ŒV8å¼•æ“çš„åƒåœ¾å›æ”¶æœºåˆ¶é€šå¸¸è¡¨ç°è‰¯å¥½ã€‚
- **ç¼ºç‚¹**ï¼šå¯¹äºåŠ¨æ€ç”Ÿæˆçš„ä»£ç å’Œæ¨¡å—ï¼Œå¯èƒ½å­˜åœ¨æœªé¢„æœŸçš„å¼•ç”¨ä¿ç•™ï¼Œå¯¼è‡´å†…å­˜æ³„æ¼ã€‚

#### ä¼˜åŒ–æ–¹æ¡ˆ
å®ç°å†…å­˜ç®¡ç†ç›‘æ§ä¸ä¼˜åŒ–ï¼š
```typescript
class MemoryManager {
  private memoryUsageThreshold: number = 70; // ç™¾åˆ†æ¯”
  
  constructor(private performanceMonitor: PerformanceMonitor) {}
  
  monitorMemory(): void {
    const memoryUsage = this.getMemoryUsage();
    
    if (memoryUsage > this.memoryUsageThreshold) {
      console.warn(`Memory usage exceeds threshold: ${memoryUsage}%`);
      this.takeMemorySnapshot();
      this.suggestMemoryOptimization();
    }
  }
  
  private getMemoryUsage(): number {
    // è·å–å½“å‰å†…å­˜ä½¿ç”¨ç‡
    return process.memoryUsage().heapUsed / process.memoryUsage().heapTotal * 100;
  }
  
  private takeMemorySnapshot(): void {
    // æ•è·å†…å­˜å¿«ç…§ï¼Œä¾¿äºåç»­åˆ†æ
    console.log("Taking memory snapshot...");
    // å®é™…é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨ V8 çš„ API æˆ–å·¥å…·æ¥æ•è·å¿«ç…§
  }
  
  private suggestMemoryOptimization(): void {
    console.log("Memory optimization suggestions:");
    console.log("- Review large module configurations");
    console.log("- Optimize generated code for memory efficiency");
    console.log("- Consider lazy loading for non-critical modules");
  }
}

// åœ¨ç”Ÿæˆå™¨æ ¸å¿ƒæµç¨‹ä¸­é›†æˆå†…å­˜ç›‘æ§
const memoryManager = new MemoryManager(performanceMonitor);
memoryManager.monitorMemory();
```
**æå‡ç‚¹**ï¼š
- å®æ—¶ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µï¼ŒåŠæ—¶å‘ç°æ½œåœ¨çš„å†…å­˜é—®é¢˜ã€‚
- æä¾›å†…å­˜ä¼˜åŒ–å»ºè®®ï¼Œå¸®åŠ©å¼€å‘è€…æ”¹è¿›ä»£ç ï¼Œå‡å°‘å†…å­˜å ç”¨ã€‚

### ç³»ç»Ÿè¿è¡Œå¯é æ€§åˆ†æä¸ä¼˜åŒ–

ç³»ç»Ÿå¯é æ€§ä¸»è¦ä½“ç°åœ¨é”™è¯¯å¤„ç†ã€å®¹é”™èƒ½åŠ›ä»¥åŠæ¢å¤æœºåˆ¶ç­‰æ–¹é¢ã€‚

#### å½“å‰å¯é æ€§è¯„ä»·
- **ä¼˜ç‚¹**ï¼šæœ‰åŸºæœ¬çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œå¦‚ç”Ÿæˆå¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸ã€‚
- **ç¼ºç‚¹**ï¼šç¼ºä¹ç³»ç»Ÿçš„å®¹é”™ç­–ç•¥å’Œæ¢å¤æœºåˆ¶ï¼ŒæŸäº›é”™è¯¯å¯èƒ½å¯¼è‡´æ•´ä¸ªç³»ç»Ÿä¸å¯ç”¨ã€‚

#### ä¼˜åŒ–æ–¹æ¡ˆ
å¼•å…¥äº‹åŠ¡æ€§ç”Ÿæˆä¸å›æ»šæœºåˆ¶ï¼š
```typescript
class TransactionalGenerator {
  private backupState: any; // å­˜å‚¨å¤‡ä»½çŠ¶æ€
  
  constructor(private generator: CodeGenerator) {}
  
  generateWithTransaction(manifests: Manifest[]): void {
    try {
      // ç”Ÿæˆå‰å¤‡ä»½å½“å‰çŠ¶æ€
      this.backupCurrentState();
      
      // æ‰§è¡Œç”Ÿæˆæ“ä½œ
      this.generator.generate(manifests);
      
      // å¦‚æœç”ŸæˆæˆåŠŸï¼Œæäº¤äº‹åŠ¡
      this.commitTransaction();
      console.log("Code generation transaction committed successfully.");
    } catch (error) {
      // å¦‚æœç”Ÿæˆå¤±è´¥ï¼Œå›æ»šåˆ°ä¹‹å‰çŠ¶æ€
      this.rollbackTransaction();
      console.error("Code generation failed. Rolled back to previous state.");
      throw error;
    }
  }
  
  private backupCurrentState(): void {
    // å®ç°çŠ¶æ€å¤‡ä»½é€»è¾‘ï¼Œå¯ä»¥å¤‡ä»½æ–‡ä»¶ç³»ç»ŸçŠ¶æ€ã€å†…å­˜çŠ¶æ€ç­‰
    console.log("Backing up current system state...");
    this.backupState = {/* å½“å‰ç³»ç»ŸçŠ¶æ€å¿«ç…§ */};
  }
  
  private commitTransaction(): void {
    // æäº¤äº‹åŠ¡ï¼Œæ¸…ç†å¤‡ä»½çŠ¶æ€
    console.log("Committing transaction...");
    this.backupState = null;
  }
  
  private rollbackTransaction(): void {
    if (this.backupState) {
      // å®ç°çŠ¶æ€å›æ»šé€»è¾‘ï¼Œæ¢å¤åˆ°å¤‡ä»½çŠ¶æ€
      console.log("Rolling back to previous state...");
      // æ¢å¤æ“ä½œ
    }
  }
}

// ä½¿ç”¨äº‹åŠ¡æ€§ç”Ÿæˆå™¨
const transactionalGenerator = new TransactionalGenerator(generator);
transactionalGenerator.generateWithTransaction(manifests);
```
å¼•å…¥å¥åº·æ£€æŸ¥ä¸è‡ªæˆ‘ä¿®å¤ï¼š
```typescript
class HealthChecker {
  private lastCheckTimestamp: Date = new Date();
  private failureCount: number = 0;
  
  constructor(private systemComponents: SystemComponent[]) {}
  
  checkHealth(): HealthReport {
    const report: HealthReport = {
      timestamp: new Date(),
      componentReports: []
    };
    
    let isHealthy = true;
    
    for (const component of this.systemComponents) {
      const componentReport = component.performHealthCheck();
      report.componentReports.push(componentReport);
      
      if (!componentReport.isHealthy) {
        isHealthy = false;
        this.failureCount++;
        
        // å°è¯•è‡ªåŠ¨ä¿®å¤
        if (componentReport.isAutoFixable) {
          console.log(`Attempting auto-fix for ${component.name}...`);
          component.attemptAutoFix();
        }
      }
    }
    
    report.isHealthy = isHealthy;
    report.failureCount = this.failureCount;
    
    return report;
  }
  
  // å®šæœŸå¥åº·æ£€æŸ¥
  startMonitoring(interval: number = 60000): void {
    setInterval(() => {
      const report = this.checkHealth();
      console.log("Health Check Report:", report);
      
      // å¦‚æœç³»ç»Ÿä¸å¥åº·ï¼Œå¯ä»¥è§¦å‘é€šçŸ¥æˆ–è¿›ä¸€æ­¥æ“ä½œ
      if (!report.isHealthy) {
        this.triggerAlert(report);
      }
    }, interval);
  }
  
  private triggerAlert(report: HealthReport): void {
    console.error("System health alert:", report);
    // å®ç°é€šçŸ¥é€»è¾‘ï¼Œå¦‚å‘é€é‚®ä»¶ã€æ¶ˆæ¯ç­‰
  }
}

interface HealthReport {
  timestamp: Date;
  isHealthy: boolean;
  componentReports: ComponentHealthReport[];
  failureCount: number;
}

interface ComponentHealthReport {
  componentName: string;
  isHealthy: boolean;
  healthDetails: Record<string, any>;
  isAutoFixable: boolean;
}

abstract class SystemComponent {
  abstract name: string;
  
  abstract performHealthCheck(): ComponentHealthReport;
  
  abstract attemptAutoFix(): void;
}

// ç¤ºä¾‹ç»„ä»¶ï¼šæ–‡ä»¶ç³»ç»Ÿç»„ä»¶
class FileSystemComponent extends SystemComponent {
  name = "FileSystem";
  
  performHealthCheck(): ComponentHealthReport {
    // å®ç°æ–‡ä»¶ç³»ç»Ÿå¥åº·æ£€æŸ¥é€»è¾‘
    const isHealthy = true; // å‡è®¾æ–‡ä»¶ç³»ç»Ÿå¥åº·
    return {
      componentName: this.name,
      isHealthy,
      healthDetails: {
        diskUsage: "40%",
        fileSystemErrors: 0
      },
      isAutoFixable: !isHealthy
    };
  }
  
  attemptAutoFix(): void {
    // å®ç°æ–‡ä»¶ç³»ç»Ÿè‡ªåŠ¨ä¿®å¤é€»è¾‘
    console.log("Auto-fixing file system...");
    // ä¿®å¤æ“ä½œ
  }
}

// ç¤ºä¾‹ç»„ä»¶ï¼šå†…å­˜ç»„ä»¶
class MemoryComponent extends SystemComponent {
  name = "Memory";
  
  performHealthCheck(): ComponentHealthReport {
    const memoryManager = new MemoryManager(new PerformanceMonitor());
    const memoryUsage = memoryManager.getMemoryUsage();
    
    const isHealthy = memoryUsage < 80; // å‡è®¾å†…å­˜ä½¿ç”¨ä½äº80%ä¸ºå¥åº·
    return {
      componentName: this.name,
      isHealthy,
      healthDetails: {
        memoryUsage: `${memoryUsage}%`
      },
      isAutoFixable: !isHealthy
    };
  }
  
  attemptAutoFix(): void {
    console.log("Attempting memory optimization...");
    // å†…å­˜ä¼˜åŒ–é€»è¾‘
  }
}

// åˆå§‹åŒ–å¥åº·æ£€æŸ¥å™¨
const healthChecker = new HealthChecker([
  new FileSystemComponent(),
  new MemoryComponent(),
  // å…¶ä»–ç³»ç»Ÿç»„ä»¶...
]);

// å¯åŠ¨å¥åº·ç›‘æµ‹
healthChecker.startMonitoring();
```
**æå‡ç‚¹**ï¼š
- é€šè¿‡äº‹åŠ¡æ€§æ“ä½œç¡®ä¿ç³»ç»Ÿåœ¨ç”Ÿæˆå¤±è´¥æ—¶èƒ½å¤Ÿå›æ»šåˆ°ç¨³å®šçŠ¶æ€ï¼Œé¿å…ä¸ä¸€è‡´é—®é¢˜ã€‚
- å¥åº·æ£€æŸ¥ä¸è‡ªæˆ‘ä¿®å¤æœºåˆ¶èƒ½å¤Ÿä¸»åŠ¨å‘ç°å¹¶è§£å†³ç³»ç»Ÿæ½œåœ¨é—®é¢˜ï¼Œæé«˜ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯ç”¨æ€§ã€‚

é€šè¿‡ä»¥ä¸Šä¼˜åŒ–æ–¹æ¡ˆï¼Œå¯ä»¥æ˜¾è‘—æå‡ä½ä»£ç å¹³å°åœ¨å¤„ç†å¤æ‚é¡¹ç›®æ—¶çš„æ€§èƒ½ã€å†…å­˜ä½¿ç”¨æ•ˆç‡å’Œç³»ç»Ÿå¯é æ€§ï¼Œä»è€Œæ›´å¥½åœ°æ»¡è¶³ä¼ä¸šçº§åº”ç”¨çš„éœ€æ±‚ã€‚è¿™äº›æ”¹è¿›å°†ä½¿ç³»ç»Ÿæ›´åŠ å¥å£®ã€æ˜“äºç»´æŠ¤ï¼Œå¹¶èƒ½å¤Ÿé€‚åº”ä¸æ–­å˜åŒ–çš„ä¸šåŠ¡éœ€æ±‚ã€‚

