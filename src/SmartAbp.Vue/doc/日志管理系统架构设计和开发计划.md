# æ—¥å¿—ç®¡ç†ç³»ç»Ÿæ¶æ„è®¾è®¡å’Œå¼€å‘è®¡åˆ’

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### ç›®æ ‡
æ„å»ºä¸€ä¸ª**ä¼ä¸šçº§å‰ç«¯æ—¥å¿—ç®¡ç†ç³»ç»Ÿ**ï¼Œå®ç°ä»å®¢æˆ·ç«¯é”™è¯¯æ•è·åˆ°æœåŠ¡ç«¯åˆ†æçš„å®Œæ•´é—­ç¯ï¼Œä¸ºè½¯ä»¶å¼€å‘å•†æä¾›å®æ—¶çš„å®¢æˆ·ç«¯ç›‘æ§å’Œé—®é¢˜è¯Šæ–­èƒ½åŠ›ã€‚

### æ ¸å¿ƒéœ€æ±‚
1. **å®Œæ•´é”™è¯¯æ•è·** - æ•è·æ‰€æœ‰ç±»å‹çš„å‰ç«¯é”™è¯¯ï¼ˆJSé”™è¯¯ã€Vueé”™è¯¯ã€Promiseé”™è¯¯ã€æ§åˆ¶å°é”™è¯¯ï¼‰
2. **æ€§èƒ½ç›‘æ§** - APIè°ƒç”¨æ€§èƒ½ã€é¡µé¢åŠ è½½æ€§èƒ½ç›‘æ§
3. **ç”¨æˆ·è¡Œä¸ºè¿½è¸ª** - å…³é”®æ“ä½œè·¯å¾„è®°å½•
4. **å®æ—¶å‘Šè­¦** - ä¸¥é‡é—®é¢˜ç«‹å³é€šçŸ¥
5. **æœåŠ¡ç«¯å¯è§** - å¼€å‘å•†èƒ½å¤Ÿçœ‹åˆ°æ‰€æœ‰å®¢æˆ·ç«¯æ—¥å¿—
6. **åŠ¡å®å¯é ** - å¼‚æ­¥å¤„ç†ã€ä¾èµ–å¯æ§ã€ä¸å½±å“ä¸»åº”ç”¨æ€§èƒ½

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å®¢æˆ·ç«¯é”™è¯¯     â”‚â”€â”€â”€â–¶â”‚   WebWorker      â”‚â”€â”€â”€â–¶â”‚   IndexedDB     â”‚
â”‚   å‘ç”Ÿ/æ•è·     â”‚    â”‚   å¼‚æ­¥å¤„ç†é˜Ÿåˆ—    â”‚    â”‚   æœ¬åœ°æŒä¹…åŒ–    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æœåŠ¡ç«¯API     â”‚â—€â”€â”€â”€â”‚   æ‰¹é‡å‹ç¼©ä¸Šä¼     â”‚    â”‚   ç½‘ç»œé‡è¯•æœºåˆ¶   â”‚
â”‚   æ—¥å¿—æ¥æ”¶      â”‚    â”‚   æ™ºèƒ½è°ƒåº¦       â”‚    â”‚   å¤±è´¥æ¢å¤      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ•°æ®åº“å­˜å‚¨     â”‚â”€â”€â”€â–¶â”‚   æ—¥å¿—åˆ†æå¼•æ“    â”‚â”€â”€â”€â–¶â”‚   å¼€å‘å•†åå°     â”‚
â”‚   ç»“æ„åŒ–æ•°æ®     â”‚    â”‚   æ™ºèƒ½ç»Ÿè®¡       â”‚    â”‚   ç›‘æ§é¢æ¿      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆé€‰æ‹©
- **å‰ç«¯æ¡†æ¶**: Vue 3 + TypeScript + Pinia
- **å·¥å…·åº“**: Element Plus + ECharts
- **å­˜å‚¨æ–¹æ¡ˆ**: IndexedDB (å®¢æˆ·ç«¯) + SQL Server (æœåŠ¡ç«¯)
- **å¹¶å‘å¤„ç†**: WebWorker
- **æ¶æ„æ¨¡å¼**: ä¾èµ–æ³¨å…¥ + æ¥å£æŠ½è±¡
- **é€šä¿¡åè®®**: HTTP/HTTPS + JSON
- **æ•°æ®å‹ç¼©**: JSONå‹ç¼© + æ‰¹é‡ä¼ è¾“

## ğŸ”§ ä¾èµ–æ³¨å…¥æ¶æ„è®¾è®¡

### æ ¸å¿ƒæ¥å£å®šä¹‰
```typescript
// å­˜å‚¨æ¥å£
interface ILogStorage {
  save(log: LogEntry): Promise<void>
  query(filter: LogFilter): Promise<LogEntry[]>
  clear(): Promise<void>
  count(): Promise<number>
}

// æ”¶é›†å™¨æ¥å£
interface ILogCollector {
  collect(error: ErrorInfo): void
  setFilters(filters: LogFilter[]): void
}

// æ ¼å¼åŒ–æ¥å£
interface ILogFormatter {
  format(log: LogEntry): FormattedLog
  formatBatch(logs: LogEntry[]): FormattedLog[]
}

// ä¼ è¾“æ¥å£
interface ILogTransport {
  send(logs: LogEntry[]): Promise<void>
  isAvailable(): boolean
}
```

### IoCå®¹å™¨å®ç°
```typescript
// src/utils/di/Container.ts
export class DIContainer {
  private services = new Map<string, ServiceDescriptor>()
  private instances = new Map<string, any>()
  
  // æ³¨å†Œç¬æ€æœåŠ¡
  register<T>(token: string, factory: () => T): void {
    this.services.set(token, {
      factory,
      lifetime: 'transient'
    })
  }
  
  // æ³¨å†Œå•ä¾‹æœåŠ¡
  singleton<T>(token: string, factory: () => T): void {
    this.services.set(token, {
      factory,
      lifetime: 'singleton'
    })
  }
  
  // è§£ææœåŠ¡
  resolve<T>(token: string): T {
    const descriptor = this.services.get(token)
    if (!descriptor) {
      throw new Error(`Service ${token} not registered`)
    }
    
    if (descriptor.lifetime === 'singleton') {
      if (!this.instances.has(token)) {
        this.instances.set(token, descriptor.factory())
      }
      return this.instances.get(token)
    }
    
    return descriptor.factory()
  }
  
  // æ‰¹é‡æ³¨å†Œ
  registerBatch(registrations: ServiceRegistration[]): void {
    registrations.forEach(({ token, factory, lifetime = 'transient' }) => {
      if (lifetime === 'singleton') {
        this.singleton(token, factory)
      } else {
        this.register(token, factory)
      }
    })
  }
}
```

### æœåŠ¡é…ç½®ç®¡ç†
```typescript
// src/utils/logging/config/ServiceConfig.ts
export class LoggingServiceConfig {
  static configureServices(container: DIContainer, env: 'development' | 'production') {
    const registrations: ServiceRegistration[] = []
    
    if (env === 'development') {
      // å¼€å‘ç¯å¢ƒé…ç½®
      registrations.push(
        {
          token: 'ILogStorage',
          factory: () => new IndexedDBStorage(),
          lifetime: 'singleton'
        },
        {
          token: 'ILogTransport', 
          factory: () => new ConsoleTransport(),
          lifetime: 'singleton'
        }
      )
    } else {
      // ç”Ÿäº§ç¯å¢ƒé…ç½®
      registrations.push(
        {
          token: 'ILogStorage',
          factory: () => new RemoteStorage(process.env.VITE_LOG_API_URL!),
          lifetime: 'singleton'
        },
        {
          token: 'ILogTransport',
          factory: () => new BatchTransport(process.env.VITE_LOG_API_URL!),
          lifetime: 'singleton'
        }
      )
    }
    
    // é€šç”¨æœåŠ¡æ³¨å†Œ
    registrations.push(
      {
        token: 'ILogFormatter',
        factory: () => new StructuredLogFormatter(),
        lifetime: 'singleton'
      },
      {
        token: 'ILogCollector',
        factory: () => new WebWorkerLogCollector(
          container.resolve<ILogStorage>('ILogStorage'),
          container.resolve<ILogFormatter>('ILogFormatter')
        ),
        lifetime: 'singleton'
      }
    )
    
    container.registerBatch(registrations)
  }
}
```

## âš¡ WebWorker + IndexedDB è®¾è®¡

### WebWorkeræ¶æ„è®¾è®¡

#### æ ¸å¿ƒä¼˜åŠ¿
1. **éé˜»å¡å¤„ç†** - æ‰€æœ‰æ—¥å¿—å¤„ç†åœ¨åå°çº¿ç¨‹è¿›è¡Œ
2. **ç‹¬ç«‹å†…å­˜ç©ºé—´** - ä¸å ç”¨ä¸»çº¿ç¨‹å†…å­˜èµ„æº
3. **å¹¶è¡Œè®¡ç®—èƒ½åŠ›** - å¯è¿›è¡Œæ•°æ®å‹ç¼©ã€åŠ å¯†ã€å¤æ‚åˆ†æ
4. **å®¹é”™éš”ç¦»** - Workerå´©æºƒä¸å½±å“ä¸»åº”ç”¨
5. **æŒä¹…åŒ–å­˜å‚¨** - ç›´æ¥åœ¨Workerä¸­æ“ä½œIndexedDB

#### Workerå®ç°æ¶æ„
```typescript
// src/workers/logWorker.ts
class LogWorker {
  private queue: LogEntry[] = []                    // å†…å­˜é˜Ÿåˆ—
  private db: IDBDatabase | null = null             // IndexedDBè¿æ¥
  private isProcessing = false                      // å¤„ç†çŠ¶æ€æ ‡å¿—
  private readonly BATCH_SIZE = 20                  // æ‰¹é‡å¤„ç†å¤§å°
  private readonly PROCESS_INTERVAL = 30000         // å¤„ç†é—´éš”30ç§’
  private readonly MAX_RETRY_COUNT = 3              // æœ€å¤§é‡è¯•æ¬¡æ•°
  
  constructor() {
    this.initIndexedDB()                           // åˆå§‹åŒ–æ•°æ®åº“
    this.startProcessingLoop()                     // å¯åŠ¨å¤„ç†å¾ªç¯
    this.recoverPendingLogs()                      // æ¢å¤å¾…å¤„ç†æ—¥å¿—
  }
  
  // æ¶ˆæ¯å¤„ç†è·¯ç”±
  handleMessage = (event: MessageEvent) => {
    const { type, data, id } = event.data
    
    switch (type) {
      case 'ADD_LOG':
        this.addToQueue(data)
        this.sendResponse(id, 'LOG_RECEIVED', { status: 'queued' })
        break
        
      case 'FORCE_UPLOAD':
        this.processQueue()
        break
        
      case 'GET_STATS':
        this.sendStats(id)
        break
        
      case 'CLEAR_LOGS':
        this.clearAllLogs()
        break
    }
  }
  
  // é˜Ÿåˆ—ç®¡ç†
  private addToQueue(log: LogEntry) {
    const enrichedLog = {
      ...log,
      workerReceivedAt: Date.now(),
      status: 'pending',
      retryCount: 0
    }
    
    this.queue.push(enrichedLog)
    this.saveToIndexedDB(enrichedLog)              // ç«‹å³æŒä¹…åŒ–
    
    // é«˜ä¼˜å…ˆçº§æ—¥å¿—ç«‹å³å¤„ç†
    if (log.level === 'ERROR' || log.priority === 'high') {
      this.processQueue()
    }
  }
  
  // æ‰¹é‡å¤„ç†é˜Ÿåˆ—
  private async processQueue() {
    if (this.isProcessing || this.queue.length === 0) return
    
    this.isProcessing = true
    
    try {
      // æŒ‰ä¼˜å…ˆçº§æ’åº
      this.queue.sort((a, b) => {
        if (a.level === 'ERROR' && b.level !== 'ERROR') return -1
        if (b.level === 'ERROR' && a.level !== 'ERROR') return 1
        return a.timestamp - b.timestamp
      })
      
      const batch = this.queue.splice(0, this.BATCH_SIZE)
      
      // æ•°æ®å‹ç¼©
      const compressed = await this.compressLogBatch(batch)
      
      // ç½‘ç»œä¸Šä¼ 
      await this.uploadBatch(compressed, batch)
      
      // æ›´æ–°çŠ¶æ€
      await this.updateLogStatus(batch.map(l => l.id), 'uploaded')
      
      this.sendMessage('BATCH_UPLOADED', {
        count: batch.length,
        remainingInQueue: this.queue.length
      })
      
    } catch (error) {
      // å¤±è´¥å¤„ç†
      this.handleUploadFailure(batch, error)
    } finally {
      this.isProcessing = false
    }
  }
  
  // æ•°æ®å‹ç¼©ç®—æ³•
  private async compressLogBatch(logs: LogEntry[]): Promise<CompressedBatch> {
    // å­—æ®µå‹ç¼©æ˜ å°„
    const compressed = logs.map(log => ({
      i: log.id,
      t: log.timestamp,
      l: log.level,
      m: log.message,
      s: log.stack?.substring(0, 500),               // é™åˆ¶å †æ ˆé•¿åº¦
      u: log.url !== location.href ? log.url : undefined  // å»é‡URL
    }))
    
    const jsonString = JSON.stringify(compressed)
    
    return {
      data: jsonString,
      originalCount: logs.length,
      compressedSize: jsonString.length,
      compressionRatio: jsonString.length / JSON.stringify(logs).length
    }
  }
}
```

### IndexedDBæ•°æ®ç»“æ„è®¾è®¡

#### æ•°æ®åº“æ¶æ„
```typescript
// æ•°æ®åº“ç»“æ„è®¾è®¡
interface LogDatabase {
  name: 'SmartAbpLogs'
  version: 1
  stores: {
    logs: {                                       // ä¸»æ—¥å¿—å­˜å‚¨
      keyPath: 'id'
      indexes: {
        timestamp: { keyPath: 'timestamp', unique: false }
        level: { keyPath: 'level', unique: false }
        status: { keyPath: 'status', unique: false }
        type: { keyPath: 'type', unique: false }
      }
    }
    
    upload_queue: {                              // ä¸Šä¼ é˜Ÿåˆ—
      keyPath: 'id'
      indexes: {
        priority: { keyPath: 'priority', unique: false }
        retryCount: { keyPath: 'retryCount', unique: false }
        scheduledTime: { keyPath: 'scheduledTime', unique: false }
      }
    }
    
    client_meta: {                               // å®¢æˆ·ç«¯å…ƒæ•°æ®
      keyPath: 'key'
      data: {
        clientId: string
        sessionId: string
        appVersion: string
        lastUploadTime: number
        totalLogsGenerated: number
        totalLogsUploaded: number
      }
    }
  }
}
```

#### å­˜å‚¨å®ç°
```typescript
// src/utils/logging/storage/IndexedDBStorage.ts
export class IndexedDBStorage implements ILogStorage {
  private readonly dbName = 'SmartAbpLogs'
  private readonly version = 1
  private db: IDBDatabase | null = null
  
  async initialize(): Promise<void> {
    this.db = await new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version)
      
      request.onerror = () => reject(request.error)
      request.onsuccess = () => resolve(request.result)
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result
        this.createStores(db)
      }
    })
  }
  
  private createStores(db: IDBDatabase): void {
    // åˆ›å»ºæ—¥å¿—å­˜å‚¨è¡¨
    const logsStore = db.createObjectStore('logs', { keyPath: 'id' })
    logsStore.createIndex('timestamp', 'timestamp')
    logsStore.createIndex('level', 'level')
    logsStore.createIndex('status', 'status')
    logsStore.createIndex('type', 'type')
    
    // åˆ›å»ºä¸Šä¼ é˜Ÿåˆ—è¡¨
    const queueStore = db.createObjectStore('upload_queue', { keyPath: 'id' })
    queueStore.createIndex('priority', 'priority')
    queueStore.createIndex('retryCount', 'retryCount')
    queueStore.createIndex('scheduledTime', 'scheduledTime')
    
    // åˆ›å»ºå…ƒæ•°æ®è¡¨
    const metaStore = db.createObjectStore('client_meta', { keyPath: 'key' })
  }
  
  async save(log: LogEntry): Promise<void> {
    const transaction = this.db!.transaction(['logs'], 'readwrite')
    const store = transaction.objectStore('logs')
    await store.put(log)
  }
  
  async query(filter: LogFilter): Promise<LogEntry[]> {
    const transaction = this.db!.transaction(['logs'], 'readonly')
    const store = transaction.objectStore('logs')
    
    // æ ¹æ®filteræ„å»ºæŸ¥è¯¢
    let cursor: IDBCursorWithValue | null
    
    if (filter.level) {
      const index = store.index('level')
      cursor = await index.openCursor(IDBKeyRange.only(filter.level))
    } else if (filter.timeRange) {
      const index = store.index('timestamp')
      cursor = await index.openCursor(IDBKeyRange.bound(
        filter.timeRange.start, 
        filter.timeRange.end
      ))
    } else {
      cursor = await store.openCursor()
    }
    
    const results: LogEntry[] = []
    while (cursor && results.length < (filter.limit || 100)) {
      results.push(cursor.value)
      cursor = await cursor.continue()
    }
    
    return results
  }
  
  async clear(): Promise<void> {
    const transaction = this.db!.transaction(['logs'], 'readwrite')
    const store = transaction.objectStore('logs')
    await store.clear()
  }
  
  async count(): Promise<number> {
    const transaction = this.db!.transaction(['logs'], 'readonly')
    const store = transaction.objectStore('logs')
    return await store.count()
  }
}
```

## ğŸ” 5å¤§æ ¸å¿ƒåŠŸèƒ½å®ç°

### 1. é”™è¯¯å´©æºƒæ—¥å¿—ç³»ç»Ÿ

#### å…¨å±€é”™è¯¯æ•è·
```typescript
// src/utils/logging/errorCapture/GlobalErrorHandler.ts
export class GlobalErrorHandler {
  private collector: ILogCollector
  
  constructor(collector: ILogCollector) {
    this.collector = collector
  }
  
  init(): void {
    // 1. JavaScriptè¿è¡Œæ—¶é”™è¯¯
    window.addEventListener('error', this.handleJSError.bind(this))
    
    // 2. Promiseæœªå¤„ç†é”™è¯¯
    window.addEventListener('unhandledrejection', this.handlePromiseError.bind(this))
    
    // 3. èµ„æºåŠ è½½é”™è¯¯
    window.addEventListener('error', this.handleResourceError.bind(this), true)
    
    // 4. æ§åˆ¶å°é”™è¯¯æ‹¦æˆª - é‡ç‚¹éœ€æ±‚ï¼
    this.interceptConsoleErrors()
  }
  
  private handleJSError(event: ErrorEvent): void {
    this.collector.collect({
      type: 'javascript',
      level: 'ERROR',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now(),
      url: location.href,
      userAgent: navigator.userAgent
    })
  }
  
  private handlePromiseError(event: PromiseRejectionEvent): void {
    this.collector.collect({
      type: 'promise',
      level: 'ERROR',
      message: String(event.reason),
      stack: event.reason?.stack,
      timestamp: Date.now(),
      url: location.href
    })
  }
  
  private handleResourceError(event: Event): void {
    const target = event.target as HTMLElement
    if (target && target !== window) {
      this.collector.collect({
        type: 'resource',
        level: 'ERROR',
        message: `Resource failed to load: ${target.tagName}`,
        source: (target as any).src || (target as any).href,
        timestamp: Date.now(),
        url: location.href
      })
    }
  }
  
  // æ§åˆ¶å°é”™è¯¯æ‹¦æˆª - æ ¸å¿ƒåŠŸèƒ½
  private interceptConsoleErrors(): void {
    const originalError = console.error
    const originalWarn = console.warn
    
    console.error = (...args) => {
      // è®°å½•åˆ°æˆ‘ä»¬çš„ç³»ç»Ÿ
      this.collector.collect({
        type: 'console',
        level: 'ERROR',
        message: args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' '),
        timestamp: Date.now(),
        url: location.href,
        source: 'console.error'
      })
      
      // ç»§ç»­åŸæœ‰è¾“å‡º
      originalError.apply(console, args)
    }
    
    console.warn = (...args) => {
      this.collector.collect({
        type: 'console',
        level: 'WARN',
        message: args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' '),
        timestamp: Date.now(),
        url: location.href,
        source: 'console.warn'
      })
      
      originalWarn.apply(console, args)
    }
  }
}
```

#### Vueé”™è¯¯å¤„ç†é›†æˆ
```typescript
// src/main.ts - Vueé”™è¯¯å¤„ç†å™¨é›†æˆ
const app = createApp(App)
const container = new DIContainer()

// é…ç½®æœåŠ¡
LoggingServiceConfig.configureServices(container, import.meta.env.MODE as any)

// è·å–æ—¥å¿—æ”¶é›†å™¨
const logCollector = container.resolve<ILogCollector>('ILogCollector')

// Vueé”™è¯¯å¤„ç†å™¨
app.config.errorHandler = (err: any, instance: any, info: string) => {
  logCollector.collect({
    type: 'vue',
    level: 'ERROR',
    message: err.message || String(err),
    stack: err.stack,
    componentName: instance?.$options.name || 'Unknown',
    errorInfo: info,
    timestamp: Date.now(),
    url: location.href,
    vueVersion: app.version
  })
}

// å¯åŠ¨å…¨å±€é”™è¯¯å¤„ç†
const globalErrorHandler = new GlobalErrorHandler(logCollector)
globalErrorHandler.init()
```

### 2. APIæ€§èƒ½ç›‘æ§ç³»ç»Ÿ

#### HTTPæ‹¦æˆªå™¨å®ç°
```typescript
// src/utils/logging/interceptors/ApiInterceptor.ts
export class ApiPerformanceInterceptor {
  private collector: ILogCollector
  
  constructor(collector: ILogCollector) {
    this.collector = collector
  }
  
  setupAxiosInterceptors(axiosInstance: AxiosInstance): void {
    // è¯·æ±‚æ‹¦æˆªå™¨ - è®°å½•å¼€å§‹æ—¶é—´
    axiosInstance.interceptors.request.use(
      (config) => {
        config.metadata = {
          startTime: performance.now(),
          url: config.url,
          method: config.method?.toUpperCase(),
          page: location.pathname
        }
        return config
      },
      (error) => {
        this.logApiError('REQUEST_ERROR', error)
        return Promise.reject(error)
      }
    )
    
    // å“åº”æ‹¦æˆªå™¨ - è®°å½•æ€§èƒ½æ•°æ®
    axiosInstance.interceptors.response.use(
      (response) => {
        const { startTime, url, method, page } = response.config.metadata || {}
        const duration = performance.now() - (startTime || 0)
        
        this.collector.collect({
          type: 'api_performance',
          level: duration > 2000 ? 'WARN' : 'INFO',
          message: `${method} ${url} - ${response.status}`,
          data: {
            method,
            url,
            status: response.status,
            duration: Math.round(duration),
            page,
            responseSize: JSON.stringify(response.data).length,
            requestSize: JSON.stringify(response.config.data || {}).length
          },
          timestamp: Date.now(),
          category: 'api'
        })
        
        // æ…¢APIå‘Šè­¦
        if (duration > 2000) {
          this.triggerSlowApiAlert(method, url, duration, page)
        }
        
        return response
      },
      (error) => {
        const { startTime, url, method, page } = error.config?.metadata || {}
        const duration = startTime ? performance.now() - startTime : 0
        
        this.collector.collect({
          type: 'api_error',
          level: 'ERROR',
          message: `${method} ${url} - ${error.response?.status || 'Network Error'}`,
          data: {
            method,
            url,
            status: error.response?.status,
            duration: Math.round(duration),
            page,
            errorMessage: error.message,
            errorCode: error.code
          },
          timestamp: Date.now(),
          category: 'api'
        })
        
        return Promise.reject(error)
      }
    )
  }
  
  private triggerSlowApiAlert(method: string, url: string, duration: number, page: string): void {
    // æ…¢APIå‘Šè­¦é€»è¾‘
    this.collector.collect({
      type: 'slow_api_alert',
      level: 'WARN',
      message: `æ…¢APIæ£€æµ‹: ${method} ${url} è€—æ—¶ ${Math.round(duration)}ms`,
      data: {
        method,
        url,
        duration: Math.round(duration),
        page,
        threshold: 2000,
        severity: duration > 5000 ? 'high' : 'medium'
      },
      timestamp: Date.now(),
      category: 'performance',
      priority: 'high'
    })
  }
}
```

### 3. é¡µé¢æ€§èƒ½ç›‘æ§ç³»ç»Ÿ

#### æ€§èƒ½æŒ‡æ ‡æ”¶é›†
```typescript
// src/utils/logging/performance/PerformanceMonitor.ts
export class PerformanceMonitor {
  private collector: ILogCollector
  private observer: PerformanceObserver | null = null
  
  constructor(collector: ILogCollector) {
    this.collector = collector
  }
  
  init(): void {
    // é¡µé¢åŠ è½½æ€§èƒ½ç›‘æ§
    this.monitorPageLoad()
    
    // è¿è¡Œæ—¶æ€§èƒ½ç›‘æ§
    this.monitorRuntime()
    
    // è·¯ç”±å˜åŒ–æ€§èƒ½ç›‘æ§
    this.monitorRouteChanges()
  }
  
  private monitorPageLoad(): void {
    window.addEventListener('load', () => {
      setTimeout(() => {
        const perfData = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
        
        this.collector.collect({
          type: 'page_performance',
          level: 'INFO',
          message: `é¡µé¢åŠ è½½å®Œæˆ: ${location.pathname}`,
          data: {
            url: location.href,
            loadTime: Math.round(perfData.loadEventEnd - perfData.navigationStart),
            domContentLoaded: Math.round(perfData.domContentLoadedEventEnd - perfData.navigationStart),
            firstPaint: this.getFirstPaint(),
            firstContentfulPaint: this.getFirstContentfulPaint(),
            memoryUsage: this.getMemoryUsage(),
            connectionType: this.getConnectionType(),
            deviceInfo: this.getDeviceInfo()
          },
          timestamp: Date.now(),
          category: 'performance'
        })
      }, 100)
    })
  }
  
  private monitorRuntime(): void {
    if ('PerformanceObserver' in window) {
      this.observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === 'measure' || entry.entryType === 'mark') {
            this.collector.collect({
              type: 'runtime_performance',
              level: entry.duration > 100 ? 'WARN' : 'INFO',
              message: `æ€§èƒ½æ ‡è®°: ${entry.name}`,
              data: {
                name: entry.name,
                duration: Math.round(entry.duration),
                startTime: Math.round(entry.startTime),
                entryType: entry.entryType
              },
              timestamp: Date.now(),
              category: 'performance'
            })
          }
        })
      })
      
      this.observer.observe({ entryTypes: ['measure', 'mark'] })
    }
  }
  
  private getMemoryUsage(): any {
    if ('memory' in performance) {
      const memory = (performance as any).memory
      return {
        usedJSHeapSize: memory.usedJSHeapSize,
        totalJSHeapSize: memory.totalJSHeapSize,
        jsHeapSizeLimit: memory.jsHeapSizeLimit
      }
    }
    return null
  }
  
  private getConnectionType(): string {
    if ('connection' in navigator) {
      const connection = (navigator as any).connection
      return connection.effectiveType || connection.type || 'unknown'
    }
    return 'unknown'
  }
  
  // è·¯ç”±æ€§èƒ½ç›‘æ§
  monitorRouteChange(from: string, to: string, duration: number): void {
    this.collector.collect({
      type: 'route_performance',
      level: duration > 1000 ? 'WARN' : 'INFO',
      message: `è·¯ç”±åˆ‡æ¢: ${from} â†’ ${to}`,
      data: {
        from,
        to,
        duration: Math.round(duration),
        memoryBefore: this.getMemoryUsage(),
        timestamp: Date.now()
      },
      category: 'navigation'
    })
  }
}
```

### 4. ç”¨æˆ·æ“ä½œè½¨è¿¹ç³»ç»Ÿ

#### ç”¨æˆ·è¡Œä¸ºè¿½è¸ª
```typescript
// src/utils/logging/tracking/UserTracker.ts
export class UserTracker {
  private collector: ILogCollector
  private sessionId: string
  private actionSequence: number = 0
  private lastAction: UserAction | null = null
  
  constructor(collector: ILogCollector) {
    this.collector = collector
    this.sessionId = this.generateSessionId()
    this.init()
  }
  
  init(): void {
    // é¡µé¢ç‚¹å‡»è¿½è¸ª
    this.trackClicks()
    
    // è¡¨å•äº¤äº’è¿½è¸ª
    this.trackFormInteractions()
    
    // è·¯ç”±å˜åŒ–è¿½è¸ª
    this.trackRouteChanges()
    
    // é¡µé¢å¯è§æ€§å˜åŒ–
    this.trackVisibilityChanges()
  }
  
  private trackClicks(): void {
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement
      
      // åªè¿½è¸ªé‡è¦å…ƒç´ 
      if (this.isImportantElement(target)) {
        this.recordAction({
          type: 'click',
          element: this.getElementSelector(target),
          text: target.textContent?.substring(0, 100),
          position: { x: event.clientX, y: event.clientY },
          timestamp: Date.now()
        })
      }
    })
  }
  
  private trackFormInteractions(): void {
    // è¡¨å•æäº¤
    document.addEventListener('submit', (event) => {
      const form = event.target as HTMLFormElement
      this.recordAction({
        type: 'form_submit',
        element: this.getElementSelector(form),
        formData: this.getFormSummary(form),
        timestamp: Date.now()
      })
    })
    
    // é‡è¦è¾“å…¥æ¡†å˜åŒ–
    document.addEventListener('change', (event) => {
      const target = event.target as HTMLInputElement
      if (target.type === 'email' || target.type === 'password' || target.required) {
        this.recordAction({
          type: 'form_input',
          element: this.getElementSelector(target),
          inputType: target.type,
          hasValue: !!target.value,
          timestamp: Date.now()
        })
      }
    })
  }
  
  private recordAction(action: UserAction): void {
    const enrichedAction = {
      ...action,
      sequence: ++this.actionSequence,
      sessionId: this.sessionId,
      url: location.href,
      userAgent: navigator.userAgent,
      viewportSize: `${window.innerWidth}x${window.innerHeight}`,
      timeSinceLastAction: this.lastAction 
        ? action.timestamp - this.lastAction.timestamp 
        : 0
    }
    
    this.collector.collect({
      type: 'user_action',
      level: 'INFO',
      message: `ç”¨æˆ·æ“ä½œ: ${action.type}`,
      data: enrichedAction,
      timestamp: action.timestamp,
      category: 'user_behavior',
      sessionId: this.sessionId
    })
    
    this.lastAction = enrichedAction
  }
  
  // ç”Ÿæˆç”¨æˆ·æ“ä½œè·¯å¾„
  generateUserPath(timeWindow: number = 300000): UserPath {
    // ä»æœ€è¿‘çš„æ“ä½œä¸­ç”Ÿæˆç”¨æˆ·è·¯å¾„
    const recentActions = this.getRecentActions(timeWindow)
    
    return {
      sessionId: this.sessionId,
      startTime: recentActions[0]?.timestamp,
      endTime: recentActions[recentActions.length - 1]?.timestamp,
      steps: recentActions.map(action => ({
        action: action.type,
        element: action.element,
        timestamp: action.timestamp,
        duration: action.timeSinceLastAction
      })),
      totalDuration: recentActions.length > 1 
        ? recentActions[recentActions.length - 1].timestamp - recentActions[0].timestamp
        : 0
    }
  }
}
```

### 5. å®æ—¶å‘Šè­¦é€šçŸ¥ç³»ç»Ÿ

#### å‘Šè­¦è§„åˆ™å¼•æ“
```typescript
// src/utils/logging/alerting/AlertEngine.ts
export class AlertEngine {
  private rules: AlertRule[] = []
  private recentAlerts = new Map<string, number>()
  private readonly ALERT_COOLDOWN = 60000 // 1åˆ†é’Ÿå†·å´
  
  constructor() {
    this.initDefaultRules()
  }
  
  private initDefaultRules(): void {
    this.rules = [
      // JavaScripté”™è¯¯å‘Šè­¦
      {
        id: 'js_error',
        name: 'JavaScripté”™è¯¯',
        condition: (log) => log.type === 'javascript' && log.level === 'ERROR',
        severity: 'high',
        cooldown: 30000,
        action: 'immediate_notify'
      },
      
      // æ…¢APIå‘Šè­¦
      {
        id: 'slow_api',
        name: 'æ…¢APIå‘Šè­¦',
        condition: (log) => log.type === 'api_performance' && log.data?.duration > 5000,
        severity: 'medium',
        cooldown: 300000, // 5åˆ†é’Ÿ
        action: 'batch_notify'
      },
      
      // æ‰¹é‡é”™è¯¯å‘Šè­¦
      {
        id: 'error_spike',
        name: 'é”™è¯¯æ¿€å¢å‘Šè­¦',
        condition: (logs) => this.countRecentErrors(logs, 60000) > 10,
        severity: 'critical',
        cooldown: 600000, // 10åˆ†é’Ÿ
        action: 'urgent_notify'
      },
      
      // ç”¨æˆ·ä½“éªŒå¼‚å¸¸
      {
        id: 'ux_degradation',
        name: 'ç”¨æˆ·ä½“éªŒå¼‚å¸¸',
        condition: (log) => log.type === 'page_performance' && log.data?.loadTime > 10000,
        severity: 'medium',
        cooldown: 180000, // 3åˆ†é’Ÿ
        action: 'notify'
      }
    ]
  }
  
  evaluateLog(log: LogEntry, recentLogs: LogEntry[]): void {
    this.rules.forEach(rule => {
      const alertKey = `${rule.id}_${this.getAlertKey(log)}`
      
      // æ£€æŸ¥å†·å´æœŸ
      const lastAlert = this.recentAlerts.get(alertKey)
      if (lastAlert && Date.now() - lastAlert < rule.cooldown) {
        return
      }
      
      // è¯„ä¼°å‘Šè­¦æ¡ä»¶
      let shouldAlert = false
      if (typeof rule.condition === 'function') {
        shouldAlert = rule.condition(log, recentLogs)
      }
      
      if (shouldAlert) {
        this.triggerAlert(rule, log, alertKey)
      }
    })
  }
  
  private triggerAlert(rule: AlertRule, log: LogEntry, alertKey: string): void {
    const alert: Alert = {
      id: this.generateAlertId(),
      ruleId: rule.id,
      ruleName: rule.name,
      severity: rule.severity,
      message: this.generateAlertMessage(rule, log),
      triggerLog: log,
      timestamp: Date.now(),
      status: 'active'
    }
    
    // è®°å½•å‘Šè­¦æ—¶é—´
    this.recentAlerts.set(alertKey, Date.now())
    
    // æ‰§è¡Œå‘Šè­¦åŠ¨ä½œ
    this.executeAlertAction(rule.action, alert)
  }
  
  private executeAlertAction(action: string, alert: Alert): void {
    switch (action) {
      case 'immediate_notify':
        this.sendImmediateNotification(alert)
        break
        
      case 'urgent_notify':
        this.sendUrgentNotification(alert)
        break
        
      case 'batch_notify':
        this.addToBatchNotification(alert)
        break
        
      case 'notify':
        this.sendStandardNotification(alert)
        break
    }
  }
  
  private sendImmediateNotification(alert: Alert): void {
    // æµè§ˆå™¨é€šçŸ¥
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(`${alert.ruleName}`, {
        body: alert.message,
        icon: '/favicon.ico',
        tag: alert.ruleId
      })
    }
    
    // æ§åˆ¶å°è¾“å‡º
    console.error(`ğŸš¨ [å‘Šè­¦] ${alert.ruleName}: ${alert.message}`)
    
    // å‘é€åˆ°æœåŠ¡å™¨
    this.sendAlertToServer(alert)
  }
  
  private async sendAlertToServer(alert: Alert): Promise<void> {
    try {
      await fetch('/api/alerts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Client-ID': this.getClientId()
        },
        body: JSON.stringify({
          alert,
          clientInfo: {
            url: location.href,
            userAgent: navigator.userAgent,
            timestamp: Date.now()
          }
        })
      })
    } catch (error) {
      console.error('Failed to send alert to server:', error)
    }
  }
}
```

## ğŸŒ æœåŠ¡ç«¯é›†æˆæ–¹æ¡ˆ

### APIè®¾è®¡
```csharp
// Controllers/LogsController.cs
[ApiController]
[Route("api/[controller]")]
public class LogsController : ControllerBase
{
    [HttpPost("batch")]
    public async Task<IActionResult> ReceiveBatchLogs([FromBody] CompressedLogBatch batch)
    {
        var logs = await DecompressAndValidateLogs(batch);
        await _logService.StoreBatchLogs(logs, GetClientId());
        return Ok(new { received = logs.Count, timestamp = DateTime.UtcNow });
    }
    
    [HttpGet("dashboard")]
    public async Task<IActionResult> GetDashboard()
    {
        var dashboard = await _logAnalysisService.GenerateDashboard();
        return Ok(dashboard);
    }
}
```

### æ•°æ®åº“è®¾è®¡
```sql
-- å®¢æˆ·ç«¯æ—¥å¿—è¡¨
CREATE TABLE ClientLogs (
    Id NVARCHAR(50) PRIMARY KEY,
    ClientId NVARCHAR(100) NOT NULL,
    SessionId NVARCHAR(100) NOT NULL,
    Type NVARCHAR(50) NOT NULL,
    Level NVARCHAR(20) NOT NULL,
    Message NVARCHAR(MAX) NOT NULL,
    Data NVARCHAR(MAX),
    Stack NVARCHAR(MAX),
    Url NVARCHAR(500),
    UserAgent NVARCHAR(500),
    Timestamp DATETIME2 NOT NULL,
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    
    INDEX IX_ClientLogs_ClientId_Timestamp (ClientId, Timestamp DESC),
    INDEX IX_ClientLogs_Level_Timestamp (Level, Timestamp DESC),
    INDEX IX_ClientLogs_Type_Timestamp (Type, Timestamp DESC)
);

-- å‘Šè­¦è®°å½•è¡¨
CREATE TABLE AlertRecords (
    Id BIGINT IDENTITY PRIMARY KEY,
    ClientId NVARCHAR(100) NOT NULL,
    RuleId NVARCHAR(50) NOT NULL,
    Severity NVARCHAR(20) NOT NULL,
    Message NVARCHAR(MAX) NOT NULL,
    TriggerLogId NVARCHAR(50),
    Status NVARCHAR(20) NOT NULL,
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    ResolvedAt DATETIME2,
    
    INDEX IX_AlertRecords_ClientId_CreatedAt (ClientId, CreatedAt DESC),
    INDEX IX_AlertRecords_Status_Severity (Status, Severity)
);
```

## ğŸ“Š å¼€å‘è®¡åˆ’

### Phase 1: åŸºç¡€æ¶æ„ (Week 1-2)
**ç›®æ ‡**: å»ºç«‹ä¾èµ–æ³¨å…¥å®¹å™¨å’ŒåŸºç¡€æ¥å£

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»ºDIContainerç±»å’ŒåŸºç¡€æ¥å£
- [ ] å®ç°IndexedDBStorageåŸºç¡€åŠŸèƒ½
- [ ] åˆ›å»ºåŸºç¡€LogCollectorå®ç°
- [ ] è®¾ç½®æœåŠ¡é…ç½®ç®¡ç†
- [ ] é›†æˆåˆ°main.tså¹¶æµ‹è¯•

**äº¤ä»˜ç‰©**:
- å®Œæ•´çš„ä¾èµ–æ³¨å…¥æ¶æ„
- åŸºç¡€çš„æ—¥å¿—å­˜å‚¨åŠŸèƒ½
- å¯å·¥ä½œçš„æ—¥å¿—æ”¶é›†å™¨

### Phase 2: WebWorkeré›†æˆ (Week 3-4)
**ç›®æ ‡**: å®ç°WebWorkerå¼‚æ­¥æ—¥å¿—å¤„ç†

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»ºLogWorkerç±»å’Œæ¶ˆæ¯å¤„ç†
- [ ] å®ç°é˜Ÿåˆ—ç®¡ç†å’Œæ‰¹é‡å¤„ç†
- [ ] é›†æˆIndexedDBæ“ä½œåˆ°Worker
- [ ] å®ç°å‹ç¼©å’Œç½‘ç»œä¸Šä¼ 
- [ ] æ·»åŠ é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

**äº¤ä»˜ç‰©**:
- å®Œæ•´çš„WebWorkeræ—¥å¿—å¤„ç†ç³»ç»Ÿ
- å¯é çš„ç½‘ç»œä¸Šä¼ æœºåˆ¶
- å¤±è´¥æ¢å¤å’Œé‡è¯•åŠŸèƒ½

### Phase 3: é”™è¯¯æ•è·ç³»ç»Ÿ (Week 5-6)
**ç›®æ ‡**: å®ç°å…¨é¢çš„é”™è¯¯æ•è·æœºåˆ¶

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°GlobalErrorHandler
- [ ] æ·»åŠ JavaScript/Promise/Vueé”™è¯¯æ•è·
- [ ] å®ç°æ§åˆ¶å°é”™è¯¯æ‹¦æˆª
- [ ] é›†æˆèµ„æºåŠ è½½é”™è¯¯æ•è·
- [ ] åˆ›å»ºé”™è¯¯å±•ç¤ºç•Œé¢

**äº¤ä»˜ç‰©**:
- å®Œæ•´çš„é”™è¯¯æ•è·ç³»ç»Ÿ
- æ‰€æœ‰ç±»å‹é”™è¯¯çš„ç»Ÿä¸€å¤„ç†
- é”™è¯¯ç›‘æ§å’Œå±•ç¤ºç•Œé¢

### Phase 4: æ€§èƒ½ç›‘æ§ç³»ç»Ÿ (Week 7-8)
**ç›®æ ‡**: å®ç°APIå’Œé¡µé¢æ€§èƒ½ç›‘æ§

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°ApiPerformanceInterceptor
- [ ] åˆ›å»ºPerformanceMonitorç±»
- [ ] é›†æˆåˆ°HTTPå®¢æˆ·ç«¯
- [ ] æ·»åŠ æ…¢APIå‘Šè­¦æœºåˆ¶
- [ ] åˆ›å»ºæ€§èƒ½ç›‘æ§ç•Œé¢

**äº¤ä»˜ç‰©**:
- APIæ€§èƒ½ç›‘æ§å’Œå‘Šè­¦
- é¡µé¢æ€§èƒ½æŒ‡æ ‡æ”¶é›†
- æ€§èƒ½æ•°æ®å¯è§†åŒ–ç•Œé¢

### Phase 5: ç”¨æˆ·è¿½è¸ªå’Œå‘Šè­¦ (Week 9-10)
**ç›®æ ‡**: å®ç°ç”¨æˆ·è¡Œä¸ºè¿½è¸ªå’Œå‘Šè­¦ç³»ç»Ÿ

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°UserTrackerç±»
- [ ] åˆ›å»ºAlertEngineå‘Šè­¦å¼•æ“
- [ ] å®ç°å‘Šè­¦è§„åˆ™é…ç½®
- [ ] æ·»åŠ é€šçŸ¥æœºåˆ¶
- [ ] åˆ›å»ºç”¨æˆ·è¡Œä¸ºåˆ†æç•Œé¢

**äº¤ä»˜ç‰©**:
- å®Œæ•´çš„ç”¨æˆ·è¡Œä¸ºè¿½è¸ª
- æ™ºèƒ½å‘Šè­¦ç³»ç»Ÿ
- ç”¨æˆ·è·¯å¾„åˆ†æåŠŸèƒ½

### Phase 6: æœåŠ¡ç«¯é›†æˆ (Week 11-12)
**ç›®æ ‡**: å®ŒæˆæœåŠ¡ç«¯æ¥æ”¶å’Œåˆ†æç³»ç»Ÿ

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»ºæœåŠ¡ç«¯APIæ¥å£
- [ ] å®ç°æ•°æ®åº“å­˜å‚¨é€»è¾‘
- [ ] åˆ›å»ºæ—¥å¿—åˆ†ææœåŠ¡
- [ ] å®ç°å¼€å‘å•†ç›‘æ§åå°
- [ ] é›†æˆå‘Šè­¦é€šçŸ¥æœåŠ¡

**äº¤ä»˜ç‰©**:
- å®Œæ•´çš„æœåŠ¡ç«¯æ—¥å¿—ç³»ç»Ÿ
- å¼€å‘å•†ç›‘æ§å’Œåˆ†æåå°
- ç«¯åˆ°ç«¯çš„æ—¥å¿—ç®¡ç†é—­ç¯

## ğŸ”§ éƒ¨ç½²å’Œè¿ç»´

### ç¯å¢ƒé…ç½®
```bash
# å¼€å‘ç¯å¢ƒ
VITE_LOG_LEVEL=DEBUG
VITE_LOG_API_URL=http://localhost:5000
VITE_ENABLE_CONSOLE_CAPTURE=true
VITE_MAX_LOG_BATCH_SIZE=10

# ç”Ÿäº§ç¯å¢ƒ  
VITE_LOG_LEVEL=WARN
VITE_LOG_API_URL=https://logs.yourdomain.com
VITE_ENABLE_CONSOLE_CAPTURE=true
VITE_MAX_LOG_BATCH_SIZE=50
```

### ç›‘æ§æŒ‡æ ‡
- **æ—¥å¿—æ”¶é›†ç‡**: ç›®æ ‡ >99%
- **ä¸Šä¼ æˆåŠŸç‡**: ç›®æ ‡ >95%
- **å¤„ç†å»¶è¿Ÿ**: ç›®æ ‡ <5ç§’
- **å­˜å‚¨æ•ˆç‡**: ç›®æ ‡å‹ç¼©ç‡ >60%
- **å‘Šè­¦åŠæ—¶æ€§**: ç›®æ ‡ <30ç§’

### æˆåŠŸæ ‡å‡†
1. **å®Œæ•´æ€§**: æ‰€æœ‰é”™è¯¯ç±»å‹100%æ•è·
2. **å¯é æ€§**: ç½‘ç»œå¼‚å¸¸æ—¶ä¸ä¸¢å¤±æ—¥å¿—
3. **æ€§èƒ½**: ä¸å½±å“ä¸»åº”ç”¨å“åº”é€Ÿåº¦
4. **å¯ç”¨æ€§**: æœåŠ¡ç«¯å¯æŸ¥çœ‹æ‰€æœ‰å®¢æˆ·ç«¯æ—¥å¿—
5. **æ™ºèƒ½æ€§**: è‡ªåŠ¨è¯†åˆ«å’Œå‘Šè­¦é‡è¦é—®é¢˜

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2024-01-15  
**æœ€åæ›´æ–°**: 2024-01-15  
**è´Ÿè´£äºº**: å¼€å‘å›¢é˜Ÿ  
**å®¡æ ¸çŠ¶æ€**: å¾…å®¡æ ¸
