# 日志管理系统架构设计和开发计划

## 📋 项目概述

### 目标
构建一个**企业级前端日志管理系统**，实现从客户端错误捕获到服务端分析的完整闭环，为软件开发商提供实时的客户端监控和问题诊断能力。

### 核心需求
1. **完整错误捕获** - 捕获所有类型的前端错误（JS错误、Vue错误、Promise错误、控制台错误）
2. **性能监控** - API调用性能、页面加载性能监控
3. **用户行为追踪** - 关键操作路径记录
4. **实时告警** - 严重问题立即通知
5. **服务端可见** - 开发商能够看到所有客户端日志
6. **务实可靠** - 异步处理、依赖可控、不影响主应用性能

## 🏗️ 整体架构设计

### 系统架构图
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   客户端错误     │───▶│   WebWorker      │───▶│   IndexedDB     │
│   发生/捕获     │    │   异步处理队列    │    │   本地持久化    │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │
                              ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   服务端API     │◀───│   批量压缩上传    │    │   网络重试机制   │
│   日志接收      │    │   智能调度       │    │   失败恢复      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │
         ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   数据库存储     │───▶│   日志分析引擎    │───▶│   开发商后台     │
│   结构化数据     │    │   智能统计       │    │   监控面板      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

### 技术栈选择
- **前端框架**: Vue 3 + TypeScript + Pinia
- **工具库**: Element Plus + ECharts
- **存储方案**: IndexedDB (客户端) + SQL Server (服务端)
- **并发处理**: WebWorker
- **架构模式**: 依赖注入 + 接口抽象
- **通信协议**: HTTP/HTTPS + JSON
- **数据压缩**: JSON压缩 + 批量传输

## 🔧 依赖注入架构设计

### 核心接口定义
```typescript
// 存储接口
interface ILogStorage {
  save(log: LogEntry): Promise<void>
  query(filter: LogFilter): Promise<LogEntry[]>
  clear(): Promise<void>
  count(): Promise<number>
}

// 收集器接口
interface ILogCollector {
  collect(error: ErrorInfo): void
  setFilters(filters: LogFilter[]): void
}

// 格式化接口
interface ILogFormatter {
  format(log: LogEntry): FormattedLog
  formatBatch(logs: LogEntry[]): FormattedLog[]
}

// 传输接口
interface ILogTransport {
  send(logs: LogEntry[]): Promise<void>
  isAvailable(): boolean
}
```

### IoC容器实现
```typescript
// src/utils/di/Container.ts
export class DIContainer {
  private services = new Map<string, ServiceDescriptor>()
  private instances = new Map<string, any>()
  
  // 注册瞬态服务
  register<T>(token: string, factory: () => T): void {
    this.services.set(token, {
      factory,
      lifetime: 'transient'
    })
  }
  
  // 注册单例服务
  singleton<T>(token: string, factory: () => T): void {
    this.services.set(token, {
      factory,
      lifetime: 'singleton'
    })
  }
  
  // 解析服务
  resolve<T>(token: string): T {
    const descriptor = this.services.get(token)
    if (!descriptor) {
      throw new Error(`Service ${token} not registered`)
    }
    
    if (descriptor.lifetime === 'singleton') {
      if (!this.instances.has(token)) {
        this.instances.set(token, descriptor.factory())
      }
      return this.instances.get(token)
    }
    
    return descriptor.factory()
  }
  
  // 批量注册
  registerBatch(registrations: ServiceRegistration[]): void {
    registrations.forEach(({ token, factory, lifetime = 'transient' }) => {
      if (lifetime === 'singleton') {
        this.singleton(token, factory)
      } else {
        this.register(token, factory)
      }
    })
  }
}
```

### 服务配置管理
```typescript
// src/utils/logging/config/ServiceConfig.ts
export class LoggingServiceConfig {
  static configureServices(container: DIContainer, env: 'development' | 'production') {
    const registrations: ServiceRegistration[] = []
    
    if (env === 'development') {
      // 开发环境配置
      registrations.push(
        {
          token: 'ILogStorage',
          factory: () => new IndexedDBStorage(),
          lifetime: 'singleton'
        },
        {
          token: 'ILogTransport', 
          factory: () => new ConsoleTransport(),
          lifetime: 'singleton'
        }
      )
    } else {
      // 生产环境配置
      registrations.push(
        {
          token: 'ILogStorage',
          factory: () => new RemoteStorage(process.env.VITE_LOG_API_URL!),
          lifetime: 'singleton'
        },
        {
          token: 'ILogTransport',
          factory: () => new BatchTransport(process.env.VITE_LOG_API_URL!),
          lifetime: 'singleton'
        }
      )
    }
    
    // 通用服务注册
    registrations.push(
      {
        token: 'ILogFormatter',
        factory: () => new StructuredLogFormatter(),
        lifetime: 'singleton'
      },
      {
        token: 'ILogCollector',
        factory: () => new WebWorkerLogCollector(
          container.resolve<ILogStorage>('ILogStorage'),
          container.resolve<ILogFormatter>('ILogFormatter')
        ),
        lifetime: 'singleton'
      }
    )
    
    container.registerBatch(registrations)
  }
}
```

## ⚡ WebWorker + IndexedDB 设计

### WebWorker架构设计

#### 核心优势
1. **非阻塞处理** - 所有日志处理在后台线程进行
2. **独立内存空间** - 不占用主线程内存资源
3. **并行计算能力** - 可进行数据压缩、加密、复杂分析
4. **容错隔离** - Worker崩溃不影响主应用
5. **持久化存储** - 直接在Worker中操作IndexedDB

#### Worker实现架构
```typescript
// src/workers/logWorker.ts
class LogWorker {
  private queue: LogEntry[] = []                    // 内存队列
  private db: IDBDatabase | null = null             // IndexedDB连接
  private isProcessing = false                      // 处理状态标志
  private readonly BATCH_SIZE = 20                  // 批量处理大小
  private readonly PROCESS_INTERVAL = 30000         // 处理间隔30秒
  private readonly MAX_RETRY_COUNT = 3              // 最大重试次数
  
  constructor() {
    this.initIndexedDB()                           // 初始化数据库
    this.startProcessingLoop()                     // 启动处理循环
    this.recoverPendingLogs()                      // 恢复待处理日志
  }
  
  // 消息处理路由
  handleMessage = (event: MessageEvent) => {
    const { type, data, id } = event.data
    
    switch (type) {
      case 'ADD_LOG':
        this.addToQueue(data)
        this.sendResponse(id, 'LOG_RECEIVED', { status: 'queued' })
        break
        
      case 'FORCE_UPLOAD':
        this.processQueue()
        break
        
      case 'GET_STATS':
        this.sendStats(id)
        break
        
      case 'CLEAR_LOGS':
        this.clearAllLogs()
        break
    }
  }
  
  // 队列管理
  private addToQueue(log: LogEntry) {
    const enrichedLog = {
      ...log,
      workerReceivedAt: Date.now(),
      status: 'pending',
      retryCount: 0
    }
    
    this.queue.push(enrichedLog)
    this.saveToIndexedDB(enrichedLog)              // 立即持久化
    
    // 高优先级日志立即处理
    if (log.level === 'ERROR' || log.priority === 'high') {
      this.processQueue()
    }
  }
  
  // 批量处理队列
  private async processQueue() {
    if (this.isProcessing || this.queue.length === 0) return
    
    this.isProcessing = true
    
    try {
      // 按优先级排序
      this.queue.sort((a, b) => {
        if (a.level === 'ERROR' && b.level !== 'ERROR') return -1
        if (b.level === 'ERROR' && a.level !== 'ERROR') return 1
        return a.timestamp - b.timestamp
      })
      
      const batch = this.queue.splice(0, this.BATCH_SIZE)
      
      // 数据压缩
      const compressed = await this.compressLogBatch(batch)
      
      // 网络上传
      await this.uploadBatch(compressed, batch)
      
      // 更新状态
      await this.updateLogStatus(batch.map(l => l.id), 'uploaded')
      
      this.sendMessage('BATCH_UPLOADED', {
        count: batch.length,
        remainingInQueue: this.queue.length
      })
      
    } catch (error) {
      // 失败处理
      this.handleUploadFailure(batch, error)
    } finally {
      this.isProcessing = false
    }
  }
  
  // 数据压缩算法
  private async compressLogBatch(logs: LogEntry[]): Promise<CompressedBatch> {
    // 字段压缩映射
    const compressed = logs.map(log => ({
      i: log.id,
      t: log.timestamp,
      l: log.level,
      m: log.message,
      s: log.stack?.substring(0, 500),               // 限制堆栈长度
      u: log.url !== location.href ? log.url : undefined  // 去重URL
    }))
    
    const jsonString = JSON.stringify(compressed)
    
    return {
      data: jsonString,
      originalCount: logs.length,
      compressedSize: jsonString.length,
      compressionRatio: jsonString.length / JSON.stringify(logs).length
    }
  }
}
```

### IndexedDB数据结构设计

#### 数据库架构
```typescript
// 数据库结构设计
interface LogDatabase {
  name: 'SmartAbpLogs'
  version: 1
  stores: {
    logs: {                                       // 主日志存储
      keyPath: 'id'
      indexes: {
        timestamp: { keyPath: 'timestamp', unique: false }
        level: { keyPath: 'level', unique: false }
        status: { keyPath: 'status', unique: false }
        type: { keyPath: 'type', unique: false }
      }
    }
    
    upload_queue: {                              // 上传队列
      keyPath: 'id'
      indexes: {
        priority: { keyPath: 'priority', unique: false }
        retryCount: { keyPath: 'retryCount', unique: false }
        scheduledTime: { keyPath: 'scheduledTime', unique: false }
      }
    }
    
    client_meta: {                               // 客户端元数据
      keyPath: 'key'
      data: {
        clientId: string
        sessionId: string
        appVersion: string
        lastUploadTime: number
        totalLogsGenerated: number
        totalLogsUploaded: number
      }
    }
  }
}
```

#### 存储实现
```typescript
// src/utils/logging/storage/IndexedDBStorage.ts
export class IndexedDBStorage implements ILogStorage {
  private readonly dbName = 'SmartAbpLogs'
  private readonly version = 1
  private db: IDBDatabase | null = null
  
  async initialize(): Promise<void> {
    this.db = await new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version)
      
      request.onerror = () => reject(request.error)
      request.onsuccess = () => resolve(request.result)
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result
        this.createStores(db)
      }
    })
  }
  
  private createStores(db: IDBDatabase): void {
    // 创建日志存储表
    const logsStore = db.createObjectStore('logs', { keyPath: 'id' })
    logsStore.createIndex('timestamp', 'timestamp')
    logsStore.createIndex('level', 'level')
    logsStore.createIndex('status', 'status')
    logsStore.createIndex('type', 'type')
    
    // 创建上传队列表
    const queueStore = db.createObjectStore('upload_queue', { keyPath: 'id' })
    queueStore.createIndex('priority', 'priority')
    queueStore.createIndex('retryCount', 'retryCount')
    queueStore.createIndex('scheduledTime', 'scheduledTime')
    
    // 创建元数据表
    const metaStore = db.createObjectStore('client_meta', { keyPath: 'key' })
  }
  
  async save(log: LogEntry): Promise<void> {
    const transaction = this.db!.transaction(['logs'], 'readwrite')
    const store = transaction.objectStore('logs')
    await store.put(log)
  }
  
  async query(filter: LogFilter): Promise<LogEntry[]> {
    const transaction = this.db!.transaction(['logs'], 'readonly')
    const store = transaction.objectStore('logs')
    
    // 根据filter构建查询
    let cursor: IDBCursorWithValue | null
    
    if (filter.level) {
      const index = store.index('level')
      cursor = await index.openCursor(IDBKeyRange.only(filter.level))
    } else if (filter.timeRange) {
      const index = store.index('timestamp')
      cursor = await index.openCursor(IDBKeyRange.bound(
        filter.timeRange.start, 
        filter.timeRange.end
      ))
    } else {
      cursor = await store.openCursor()
    }
    
    const results: LogEntry[] = []
    while (cursor && results.length < (filter.limit || 100)) {
      results.push(cursor.value)
      cursor = await cursor.continue()
    }
    
    return results
  }
  
  async clear(): Promise<void> {
    const transaction = this.db!.transaction(['logs'], 'readwrite')
    const store = transaction.objectStore('logs')
    await store.clear()
  }
  
  async count(): Promise<number> {
    const transaction = this.db!.transaction(['logs'], 'readonly')
    const store = transaction.objectStore('logs')
    return await store.count()
  }
}
```

## 🔍 5大核心功能实现

### 1. 错误崩溃日志系统

#### 全局错误捕获
```typescript
// src/utils/logging/errorCapture/GlobalErrorHandler.ts
export class GlobalErrorHandler {
  private collector: ILogCollector
  
  constructor(collector: ILogCollector) {
    this.collector = collector
  }
  
  init(): void {
    // 1. JavaScript运行时错误
    window.addEventListener('error', this.handleJSError.bind(this))
    
    // 2. Promise未处理错误
    window.addEventListener('unhandledrejection', this.handlePromiseError.bind(this))
    
    // 3. 资源加载错误
    window.addEventListener('error', this.handleResourceError.bind(this), true)
    
    // 4. 控制台错误拦截 - 重点需求！
    this.interceptConsoleErrors()
  }
  
  private handleJSError(event: ErrorEvent): void {
    this.collector.collect({
      type: 'javascript',
      level: 'ERROR',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now(),
      url: location.href,
      userAgent: navigator.userAgent
    })
  }
  
  private handlePromiseError(event: PromiseRejectionEvent): void {
    this.collector.collect({
      type: 'promise',
      level: 'ERROR',
      message: String(event.reason),
      stack: event.reason?.stack,
      timestamp: Date.now(),
      url: location.href
    })
  }
  
  private handleResourceError(event: Event): void {
    const target = event.target as HTMLElement
    if (target && target !== window) {
      this.collector.collect({
        type: 'resource',
        level: 'ERROR',
        message: `Resource failed to load: ${target.tagName}`,
        source: (target as any).src || (target as any).href,
        timestamp: Date.now(),
        url: location.href
      })
    }
  }
  
  // 控制台错误拦截 - 核心功能
  private interceptConsoleErrors(): void {
    const originalError = console.error
    const originalWarn = console.warn
    
    console.error = (...args) => {
      // 记录到我们的系统
      this.collector.collect({
        type: 'console',
        level: 'ERROR',
        message: args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' '),
        timestamp: Date.now(),
        url: location.href,
        source: 'console.error'
      })
      
      // 继续原有输出
      originalError.apply(console, args)
    }
    
    console.warn = (...args) => {
      this.collector.collect({
        type: 'console',
        level: 'WARN',
        message: args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' '),
        timestamp: Date.now(),
        url: location.href,
        source: 'console.warn'
      })
      
      originalWarn.apply(console, args)
    }
  }
}
```

#### Vue错误处理集成
```typescript
// src/main.ts - Vue错误处理器集成
const app = createApp(App)
const container = new DIContainer()

// 配置服务
LoggingServiceConfig.configureServices(container, import.meta.env.MODE as any)

// 获取日志收集器
const logCollector = container.resolve<ILogCollector>('ILogCollector')

// Vue错误处理器
app.config.errorHandler = (err: any, instance: any, info: string) => {
  logCollector.collect({
    type: 'vue',
    level: 'ERROR',
    message: err.message || String(err),
    stack: err.stack,
    componentName: instance?.$options.name || 'Unknown',
    errorInfo: info,
    timestamp: Date.now(),
    url: location.href,
    vueVersion: app.version
  })
}

// 启动全局错误处理
const globalErrorHandler = new GlobalErrorHandler(logCollector)
globalErrorHandler.init()
```

### 2. API性能监控系统

#### HTTP拦截器实现
```typescript
// src/utils/logging/interceptors/ApiInterceptor.ts
export class ApiPerformanceInterceptor {
  private collector: ILogCollector
  
  constructor(collector: ILogCollector) {
    this.collector = collector
  }
  
  setupAxiosInterceptors(axiosInstance: AxiosInstance): void {
    // 请求拦截器 - 记录开始时间
    axiosInstance.interceptors.request.use(
      (config) => {
        config.metadata = {
          startTime: performance.now(),
          url: config.url,
          method: config.method?.toUpperCase(),
          page: location.pathname
        }
        return config
      },
      (error) => {
        this.logApiError('REQUEST_ERROR', error)
        return Promise.reject(error)
      }
    )
    
    // 响应拦截器 - 记录性能数据
    axiosInstance.interceptors.response.use(
      (response) => {
        const { startTime, url, method, page } = response.config.metadata || {}
        const duration = performance.now() - (startTime || 0)
        
        this.collector.collect({
          type: 'api_performance',
          level: duration > 2000 ? 'WARN' : 'INFO',
          message: `${method} ${url} - ${response.status}`,
          data: {
            method,
            url,
            status: response.status,
            duration: Math.round(duration),
            page,
            responseSize: JSON.stringify(response.data).length,
            requestSize: JSON.stringify(response.config.data || {}).length
          },
          timestamp: Date.now(),
          category: 'api'
        })
        
        // 慢API告警
        if (duration > 2000) {
          this.triggerSlowApiAlert(method, url, duration, page)
        }
        
        return response
      },
      (error) => {
        const { startTime, url, method, page } = error.config?.metadata || {}
        const duration = startTime ? performance.now() - startTime : 0
        
        this.collector.collect({
          type: 'api_error',
          level: 'ERROR',
          message: `${method} ${url} - ${error.response?.status || 'Network Error'}`,
          data: {
            method,
            url,
            status: error.response?.status,
            duration: Math.round(duration),
            page,
            errorMessage: error.message,
            errorCode: error.code
          },
          timestamp: Date.now(),
          category: 'api'
        })
        
        return Promise.reject(error)
      }
    )
  }
  
  private triggerSlowApiAlert(method: string, url: string, duration: number, page: string): void {
    // 慢API告警逻辑
    this.collector.collect({
      type: 'slow_api_alert',
      level: 'WARN',
      message: `慢API检测: ${method} ${url} 耗时 ${Math.round(duration)}ms`,
      data: {
        method,
        url,
        duration: Math.round(duration),
        page,
        threshold: 2000,
        severity: duration > 5000 ? 'high' : 'medium'
      },
      timestamp: Date.now(),
      category: 'performance',
      priority: 'high'
    })
  }
}
```

### 3. 页面性能监控系统

#### 性能指标收集
```typescript
// src/utils/logging/performance/PerformanceMonitor.ts
export class PerformanceMonitor {
  private collector: ILogCollector
  private observer: PerformanceObserver | null = null
  
  constructor(collector: ILogCollector) {
    this.collector = collector
  }
  
  init(): void {
    // 页面加载性能监控
    this.monitorPageLoad()
    
    // 运行时性能监控
    this.monitorRuntime()
    
    // 路由变化性能监控
    this.monitorRouteChanges()
  }
  
  private monitorPageLoad(): void {
    window.addEventListener('load', () => {
      setTimeout(() => {
        const perfData = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
        
        this.collector.collect({
          type: 'page_performance',
          level: 'INFO',
          message: `页面加载完成: ${location.pathname}`,
          data: {
            url: location.href,
            loadTime: Math.round(perfData.loadEventEnd - perfData.navigationStart),
            domContentLoaded: Math.round(perfData.domContentLoadedEventEnd - perfData.navigationStart),
            firstPaint: this.getFirstPaint(),
            firstContentfulPaint: this.getFirstContentfulPaint(),
            memoryUsage: this.getMemoryUsage(),
            connectionType: this.getConnectionType(),
            deviceInfo: this.getDeviceInfo()
          },
          timestamp: Date.now(),
          category: 'performance'
        })
      }, 100)
    })
  }
  
  private monitorRuntime(): void {
    if ('PerformanceObserver' in window) {
      this.observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === 'measure' || entry.entryType === 'mark') {
            this.collector.collect({
              type: 'runtime_performance',
              level: entry.duration > 100 ? 'WARN' : 'INFO',
              message: `性能标记: ${entry.name}`,
              data: {
                name: entry.name,
                duration: Math.round(entry.duration),
                startTime: Math.round(entry.startTime),
                entryType: entry.entryType
              },
              timestamp: Date.now(),
              category: 'performance'
            })
          }
        })
      })
      
      this.observer.observe({ entryTypes: ['measure', 'mark'] })
    }
  }
  
  private getMemoryUsage(): any {
    if ('memory' in performance) {
      const memory = (performance as any).memory
      return {
        usedJSHeapSize: memory.usedJSHeapSize,
        totalJSHeapSize: memory.totalJSHeapSize,
        jsHeapSizeLimit: memory.jsHeapSizeLimit
      }
    }
    return null
  }
  
  private getConnectionType(): string {
    if ('connection' in navigator) {
      const connection = (navigator as any).connection
      return connection.effectiveType || connection.type || 'unknown'
    }
    return 'unknown'
  }
  
  // 路由性能监控
  monitorRouteChange(from: string, to: string, duration: number): void {
    this.collector.collect({
      type: 'route_performance',
      level: duration > 1000 ? 'WARN' : 'INFO',
      message: `路由切换: ${from} → ${to}`,
      data: {
        from,
        to,
        duration: Math.round(duration),
        memoryBefore: this.getMemoryUsage(),
        timestamp: Date.now()
      },
      category: 'navigation'
    })
  }
}
```

### 4. 用户操作轨迹系统

#### 用户行为追踪
```typescript
// src/utils/logging/tracking/UserTracker.ts
export class UserTracker {
  private collector: ILogCollector
  private sessionId: string
  private actionSequence: number = 0
  private lastAction: UserAction | null = null
  
  constructor(collector: ILogCollector) {
    this.collector = collector
    this.sessionId = this.generateSessionId()
    this.init()
  }
  
  init(): void {
    // 页面点击追踪
    this.trackClicks()
    
    // 表单交互追踪
    this.trackFormInteractions()
    
    // 路由变化追踪
    this.trackRouteChanges()
    
    // 页面可见性变化
    this.trackVisibilityChanges()
  }
  
  private trackClicks(): void {
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement
      
      // 只追踪重要元素
      if (this.isImportantElement(target)) {
        this.recordAction({
          type: 'click',
          element: this.getElementSelector(target),
          text: target.textContent?.substring(0, 100),
          position: { x: event.clientX, y: event.clientY },
          timestamp: Date.now()
        })
      }
    })
  }
  
  private trackFormInteractions(): void {
    // 表单提交
    document.addEventListener('submit', (event) => {
      const form = event.target as HTMLFormElement
      this.recordAction({
        type: 'form_submit',
        element: this.getElementSelector(form),
        formData: this.getFormSummary(form),
        timestamp: Date.now()
      })
    })
    
    // 重要输入框变化
    document.addEventListener('change', (event) => {
      const target = event.target as HTMLInputElement
      if (target.type === 'email' || target.type === 'password' || target.required) {
        this.recordAction({
          type: 'form_input',
          element: this.getElementSelector(target),
          inputType: target.type,
          hasValue: !!target.value,
          timestamp: Date.now()
        })
      }
    })
  }
  
  private recordAction(action: UserAction): void {
    const enrichedAction = {
      ...action,
      sequence: ++this.actionSequence,
      sessionId: this.sessionId,
      url: location.href,
      userAgent: navigator.userAgent,
      viewportSize: `${window.innerWidth}x${window.innerHeight}`,
      timeSinceLastAction: this.lastAction 
        ? action.timestamp - this.lastAction.timestamp 
        : 0
    }
    
    this.collector.collect({
      type: 'user_action',
      level: 'INFO',
      message: `用户操作: ${action.type}`,
      data: enrichedAction,
      timestamp: action.timestamp,
      category: 'user_behavior',
      sessionId: this.sessionId
    })
    
    this.lastAction = enrichedAction
  }
  
  // 生成用户操作路径
  generateUserPath(timeWindow: number = 300000): UserPath {
    // 从最近的操作中生成用户路径
    const recentActions = this.getRecentActions(timeWindow)
    
    return {
      sessionId: this.sessionId,
      startTime: recentActions[0]?.timestamp,
      endTime: recentActions[recentActions.length - 1]?.timestamp,
      steps: recentActions.map(action => ({
        action: action.type,
        element: action.element,
        timestamp: action.timestamp,
        duration: action.timeSinceLastAction
      })),
      totalDuration: recentActions.length > 1 
        ? recentActions[recentActions.length - 1].timestamp - recentActions[0].timestamp
        : 0
    }
  }
}
```

### 5. 实时告警通知系统

#### 告警规则引擎
```typescript
// src/utils/logging/alerting/AlertEngine.ts
export class AlertEngine {
  private rules: AlertRule[] = []
  private recentAlerts = new Map<string, number>()
  private readonly ALERT_COOLDOWN = 60000 // 1分钟冷却
  
  constructor() {
    this.initDefaultRules()
  }
  
  private initDefaultRules(): void {
    this.rules = [
      // JavaScript错误告警
      {
        id: 'js_error',
        name: 'JavaScript错误',
        condition: (log) => log.type === 'javascript' && log.level === 'ERROR',
        severity: 'high',
        cooldown: 30000,
        action: 'immediate_notify'
      },
      
      // 慢API告警
      {
        id: 'slow_api',
        name: '慢API告警',
        condition: (log) => log.type === 'api_performance' && log.data?.duration > 5000,
        severity: 'medium',
        cooldown: 300000, // 5分钟
        action: 'batch_notify'
      },
      
      // 批量错误告警
      {
        id: 'error_spike',
        name: '错误激增告警',
        condition: (logs) => this.countRecentErrors(logs, 60000) > 10,
        severity: 'critical',
        cooldown: 600000, // 10分钟
        action: 'urgent_notify'
      },
      
      // 用户体验异常
      {
        id: 'ux_degradation',
        name: '用户体验异常',
        condition: (log) => log.type === 'page_performance' && log.data?.loadTime > 10000,
        severity: 'medium',
        cooldown: 180000, // 3分钟
        action: 'notify'
      }
    ]
  }
  
  evaluateLog(log: LogEntry, recentLogs: LogEntry[]): void {
    this.rules.forEach(rule => {
      const alertKey = `${rule.id}_${this.getAlertKey(log)}`
      
      // 检查冷却期
      const lastAlert = this.recentAlerts.get(alertKey)
      if (lastAlert && Date.now() - lastAlert < rule.cooldown) {
        return
      }
      
      // 评估告警条件
      let shouldAlert = false
      if (typeof rule.condition === 'function') {
        shouldAlert = rule.condition(log, recentLogs)
      }
      
      if (shouldAlert) {
        this.triggerAlert(rule, log, alertKey)
      }
    })
  }
  
  private triggerAlert(rule: AlertRule, log: LogEntry, alertKey: string): void {
    const alert: Alert = {
      id: this.generateAlertId(),
      ruleId: rule.id,
      ruleName: rule.name,
      severity: rule.severity,
      message: this.generateAlertMessage(rule, log),
      triggerLog: log,
      timestamp: Date.now(),
      status: 'active'
    }
    
    // 记录告警时间
    this.recentAlerts.set(alertKey, Date.now())
    
    // 执行告警动作
    this.executeAlertAction(rule.action, alert)
  }
  
  private executeAlertAction(action: string, alert: Alert): void {
    switch (action) {
      case 'immediate_notify':
        this.sendImmediateNotification(alert)
        break
        
      case 'urgent_notify':
        this.sendUrgentNotification(alert)
        break
        
      case 'batch_notify':
        this.addToBatchNotification(alert)
        break
        
      case 'notify':
        this.sendStandardNotification(alert)
        break
    }
  }
  
  private sendImmediateNotification(alert: Alert): void {
    // 浏览器通知
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(`${alert.ruleName}`, {
        body: alert.message,
        icon: '/favicon.ico',
        tag: alert.ruleId
      })
    }
    
    // 控制台输出
    console.error(`🚨 [告警] ${alert.ruleName}: ${alert.message}`)
    
    // 发送到服务器
    this.sendAlertToServer(alert)
  }
  
  private async sendAlertToServer(alert: Alert): Promise<void> {
    try {
      await fetch('/api/alerts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Client-ID': this.getClientId()
        },
        body: JSON.stringify({
          alert,
          clientInfo: {
            url: location.href,
            userAgent: navigator.userAgent,
            timestamp: Date.now()
          }
        })
      })
    } catch (error) {
      console.error('Failed to send alert to server:', error)
    }
  }
}
```

## 🌐 服务端集成方案

### API设计
```csharp
// Controllers/LogsController.cs
[ApiController]
[Route("api/[controller]")]
public class LogsController : ControllerBase
{
    [HttpPost("batch")]
    public async Task<IActionResult> ReceiveBatchLogs([FromBody] CompressedLogBatch batch)
    {
        var logs = await DecompressAndValidateLogs(batch);
        await _logService.StoreBatchLogs(logs, GetClientId());
        return Ok(new { received = logs.Count, timestamp = DateTime.UtcNow });
    }
    
    [HttpGet("dashboard")]
    public async Task<IActionResult> GetDashboard()
    {
        var dashboard = await _logAnalysisService.GenerateDashboard();
        return Ok(dashboard);
    }
}
```

### 数据库设计
```sql
-- 客户端日志表
CREATE TABLE ClientLogs (
    Id NVARCHAR(50) PRIMARY KEY,
    ClientId NVARCHAR(100) NOT NULL,
    SessionId NVARCHAR(100) NOT NULL,
    Type NVARCHAR(50) NOT NULL,
    Level NVARCHAR(20) NOT NULL,
    Message NVARCHAR(MAX) NOT NULL,
    Data NVARCHAR(MAX),
    Stack NVARCHAR(MAX),
    Url NVARCHAR(500),
    UserAgent NVARCHAR(500),
    Timestamp DATETIME2 NOT NULL,
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    
    INDEX IX_ClientLogs_ClientId_Timestamp (ClientId, Timestamp DESC),
    INDEX IX_ClientLogs_Level_Timestamp (Level, Timestamp DESC),
    INDEX IX_ClientLogs_Type_Timestamp (Type, Timestamp DESC)
);

-- 告警记录表
CREATE TABLE AlertRecords (
    Id BIGINT IDENTITY PRIMARY KEY,
    ClientId NVARCHAR(100) NOT NULL,
    RuleId NVARCHAR(50) NOT NULL,
    Severity NVARCHAR(20) NOT NULL,
    Message NVARCHAR(MAX) NOT NULL,
    TriggerLogId NVARCHAR(50),
    Status NVARCHAR(20) NOT NULL,
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    ResolvedAt DATETIME2,
    
    INDEX IX_AlertRecords_ClientId_CreatedAt (ClientId, CreatedAt DESC),
    INDEX IX_AlertRecords_Status_Severity (Status, Severity)
);
```

## 📊 开发计划

### Phase 1: 基础架构 (Week 1-2)
**目标**: 建立依赖注入容器和基础接口

**任务清单**:
- [ ] 创建DIContainer类和基础接口
- [ ] 实现IndexedDBStorage基础功能
- [ ] 创建基础LogCollector实现
- [ ] 设置服务配置管理
- [ ] 集成到main.ts并测试

**交付物**:
- 完整的依赖注入架构
- 基础的日志存储功能
- 可工作的日志收集器

### Phase 2: WebWorker集成 (Week 3-4)
**目标**: 实现WebWorker异步日志处理

**任务清单**:
- [ ] 创建LogWorker类和消息处理
- [ ] 实现队列管理和批量处理
- [ ] 集成IndexedDB操作到Worker
- [ ] 实现压缩和网络上传
- [ ] 添加错误处理和重试机制

**交付物**:
- 完整的WebWorker日志处理系统
- 可靠的网络上传机制
- 失败恢复和重试功能

### Phase 3: 错误捕获系统 (Week 5-6)
**目标**: 实现全面的错误捕获机制

**任务清单**:
- [ ] 实现GlobalErrorHandler
- [ ] 添加JavaScript/Promise/Vue错误捕获
- [ ] 实现控制台错误拦截
- [ ] 集成资源加载错误捕获
- [ ] 创建错误展示界面

**交付物**:
- 完整的错误捕获系统
- 所有类型错误的统一处理
- 错误监控和展示界面

### Phase 4: 性能监控系统 (Week 7-8)
**目标**: 实现API和页面性能监控

**任务清单**:
- [ ] 实现ApiPerformanceInterceptor
- [ ] 创建PerformanceMonitor类
- [ ] 集成到HTTP客户端
- [ ] 添加慢API告警机制
- [ ] 创建性能监控界面

**交付物**:
- API性能监控和告警
- 页面性能指标收集
- 性能数据可视化界面

### Phase 5: 用户追踪和告警 (Week 9-10)
**目标**: 实现用户行为追踪和告警系统

**任务清单**:
- [ ] 实现UserTracker类
- [ ] 创建AlertEngine告警引擎
- [ ] 实现告警规则配置
- [ ] 添加通知机制
- [ ] 创建用户行为分析界面

**交付物**:
- 完整的用户行为追踪
- 智能告警系统
- 用户路径分析功能

### Phase 6: 服务端集成 (Week 11-12)
**目标**: 完成服务端接收和分析系统

**任务清单**:
- [ ] 创建服务端API接口
- [ ] 实现数据库存储逻辑
- [ ] 创建日志分析服务
- [ ] 实现开发商监控后台
- [ ] 集成告警通知服务

**交付物**:
- 完整的服务端日志系统
- 开发商监控和分析后台
- 端到端的日志管理闭环

## 🔧 部署和运维

### 环境配置
```bash
# 开发环境
VITE_LOG_LEVEL=DEBUG
VITE_LOG_API_URL=http://localhost:5000
VITE_ENABLE_CONSOLE_CAPTURE=true
VITE_MAX_LOG_BATCH_SIZE=10

# 生产环境  
VITE_LOG_LEVEL=WARN
VITE_LOG_API_URL=https://logs.yourdomain.com
VITE_ENABLE_CONSOLE_CAPTURE=true
VITE_MAX_LOG_BATCH_SIZE=50
```

### 监控指标
- **日志收集率**: 目标 >99%
- **上传成功率**: 目标 >95%
- **处理延迟**: 目标 <5秒
- **存储效率**: 目标压缩率 >60%
- **告警及时性**: 目标 <30秒

### 成功标准
1. **完整性**: 所有错误类型100%捕获
2. **可靠性**: 网络异常时不丢失日志
3. **性能**: 不影响主应用响应速度
4. **可用性**: 服务端可查看所有客户端日志
5. **智能性**: 自动识别和告警重要问题

---

**文档版本**: v1.0  
**创建时间**: 2024-01-15  
**最后更新**: 2024-01-15  
**负责人**: 开发团队  
**审核状态**: 待审核
